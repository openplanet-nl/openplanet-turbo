/** 
 *	In-Game UI library
 */
 

#Include "TextLib" as TL

#Include "Libs/Nadeo/Anim.Script.txt" 										as Anim
#Include "Libs/Nadeo/Manialink2.Script.txt"  								as Manialink
#Include "Libs/Nadeo/Layers2.Script.txt" 									as Layers
#Include "Libs/Nadeo/TMConsole/HSVColors.Script.txt" 						as Hue
#Include "Libs/Nadeo/TMConsole/FontManager.Script.txt" 						as Font
#Include "Libs/Nadeo/TMConsole/Ingame/Medals.Script.txt" 					as Medals
#Include "Libs/Nadeo/TMConsole/Colors.Script.txt" 							as Colors
#Include "Libs/Nadeo/TMConsole/Volumes.Script.txt" 							as Volumes
#Include "Libs/Nadeo/TMConsole/Ingame/UI/UI_CheatCode.Script.txt" 			as UICheatCode
#Include "Libs/Nadeo/TMConsole/Ingame/UI/UIBindingPadButtons.Script.txt" 	as UIBindingPadButtons
#Include "Libs/Nadeo/UIPadButtons.Script.txt"								as UIButtons
#Include "Libs/Nadeo/TMConsole/Ingame/UI/UIPopupBuilder.Script.txt"			as UIPopupBuilder
#Include "Libs/Nadeo/TMConsole/Prompter2.Script.txt"						as Prompter2
#Include "Libs/Nadeo/TMConsole/Ingame/UI/SplitScreenLibManialinkCoef.Script.txt"	as SplitScreenLibManialinkCoef
#Include "Libs/Nadeo/TMConsole/Ingame/UI/UILastDeviceUsed.Script.txt" 					as UILastDeviceUsed

#Const Version		"2016-03-01"
#Const ScriptName	"UI.Script.txt"

#Const IMGPATH								"file://Media/Images/TMConsole/Ingame/"
#Const SOUNDPATH							"file://Media/Sounds/TMConsole/"
#Const SOUNDPATH_VOICES						"file://Media/Sounds/TMConsole/Voices/"
#Const VIDEOPATH							"file://Media/Manialinks/Nadeo/TMConsole/Video/"

//////////////////////////////////////////
// IMAGES
#Const IMG_PRESS_TO_RESTART_BG				"press-to-restart-bg.dds"
#Const IMG_DOUBLEDRIVER_LOGO				"dd-logo.dds"
#Const IMG_FG								"slot-medium-fg.dds"
#Const IMG_BG								"slot-medium-bg.dds"
#Const IMG_BG_LINE							"menu-bg-1.dds"
#Const IMG_LAP								"lap.dds"
#Const IMG_ENGINE_OFF						"engine-off.dds"
#Const IMG_ENGINE_ON						"engine-on.dds"
#Const IMG_MEDAL_EMPTY						"medal-empty.dds"
#Const IMG_TURBO							"turbo.dds"
#Const IMG_RTLOGO01							"randomtracklogo01.png"
#Const IMG_RTLOGO02							"randomtracklogo02.png"

#Const IMG_INTRO_3							"race-3.dds"
#Const IMG_INTRO_2							"race-2.dds"
#Const IMG_INTRO_1							"race-1.dds"
#Const IMG_INTRO_GO							"race-go.dds"
#Const IMG_INTRO_GO2						"race-go2.dds"
#Const IMG_INTRO_GLOW_3						"race-3-glow.dds"
#Const IMG_INTRO_GLOW_2						"race-2-glow.dds"
#Const IMG_INTRO_GLOW_1						"race-1-glow.dds"
#Const IMG_INTRO_GLOW_GO					"race-go-glow.dds"


//////////////////////////////////////////
// SOUNDS
#Const SOUND_VOICE_CHECKPOINT_1				"Voices/voice-checkpoint-1.wav"
#Const SOUND_VOICE_CHECKPOINT_2				"Voices/voice-checkpoint-2.wav"
#Const SOUND_VOICE_CHECKPOINT_3				"Voices/voice-checkpoint-3.wav"
#Const SOUND_VOICE_CHECKPOINT_4				"Voices/voice-checkpoint-4.wav"
#Const SOUND_VOICE_CHECKPOINT_YES			"Voices/voice-checkpoint-yes-"
#Const SOUND_VOICE_CHECKPOINT_NO			"Voices/voice-checkpoint-no-"
#Const SOUND_VOICE_CARHIT					"Voices/voice-carhit-"
#Const SOUND_SPEEDEFFECT 					"event-speedeffect.wav"
#Const SOUND_CHECKPOINT_TIME 				"checkpoint-time.wav"
#Const SOUND_CHECKPOINT_NO 					"checkpoint-no.wav"
#Const SOUND_CHECKPOINT_YES 				"checkpoint-yes.wav"
#Const SOUND_CHECKPOINT_LAP 				"checkpoint-lap.wav"
#Const SOUND_ENDRACE_YES 					"endrace-yes.wav"
#Const SOUND_ENDRACE_NO						"endrace-no.wav"
#Const SOUND_CROWD_YES						"checkpoint-crowd-yes.ogg"
#Const SOUND_CROWD_NO						"checkpoint-crowd-no.ogg"
#Const SOUND_WHOOSHTEST 					"whooshtest-mono.wav"
#Const SOUND_SHOWLINE 						"event-woosh-small.wav"
#Const SOUND_RACE_1 						"race-1.wav"
#Const SOUND_RACE_2 						"race-2.wav"
#Const SOUND_RACE_3 						"race-3.wav"
#Const SOUND_RACE_GO						"race-go.wav"
#Const SOUND_DRIFTRISE 						"skid-gauge.wav"
#Const SOUND_ISFLYING 						"state-flying.ogg"
#Const SOUND_ISFREEWHEEL					"state-freewheel.ogg"
	



//////////////////////////////////////////
// VIDEO

#Const VIDEO_SPEEDSTEP   					"video_smoke_green.webm"
#Const VIDEO_BGANIM_MESSAGE					"hud_bganim_msg.webm"

//////////////////////////////////////////
// ALIGN

#Const vT 	""" valign="top" """
#Const vB 	""" valign="bottom" """
#Const vC 	""" valign="center" """
#Const hC 	""" halign="center" """
#Const hR 	""" halign="right" """



//////////////////////////////////////////
// NON-SETTINGS CONST

#Const C_LAYERNAME_PADS 					"Layer_MML_PadsPopup"
#Const C_LAYERNAME_PRESS_TO_RESTART			"PressToRestart"
#Const C_LAYERNAME_UI						"Race"
#Const C_LAYERNAME_UICHEATCODE				"UICheatCode"
#Const C_LAYERNAME_321GO					"321Go"
#Const C_LAYERNAME_TIMEOUT					"TimeOut"

#Const C_RATIO 								12.962

#Const C_LEFT								0
#Const C_HCENTER							1
#Const C_RIGHT								2
#Const C_NONE								3

#Const C_RATIO_1CIRCLE						0.06666666667
#Const C_DURATION_LABELSHOW					2000
#Const C_DELAY_LAP							0
#Const C_DELAY_ENDRACE						1500



//////////////////////////////////////////
// RACE ML SETTINGS

#Const C_RACE_CLIP_OFFSET 					0.2
#Const C_RACE_FREEWHEEL_SIZE_X 				46.
#Const C_RACE_MAPNAME_SIZE_X 				70.
#Const C_RACE_MAPNAME_TEXTSIZE_SIGN 		5
#Const C_RACE_MAPNAME_TEXTSIZE_NAME			7
#Const C_RACE_MAPNAME_MARGIN_SIGN			3
#Const C_RACE_MAPNAME_POSX_MEDAL			-1
#Const C_RACE_MAPNAME_SIZE_MEDAL			18
#Const C_RACE_MAPNAME_POSY_LAP				-11.5
#Const C_RACE_MAPNAME_POSY_LAPTEXT			-1.5
#Const C_RACE_MAPNAME_SIZE_LAP				6
#Const C_RACE_SPEEDVIDEO_SIZERATIO			1.02
#Const C_RACE_DOUBLEDRIVER_LOGO_SIZEX		52



//////////////////////////////////////////
// 321GO ML SETTINGS

#Const C_INTRO_QUAD_SIZE 					37
#Const C_INTRO_QUAD_OPACITY 				.8
#Const C_INTRO_QUAD_OPACITY_NORMAL 			1.
#Const C_INTRO_POSX							0
#Const C_INTRO_POSY 						0



//////////////////////////////////////////
// REWARD ML SETTINGS

#Const C_REWARDS_TRANSITION_SIZE_X			1012.5
#Const C_REWARDS_BUTTON_SIZE_X				10
#Const C_REWARDS_TEXT_INTERVAL				-0.13
#Const C_REWARDS_PRESSTOCONTINUE_INTERVAL	1
#Const C_REWARDS_PRESSTOCONTINUE_POSY		-75



//////////////////////////////////////////
// PRESS TO RESTART ML SETTINGS

#Const C_PRESSTORESTART_IMG_SIZE 			60
#Const C_PRESSTORESTART_TEXT_SIZE 			4
#Const C_PRESSTORESTART_TEXT_INTERLIGN 		-0.5



//////////////////////////////////////////
// SPEED COUNTER 

#Const C_SPEED_SIZEGAUGE					30.
#Const C_SPEED_SIZEGAUGE_RATIO				1.75
#Const C_SPEED_FULLCIRCLEVALUE				400.
#Const C_GAUGE_OPACITY						0.6
#Const C_GAUGEPERSISTENT_OPACITY			0.5
#Const C_GAUGEPERSISTENT_FADEDURATION		3000



//////////////////////////////////////////
// CHECKPOINT TIMER SETTINGS

// THE TEXT SIZE IS THE DEFAULT ONE USED OTHER COUNTERS (C_TEXT_DEFAUTSIZE), WITH A SCALE APPLIED TO THE WHOLE FRAME (C_TEXT_CHECKPOINT_SCALE)
#Const C_TEXT_CHECKPOINT_SCALE 				1.

#Const C_Y_SPACEBETWEEN_CHECKPOINTTIME		11.
#Const C_X_SPACEBETWEEN_CHECKPOINTTIME		40.

#Const C_CHECKPOINT_SHOW_DURATION			3000



//////////////////////////////////////////
// GENERAL SETTINGS

#Const C_TEXT_DEFAUTSIZE 					5

// HERE TO SET THE UI MARGINS FOR THE "90%"
// 1. = 10% Vertically & 10% Horizontally (16/9)
#Const C_MARGINS_GLOBALRATIO				1.


#Const C_WHITE_OPACITY						0.85
#Const C_SPEED_ANIM_BLINKSPEED				0.0125
#Const C_SPEED_SLOWANIM_BLINKSPEED			0.0185
#Const C_TURBO_ANIM_BLINKSPEED				0.100
#Const C_PERFECT_LANDING_ANIM_BLINKSPEED	0.040
#Const C_COMBO_ALMOST_FINISHED_BLINKSPEED	0.040
#Const C_COMBO_ALMOST_FINISHED_DURATION		1000


#Const C_COMMENTARIES_MAXCOUNT_CP_YES 		23
#Const C_COMMENTARIES_MAXCOUNT_CP_NO 		38
#Const C_COMMENTARIES_MAXCOUNT_ENDRACE_YES 	18
#Const C_COMMENTARIES_MAXCOUNT_ENDRACE_NO 	37
#Const C_COMMENTARIES_MAXCOUNT_CARHIT 		16

#Const C_COMMENTARIES_CARHIT_MIN_INTERVAL	2000
#Const C_COMMENTARIES_TOPLAY_EACH_XX_CP_MIN	2
#Const C_COMMENTARIES_TOPLAY_EACH_XX_CP_MAX 4
#Const C_COMMENTARIES_DELAY					400

#Const TMC_MEDAL_AUTHOR						0
#Const TMC_MEDAL_GOLD						1
#Const TMC_MEDAL_SILVER						2
#Const TMC_MEDAL_BRONZE						3
#Const TMC_MEDAL_PLAYER						4
#Const TMC_MEDAL_NONE						5
#Const TMC_MEDAL_ANOTHERPLAYER				6

// #Const C_CAMPAIGNAUTHOR						"$s$fffNANDO "



declare CTmMode	G_Mode;
declare Text 	G_ModeName;
declare Boolean G_CheatUniqueCamera;
declare Integer G_SpawnDuration;
	
declare Text 	G_FontTitle;
declare Text 	G_FontMain;
declare Text 	G_FontMainSmall;
declare Text 	G_FontChrono;
declare Text 	G_FontNumberBig;




// ---------------------------------- //
/** Create the Race manialink
 *
 *	@return	The manialink Text
 */

Text Private_GetMLRace(Real _Scale, Real _PosXRatio, Real _SpecialScale) {
	Prompter2::Load();
	
	declare ColorWhite 					= Colors::GetColor		("White");
	declare ColorYellow					= Colors::GetColor		("Yellow");
	declare ColorXmlWhite 				= Colors::GetColorXml	("White");
	declare ColorXmlRed 				= Colors::GetColorXml	("Red");
	declare ColorXmlGreen 				= Colors::GetColorXml	("Green");
	
	////////////////////////////
	// DYNAMIC SETTINGS         
	
	declare MapMarginRatio 				= 1.  * C_MARGINS_GLOBALRATIO;
	declare SeriesNameMarginX			= 16. * MapMarginRatio;
	declare MapNameMarginY				= 9.  * MapMarginRatio;
	
	declare MarginGaugeRatio 			= 0.5 * C_MARGINS_GLOBALRATIO;
	
	////////////////////////////
	// CALCULATIONS             
	
	declare CircleSize					= C_RATIO_1CIRCLE * C_RACE_MAPNAME_SIZE_X;
	
	declare MapNameSizeY 				= C_RACE_MAPNAME_SIZE_X / C_RATIO;
	declare MapNameSeparator 			= MapNameSizeY * 0.095;
	declare MapNameSizeYElement			= MapNameSizeY * 2. - MapNameSeparator;
	declare MapNameSizeXElement			= C_RACE_MAPNAME_SIZE_X * C_RATIO_1CIRCLE * 13.;
	declare MapNamePosXSign				= - MapNameSizeXElement + C_RACE_MAPNAME_MARGIN_SIGN;
	declare MapNamePosYSign				= - 1;
	declare MapNamePosXName				= MapNamePosXSign + C_RACE_MAPNAME_MARGIN_SIGN + 1.;
	declare MapNamePosYName				= - MapNameSizeY + 0.5;
	declare MapNamePosYMedal			= - MapNameSizeY;
	
	declare OpponentScreenMarginsRatio 	= 1. * C_MARGINS_GLOBALRATIO;
	declare OpponentScreenMarginsY		= 9 * OpponentScreenMarginsRatio;
	
	declare OpponentSizeX				= C_RACE_MAPNAME_SIZE_X;
	declare OpponentSizeY				= MapNameSizeY;
	declare OpponentSizeXElement		= MapNameSizeXElement;
	declare OpponentSizeYElement		= MapNameSizeY - MapNameSeparator;
	declare OpponentMargins				= 1.5;
	declare OpponentTimeSizeRatio 		= 0.66;
	
	declare OpponentNamePosX			= 1.;
	declare OpponentTimePosX			= OpponentSizeXElement - 2;
	declare OpponentTimeDiffPosX		= OpponentTimePosX;
	declare OpponentTextPosY			= OpponentSizeY * 0.5 - 0.25;
	declare OpponentTextsSizeX			= OpponentSizeX - OpponentNamePosX - OpponentMargins;
	declare OpponentTimeSizeX			= OpponentTimeSizeRatio * OpponentTextsSizeX;
	declare OpponentTimeDiffSizeX		= OpponentTextsSizeX - OpponentTimeSizeX;
	
	declare TurboSizeX 					= 22;
	declare TurboSizeY 					= TurboSizeX / 2.;
	
	declare OpponentMedalSizeX 			= OpponentSizeYElement * 2.704;
	
	declare MarginYChrono				= 9. * C_MARGINS_GLOBALRATIO;
	
	declare PosXGauge					=  ( 160 * _PosXRatio - C_SPEED_SIZEGAUGE * 0.5 * C_SPEED_SIZEGAUGE_RATIO - 9 * MarginGaugeRatio);
	declare PosYGauge					= -( 90	 - C_SPEED_SIZEGAUGE * 0.5 * C_SPEED_SIZEGAUGE_RATIO - 9  * MarginGaugeRatio);
	
	declare LapsToGoCenterY				= 90 - MapNameMarginY - MapNameSizeY*4.5;
	
	// log(OpponentSizeYElement);
	////////////////////////////
	// STYLES                   
	
	declare TextStyleMain				= """ textfont="{{{G_FontMain}}}" textsize="3" scale="0.95" """;
	declare TextStyleMainSmall			= """ textfont="{{{G_FontMainSmall}}}" textsize="3" scale="0.95" """;
	declare TextStyleCheckpoints		= """ {{{vB^hC}}} textfont="{{{G_FontChrono}}}" textsize="{{{C_TEXT_DEFAUTSIZE}}}" text="--:--.--" """;
	declare QuadStyleBg					= """ sizen="{{{C_RACE_MAPNAME_SIZE_X}}} {{{MapNameSizeY}}}" image="{{{IMGPATH^IMG_BG_LINE}}}" """;
	declare QuadStyleBgRight			= """ {{{QuadStyleBg}}} {{{hR}}} """;
	declare QuadStyleMedal				= """ sizen="{{{C_RACE_MAPNAME_SIZE_MEDAL}}} {{{C_RACE_MAPNAME_SIZE_MEDAL}}}"	{{{vC^hR}}}  """;
	declare QuadStyleGauge				= """ posn="0 0 .2" sizen="{{{C_SPEED_SIZEGAUGE*0.5}}} {{{C_SPEED_SIZEGAUGE}}}" {{{vC^hR}}} """;
	declare FreeWheelStyle				= """ posn="0. 15. 	1." sizen="{{{C_RACE_FREEWHEEL_SIZE_X}}} {{{C_RACE_FREEWHEEL_SIZE_X/2.}}}" {{{hC}}} {{{vB}}} hidden="1" """;
	declare LapStyle					= """ sizen="{{{C_RACE_MAPNAME_SIZE_X-10}}} {{{MapNameSizeY}}}" textsize="{{{C_RACE_MAPNAME_TEXTSIZE_NAME}}}"  textcolor="{{{Colors::GetColorXml("Black")}}}"	{{{vC}}} 	 """;
	
	declare MusicBoosterName			= UIBindingPadButtons::GetMusicBoostKeyCode();
	
	declare Text ML = """
<framemodel id="Framemodel_PlayerCard">
	<quad  id="Quad_Avatar" 	posn="{{{OpponentNamePosX}}}    	{{{-MapNameSeparator}}}	.2" 	sizen="{{{OpponentMedalSizeX}}} {{{OpponentSizeYElement}}}" 	bgcolor="333" hidden="1" />
	<label id="Label_Name" 		posn="{{{OpponentNamePosX}}} 		{{{-OpponentTextPosY}}} .2" 	sizen="45.0 1.0" {{{vC}}} {{{TextStyleMain}}} text="GABRIEL"	 textprefix="$t"/>
	<label id="Label_Time" 		posn="{{{OpponentTimePosX+4.5}}} 		{{{-OpponentTextPosY}}} .2" 	sizen="{{{OpponentTimeSizeX}}}" 	{{{vC}}} {{{hR}}} 	{{{TextStyleMainSmall}}} text="00:00.00"  />
	<label id="Label_TimeDiff" 	posn="{{{OpponentTimeDiffPosX+4.5}}}	{{{-OpponentTextPosY}}} .2" 	sizen="{{{OpponentTimeDiffSizeX}}}" {{{vC}}} {{{hR}}} 	{{{TextStyleMainSmall}}} text="-00:00.00" />
	<quad 						posn="0.  							{{{-MapNameSeparator}}}	.1"  	sizen="{{{MapNameSizeXElement+4.5}}} {{{OpponentSizeYElement}}}" {{{vT}}} 	image="{{{IMGPATH^IMG_BG}}}" />
	<quad 						posn="0.  							{{{-MapNameSeparator}}} 1." 	sizen="{{{MapNameSizeXElement+4.5}}} {{{OpponentSizeYElement}}}" {{{vT}}} 	image="{{{IMGPATH^IMG_FG}}}" />
</framemodel>

<framemodel id="Frame_BigCounter">
	<label id="Label_Title" 	posn=" 0.  0.   0."   {{{vT}}}  {{{TextStyleMain}}} text=""/>
	<label id="Label_Value" 	posn="-0. -0.25 0."   {{{vB}}}  textsize="11"  textfont="{{{G_FontNumberBig}}}" text=""/>
</framemodel>	

	<frame id="Frame_Hud" scale="{{{_Scale}}}" hidden="1">	
		
		<frame id="Frame_MapName" posn="{{{- 160 * _PosXRatio + C_RACE_MAPNAME_SIZE_X}}} {{{90 - MapNameMarginY}}} 31."  hidden="1">
		<frame id="Frame_MapNameAnim">
			<quad id="Quad_DoubleDriverLogo" posn="{{{-MapNameSizeXElement}}} {{{-MapNameSizeYElement*1.75}}} -1."  	sizen="{{{C_RACE_DOUBLEDRIVER_LOGO_SIZEX}}} 		{{{C_RACE_DOUBLEDRIVER_LOGO_SIZEX/2.}}}" image="{{{IMGPATH^IMG_DOUBLEDRIVER_LOGO}}}" hidden="1" />
			
			<frame id="Frame_MapNameBg">
				<quad id="Quad_Bg1" posn="0. 0. 				   30." 	{{{QuadStyleBgRight}}} />
				<quad id="Quad_Bg2" posn="0. {{{-MapNameSizeY}}}   30." 	{{{QuadStyleBgRight}}} />
			</frame>
			<quad id="Quad_Bg3" posn="0. {{{-MapNameSizeY*2}}} 30." 	{{{QuadStyleBgRight}}} />
			<frame id="Frame_MusicBg" hidden="1">
				<quad id="Quad_Bg4" posn="0. {{{-MapNameSizeY*3}}}   30." 	{{{QuadStyleBgRight}}} />
			</frame>

			<frame id="Frame_MapNameContent">
				<frame id="Frame_NormalMode">
					<quad 	posn="0.  	{{{-MapNameSeparator}}}			31."  	sizen="{{{MapNameSizeXElement}}} 		{{{MapNameSizeYElement}}}" 	{{{vT}}} 	{{{hR}}} image="{{{IMGPATH^IMG_BG}}}" />
					<quad 	posn="0.  	{{{-MapNameSeparator}}}			32."  	sizen="{{{MapNameSizeXElement}}} 		{{{MapNameSizeYElement}}}" 	{{{vT}}} 	{{{hR}}} image="{{{IMGPATH^IMG_FG}}}" /> 
					<frame clip="True" clipsizen="{{{MapNameSizeXElement}}} {{{MapNameSizeYElement*0.9}}}" clipposn="{{{-C_RACE_MAPNAME_SIZE_X*0.5 + CircleSize}}} {{{-MapNameSizeY}}}">
						<frame id="Frame_CampaignMapContent">
							<label 	id="Label_NumberSign" 	posn="{{{MapNamePosXSign}}} 	 {{{MapNamePosYSign}}} 	  31.1" 		textsize="{{{C_RACE_MAPNAME_TEXTSIZE_SIGN}}}"  textfont="{{{G_FontMain}}}" textcolor="{{{ColorXmlWhite}}}" text="#"/>
							<label 	id="Label_MapName"		posn="{{{MapNamePosXName}}} 	 {{{MapNamePosYName}}} 	  31.1"	 	textsize="{{{C_RACE_MAPNAME_TEXTSIZE_NAME}}}"  textfont="{{{G_FontNumberBig}}}" {{{vC}}} text="000" />
							<frame  id="Frame_Medal">
								<quad 	id="Quad_Medal" 		posn="{{{C_RACE_MAPNAME_POSX_MEDAL}}} 	 {{{MapNamePosYMedal}}}   31.2" 		{{{QuadStyleMedal}}} image="" />
								<quad 	id="Quad_MedalBg" 		posn="{{{C_RACE_MAPNAME_POSX_MEDAL}}} 	 {{{MapNamePosYMedal}}}   31.1" 		{{{QuadStyleMedal}}} image="{{{IMGPATH^IMG_MEDAL_EMPTY}}}" />
							</frame>	
							<quad 	id="Quad_Lap" 			posn="{{{MapNamePosXSign-2.}}} 	  		 -4.5 	  .4" 		sizen="{{{C_RACE_MAPNAME_SIZE_LAP}}} 	{{{C_RACE_MAPNAME_SIZE_LAP}}}"  image="{{{IMGPATH}}}{{{IMG_LAP}}}" colorize="{{{ColorXmlWhite}}}" />
						</frame>
					</frame>
				</frame>

				<frame id="Frame_RandomMapContent">
					<quad id="Quad_RTLogo01" 		posn="{{{MapNamePosXSign}}} 	 {{{MapNamePosYMedal}}}   31.1" 	sizen="24 12" image="{{{IMGPATH^IMG_RTLOGO01}}}"  {{{vC}}}/>
					<quad id="Quad_RTLogo02" 		posn="{{{MapNamePosXSign+25}}} 	 {{{MapNamePosYMedal}}}   31.1" 	sizen="24 12" image="{{{IMGPATH^IMG_RTLOGO02}}}"  {{{vC}}}/>
				</frame>
				
				<frame id="Frame_ChampionshipMode">
					<quad 	posn="0.  	{{{-MapNameSeparator}}}			31."  	sizen="{{{MapNameSizeXElement}}} 		{{{OpponentSizeY}}}" 	{{{vT}}} 	{{{hR}}} image="{{{IMGPATH^IMG_BG}}}" />
					<quad 	posn="0.  	{{{-MapNameSeparator}}}			32."  	sizen="{{{MapNameSizeXElement}}} 		{{{OpponentSizeY}}}" 	{{{vT}}} 	{{{hR}}} image="{{{IMGPATH^IMG_FG}}}" /> 				
					
					{{{Prompter2::InjectInManialink("ChampionshipTrackName", <-29.5, -2.5, 31.2>, <57., 50.>, 3, G_FontMain, """textcolor="{{{Colors::GetColorXml("White")}}}" """)}}}
					<label id="Label_ChampionshipName"	posn="{{{MapNamePosXName-5.}}} -1.0 31.2"	 {{{TextStyleMain}}} textcolor="{{{Colors::GetColorXml("White")}}}"/>
				</frame>
				
				<frame id="Frame_Music">
					<quad 	posn="0.  	{{{-MapNameSizeY*2}}}			31."  	sizen="{{{MapNameSizeXElement}}} {{{OpponentSizeY}}}" 	{{{vT}}} {{{hR}}} image="{{{IMGPATH^IMG_BG}}}" />
					<quad 	posn="0.  	{{{-MapNameSizeY*2}}}			32."  	sizen="{{{MapNameSizeXElement}}} {{{OpponentSizeY}}}" 	{{{vT}}} {{{hR}}} image="{{{IMGPATH^IMG_FG}}}" /> 
					<quad 	id="Quad_MusicBg" posn="0. {{{-MapNameSizeY*2}}} 31.2" sizen="{{{MapNameSizeXElement}}} {{{OpponentSizeY}}}" 	{{{vT}}} {{{hR}}} bgcolor="{{{Colors::GetColorXml("White")}}}" hidden="0" />
					<quad 	id="Quad_ButtonBoost" posn="-56.7 {{{-MapNameSizeY*2.44}}} 31.5" sizen="6 6" {{{vC}}} {{{hC}}} image="{{{UIButtons::GetAlternateImage("View")}}}"/>
					{{{UIBindingPadButtons::InjectInManialink(C_LAYERNAME_UI, MusicBoosterName, <-55.7, -MapNameSizeY*2.44, 31.5>, 0.4)}}}
					{{{Prompter2::InjectInManialink("MusicName", <-25.5, -13., 31.2>, <48.5, 50.>, 3, G_FontMain, """textcolor="{{{Colors::GetColorXml("Black")}}}" """)}}}
				</frame>
			</frame>
		</frame>	
	</frame>
		
		<frame id="Frame_Engine" posn="0. 20. 0." >	
			<quad 	id="Quad_EngineOff" {{{FreeWheelStyle}}} colorize="{{{ColorXmlRed}}}" image="{{{IMGPATH^IMG_ENGINE_OFF}}}" />
			<quad 	id="Quad_EngineOn" 	{{{FreeWheelStyle}}} colorize="{{{ColorXmlGreen}}}" image="{{{IMGPATH^IMG_ENGINE_ON}}}"/>
		</frame>
		
		<frame id="Frame_Chrono" posn="0.0 {{{-(90 - MarginYChrono)}}} 1">
			<label id="Label_Chrono" {{{hC^vB}}} textfont="{{{G_FontChrono}}}"  textsize="{{{C_TEXT_DEFAUTSIZE}}}" text="--:--.--" />
		</frame>
		
		<frame id="Frame_Checkpoints" 			hidden="0" posn="0. {{{-(90 - MarginYChrono)}}} 1" scale="{{{C_TEXT_CHECKPOINT_SCALE}}}">
			<label id="Label_CheckpointLap"  	hidden="0" posn="0. {{{C_Y_SPACEBETWEEN_CHECKPOINTTIME}}} 1." 	{{{TextStyleCheckpoints}}} textcolor="{{{Colors::GetColorXml("Yellow")}}}" />
			<label id="Label_CheckpointDiff" 	hidden="0" posn="0. 0.	1."  									{{{TextStyleCheckpoints}}} />
		</frame>
			
		<frame id="Frame_ModeName" posn="-{{{160 * _PosXRatio - 2}}} 88">
			<label id="Label_ModeName" posn="0 0 3"  text="$ff0SUPER  $fffMODE"  {{{vT}}} textsize="8" textfont="{{{G_FontMain}}}" />
		</frame>

		<frameinstance id="Frame_DriftInfo" posn="-157. -74. 3" modelid="Frame_BigCounter" />
		<frameinstance id="Frame_JumpInfo" 	posn="137. 	 74. 3" modelid="Frame_BigCounter" />
		<frameinstance id="Frame_HeightInfo" 	posn="137. 	 148. 3" modelid="Frame_BigCounter" hidden="1"/>
		
		<label hidden="1" id="Label_SeriesName" 	posn="-{{{160 - SeriesNameMarginX}}} -{{{90 - MapNameMarginY - 3}}} 3"    {{{vT}}} {{{TextStyleMain}}} text="STADIUM GREEN SERIES"/>
		
		<frame scale="{{{_SpecialScale}}}" posn="{{{- 160 * _PosXRatio}}} {{{LapsToGoCenterY}}}" >
			<frame id="Frame_LapsToGo" posn="{{{C_RACE_MAPNAME_SIZE_X}}} {{{MapNameSizeY*1.5}}}"  hidden="0">
				<frame id="Frame_LapsToGoAnim">
					<frame id="Frame_LapsToGoAnimOnChange">
						<quad id="Quad_Bg1" posn="0. 0. 				   -8.1" 	{{{QuadStyleBgRight}}} />
						<quad id="Quad_Bg2" posn="0. {{{-MapNameSizeY}}}   -8.1" 	{{{QuadStyleBgRight}}} />
						<quad id="Quad_Bg3" posn="0. {{{-MapNameSizeY*2}}} -8.1" 	{{{QuadStyleBgRight}}} />
						
						<frame id="Frame_LapsToGoContent">
							<frame id="Frame_LapsToGoContentOnChange">
								<frame 	id="Frame_Lap">
									<quad 	id="Quad_LapBg" 		posn="0. {{{-MapNameSeparator}}} 1.1"  	 sizen="{{{MapNameSizeXElement}}} 		{{{MapNameSizeYElement}}}" 	{{{vT}}} {{{hR}}} 	bgcolor="{{{Colors::GetColorXml("Yellow")}}}" 	hidden="0" />
									<quad 	id="Quad_MessageVideo" 	posn="0. {{{-MapNameSeparator}}} 1.3"  	 sizen="{{{MapNameSizeXElement}}} 		{{{MapNameSizeYElement}}}" 	{{{vT}}} {{{hR}}} 	image="" 	hidden="1" />
									<quad 							posn="0. {{{-MapNameSeparator}}} 2."  	 sizen="{{{MapNameSizeXElement}}} 		{{{MapNameSizeYElement}}}" 	{{{vT}}} {{{hR}}} 	image="{{{IMGPATH^IMG_FG}}}" /> 
									<frame posn="{{{-MapNameSizeXElement/2.}}} .1">
										<label 	id="Label_LapCurrent"		posn="-4. {{{-MapNameSizeYElement/2.}}}	1.5" textfont="{{{G_FontNumberBig}}}" 	{{{LapStyle}}} {{{hR}}}  text="3"  />						
										<label 	 							posn="0.  {{{-MapNameSizeYElement/2. +0.75}}}	1.5" textfont="{{{G_FontMain}}}" 		textsize="{{{C_RACE_MAPNAME_TEXTSIZE_NAME+3}}}"  textcolor="{{{Colors::GetColorXml("Black")}}}"	{{{vC}}} {{{hC}}}  text="/"  />						
										<label 	id="Label_LapMax" 			posn="2. {{{-MapNameSizeYElement/2.}}}	1.5" textfont="{{{G_FontNumberBig}}}" 	{{{LapStyle}}} 	  		 text="4"  />						
									</frame>	
								</frame>	
								<frame posn="0 {{{-MapNameSizeY*2.}}}">
									<quad 	posn="0.  	{{{-MapNameSeparator}}}			.1"  	sizen="{{{MapNameSizeXElement}}} 		{{{OpponentSizeYElement}}}" 	{{{vT}}} 	{{{hR}}} image="{{{IMGPATH^IMG_BG}}}" />
									<quad 	posn="0.  	{{{-MapNameSeparator}}}			1."  	sizen="{{{MapNameSizeXElement}}} 		{{{OpponentSizeYElement}}}" 	{{{vT}}} 	{{{hR}}} image="{{{IMGPATH^IMG_FG}}}" /> 
									<label 	id="Label_LapMessage" posn="{{{-MapNameSizeXElement/2.}}} {{{-OpponentSizeYElement/2.}}}	0.5" sizen="{{{MapNameSizeXElement-4.}}}" 	 textsize="3" textfont="{{{G_FontMain}}}" 	textcolor="{{{Colors::GetColorXml("White")}}}"	{{{vC}}} {{{hC}}} text="{{{_("Current lap")}}}" textprefix="$t" translate="1"  />						
								</frame>
							</frame>	
						</frame>	
					</frame>	
				</frame>	
			</frame>
		</frame>
		
		<frame id="Frame_Challenge" posn="{{{160 * _PosXRatio - OpponentSizeX-4.5}}} {{{90-OpponentScreenMarginsY}}}">
			<frame id="Frame_ChallengeAnim">
				<frame id="Frame_ChallengeContent">
					<frameinstance id="Frame_Opponent" 	posn="0 0 1" modelid="Framemodel_PlayerCard" />
					<frameinstance id="Frame_Player"	posn="0 {{{-OpponentSizeY}}} 1" modelid="Framemodel_PlayerCard" />
				</frame>
				<frame hidden="0">
					<quad id="Quad_Bg1" posn="0. 0. 				   -8.1" 	{{{QuadStyleBg}}} />
					<quad id="Quad_Bg1_1" posn="{{{OpponentSizeX-4.5}}} 0. 				   -8.1" 	{{{QuadStyleBg}}} />
					<quad id="Quad_Bg2" posn="0. {{{-MapNameSizeY}}}   -8.1" 	{{{QuadStyleBg}}} />
					<quad id="Quad_Bg2_1" posn="{{{OpponentSizeX-4.5}}} {{{-MapNameSizeY}}}   -8.1" 	{{{QuadStyleBg}}} />
					<quad id="Quad_Bg3" posn="0. {{{-MapNameSizeY*2}}} -8.1" 	{{{QuadStyleBg}}} />
					<quad id="Quad_Bg3_1" posn="{{{OpponentSizeX-4.5}}} {{{-MapNameSizeY*2}}} -8.1" 	{{{QuadStyleBg}}} />
				</frame>
			</frame>
		</frame>
		
		<!--
			<quad 	posn="0.  	{{{-MapNameSeparator}}}			31."  	sizen="{{{MapNameSizeXElement}}} 		{{{MapNameSizeYElement}}}" 	{{{vT}}} 	{{{hR}}} image="{{{IMGPATH^IMG_BG}}}" />
			<quad 	posn="0.  	{{{-MapNameSeparator}}}			32."  	sizen="{{{MapNameSizeXElement}}} 		{{{MapNameSizeYElement}}}" 	{{{vT}}} 	{{{hR}}} image="{{{IMGPATH^IMG_FG}}}" /> 
		-->
		
		<frame id="Frame_Speed" posn="{{{PosXGauge}}} {{{PosYGauge}}}" scale="{{{C_SPEED_SIZEGAUGE_RATIO}}}" hidden="0">
		
			<label 	id="Label_Speed" 		posn="0 0.1 	3"  {{{vC^hC}}}  textfont="{{{G_FontChrono}}}" textsize="{{{C_TEXT_DEFAUTSIZE}}}" text="---" />	
			<quad 	id="Quad_SpeedEffect" 	posn="0. -0.5   5"  {{{vC^hC}}} rot="-30" sizen="{{{C_SPEED_SIZEGAUGE*C_RACE_SPEEDVIDEO_SIZERATIO}}} {{{C_SPEED_SIZEGAUGE*C_RACE_SPEEDVIDEO_SIZERATIO}}}" image="{{{VIDEOPATH^VIDEO_SPEEDSTEP}}}" hidden="0" />	
			<quad 	id="Quad_Turbo" 		posn="-2 {{{C_SPEED_SIZEGAUGE/2.}}} 1" sizen="{{{TurboSizeX}}} {{{TurboSizeY}}}" valign="bottom" halign="center" image="{{{IMGPATH^IMG_TURBO}}}" colorize="fff" />
			
			<frame id="Frame_SpeedGauge">
				
				<frame id="Frame_ClipLeft" clip="True" clipposn="{{{-C_SPEED_SIZEGAUGE*0.25-C_RACE_CLIP_OFFSET+0.153}}} 0" clipsizen="{{{C_SPEED_SIZEGAUGE*0.5}}} 	{{{C_SPEED_SIZEGAUGE}}}" >
				""";
				
				for(I, 1, 3) ML ^= """
						<quad id="Quad_GaugePersistentLeft{{{I}}}"	{{{QuadStyleGauge}}} image="{{{IMGPATH}}}speed-gauge{{{I}}}.dds" rot="0"  opacity="0." />
						<quad id="Quad_GaugeLeft{{{I}}}"			{{{QuadStyleGauge}}} image="{{{IMGPATH}}}speed-gauge{{{I}}}.dds" rot="0"  opacity="{{{C_GAUGE_OPACITY}}}" />
				""";

				ML ^= """	
				</frame>
				
				<frame id="Frame_ClipRight" clip="True" clipposn="{{{C_SPEED_SIZEGAUGE*0.25+C_RACE_CLIP_OFFSET-0.152}}} 0" clipsizen="{{{C_SPEED_SIZEGAUGE*0.5}}} 	{{{C_SPEED_SIZEGAUGE}}}">
				""";
				
				
				
				for(I, 1, 3) ML ^= """
					<quad id="Quad_GaugePersistentRight{{{I}}}"		{{{QuadStyleGauge}}} image="{{{IMGPATH}}}speed-gauge{{{I}}}.dds" rot="180"  opacity="0." />
					<quad id="Quad_GaugeRight{{{I}}}"				{{{QuadStyleGauge}}} image="{{{IMGPATH}}}speed-gauge{{{I}}}.dds" rot="180"  opacity="{{{C_GAUGE_OPACITY}}}" />
				""";
				
				
				
				ML ^= """	
				</frame>
			</frame>
		</frame>
		

		
	</frame>

<script><!--

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "AnimLib" as AL

#Const DebugName  					"L_UI"

#Const C_MaxRotationLeft 			0.
#Const C_MaxRotationRight 			180.

#Const C_POS_FIRST 					<0., 0., 1.>
#Const C_POS_SECOND 				<0., -{{{OpponentSizeY}}}, 1.>

#Const TMC_MEDAL_AUTHOR   			0
#Const TMC_MEDAL_GOLD   			1
#Const TMC_MEDAL_SILVER   			2
#Const TMC_MEDAL_BRONZE   			3
#Const TMC_MEDAL_PLAYER  			4
#Const TMC_MEDAL_NONE   			5
#Const TMC_MEDAL_ANOTHERPLAYER		6

#Const C_GAMEPHASE_CHALLENGE		3
#Const C_GAMEPHASE_PREPARATION		0
#Const C_GAMEPHASE_GAME				1
#Const C_GAMEPHASE_POSTGAME			2

#Const TMC_MEDAL_RECORDCENTER		12

#Const C_HUE_RANGE 					0.59

#Const C_ANIMSHOW_OFFSET			40.
#Const C_ANIMSHOW_DURATION 			300
#Const C_ANIMSHOW_DELAY	 			100

#Const C_MESSAGE_DURATION_SCROLL	4500
#Const C_MESSAGE_DURATION_ANIM_IN	450
#Const C_MESSAGE_DURATION_ANIM_OUT	300
#Const C_MESSAGE_DURATION_FADE		120

#Const C_CHALLENGE_ANIM_DURATION 	500

#Const C_FREEWHEEL_OPACITY 			1.
#Const C_FREEWHEEL_SIN_SPEED_OFF 	0.01
#Const C_FREEWHEEL_SIN_SPEED_ON 	0.06
#Const C_FREEWHEEL_BACKON_DURATION 	1000

#Const C_CHECKPOINT_SIN_SPEED 		0.06

#Const C_LAPSTOGO_DURATION_HIDDEN 	450
#Const C_LAPSTOGO_DURATION_VISIBLE 	8000

#Const C_Device_Keyboard 	0
#Const C_Device_Pad 		1

declare Real G_FadeOpacity;
{{{UIBindingPadButtons::InjectInGlobals()}}}
{{{Prompter2::InjectInGlobals()}}}
{{{Anim::Inject("Minimal")}}}
{{{Hue::MLHSVColors()}}}
{{{Prompter2::InjectInFunctions()}}}
{{{UIButtons::GetMLFunctionPcButtons()}}}
{{{UIBindingPadButtons::InjectInFunctions()}}}

Text GetTimeDiffToText(Integer _TimeDiff, CTmMlPlayer _Player) 
{
	declare TimeDiffToText = TL::TimeToText(_TimeDiff, True);
	if (_TimeDiff >= 10) // EG : Pourquoi 10 et pas 0 ?
	{
		if(_TimeDiff < 600000) TimeDiffToText = "0"^TimeDiffToText;
		TimeDiffToText = "+"^TimeDiffToText;
	} 
	else if (_TimeDiff <= -10) 
	{
		if(_TimeDiff > -600000) TimeDiffToText = TL::Replace(TimeDiffToText, "-", "-0");
	} 
	else 
	{
		TimeDiffToText = "00:00.00";
	}
	
	return TimeDiffToText;
}

Vec3 GetTimeDiffColor(Integer _TimeDiff, CTmMlPlayer _Player) 
{
	if (_TimeDiff >= 10) return {{{Colors::GetColor("Red2")}}}; // (+)
	return {{{Colors::GetColor("BlueLight")}}};	// (-)
}

Real GetTimeDiffPosX(Integer _TimeDiff, CTmMlPlayer _Player) 
{
	if (_TimeDiff >= 10) return {{{-C_X_SPACEBETWEEN_CHECKPOINTTIME}}}; // (+)
	return {{{C_X_SPACEBETWEEN_CHECKPOINTTIME}}};	// (-)
}

Vec3 GetSeriesColorFromMapNumber(Integer _MapNumber)
{
	if		(_MapNumber >= 1 	&& _MapNumber <= 40) 	return {{{Colors::GetDifficultyColor(1)}}};
	else if	(_MapNumber >= 41 	&& _MapNumber <= 80) 	return {{{Colors::GetDifficultyColor(2)}}};
	else if	(_MapNumber >= 81 	&& _MapNumber <= 120) 	return {{{Colors::GetDifficultyColor(3)}}};
	else if	(_MapNumber >= 121 	&& _MapNumber <= 160) 	return {{{Colors::GetDifficultyColor(4)}}};
	else if	(_MapNumber >= 161 	&& _MapNumber <= 200) 	return {{{Colors::GetDifficultyColor(5)}}};
	
	return  <0.5, 0.5, 0.5>;
}

Text GetSeriesNameFromMapNumber(Integer _MapNumber)
{
	declare Text SeriesName;
	
	if		(_MapNumber >= 1 	&& _MapNumber <= 40) 	SeriesName = "WHITE";
	else if	(_MapNumber >= 41 	&& _MapNumber <= 80) 	SeriesName = "GREEN";
	else if	(_MapNumber >= 81 	&& _MapNumber <= 120) 	SeriesName = "BLUE";
	else if	(_MapNumber >= 121 	&& _MapNumber <= 160) 	SeriesName = "RED";
	else if	(_MapNumber >= 161 	&& _MapNumber <= 200) 	SeriesName = "BLACK";
		
	return SeriesName;
}

{{{Medals::GetMedalFunctions()}}}

Void PreloadSounds() 
{
	declare Text[] SoundsToPreload = [
	"{{{SOUNDPATH ^ SOUND_CHECKPOINT_TIME	}}}", 
	"{{{SOUNDPATH ^ SOUND_CHECKPOINT_NO		}}}", 
	"{{{SOUNDPATH ^ SOUND_CHECKPOINT_YES	}}}", 
	"{{{SOUNDPATH ^ SOUND_ENDRACE_YES		}}}", 
	"{{{SOUNDPATH ^ SOUND_ENDRACE_NO		}}}",
	"{{{SOUNDPATH ^ SOUND_CROWD_YES			}}}", 
	"{{{SOUNDPATH ^ SOUND_CROWD_NO			}}}",
	"{{{SOUNDPATH ^ SOUND_CHECKPOINT_LAP	}}}",
	"{{{SOUNDPATH ^ SOUND_SHOWLINE			}}}" 
	];
	foreach(Sound in SoundsToPreload) Audio.CreateSound(Sound);
}

Void GaugeUpdate(CMlQuad _QuadLeft, CMlQuad _QuadRight, Real _GaugeRatio)
{
	declare SecondHalf = (_GaugeRatio > 0.5 && _GaugeRatio <= 1.) || (_GaugeRatio > 1.5 && _GaugeRatio <= 2.) || (_GaugeRatio > 2.5 && _GaugeRatio <= 3.);

	if(SecondHalf)
	{
		declare GaugeRatioRight = 2.* (_GaugeRatio - 0.5);
		_QuadLeft 	.RelativeRotation 	= 0.;
		_QuadRight 	.RelativeRotation 	= 0 + 180 * GaugeRatioRight;
	} 
	else
	{
		declare GaugeRatioLeft 	= 2.*  _GaugeRatio ;
		_QuadLeft 	.RelativeRotation 	= -180 + 180 * GaugeRatioLeft;
		_QuadRight 	.RelativeRotation 	=  0.;
	}
}

Void SetGauges(CMlQuad[] _QuadsLeft, CMlQuad[] _QuadsRight, Real _GaugeRatio)
{
	
	declare Boolean Phase2 					= (_GaugeRatio > 1. && _GaugeRatio <= 2.);
	declare Boolean Phase3 					= (_GaugeRatio > 2. && _GaugeRatio <= 3.);
	
	if(Phase2)
	{
		_QuadsLeft[1]	.Visible 			= True;
		_QuadsRight[1]	.Visible 			= True;
		_QuadsLeft[2]	.Visible 			= False;
		_QuadsRight[2]	.Visible 			= False;
		_QuadsLeft[0]	.RelativeRotation 	= C_MaxRotationLeft;
		_QuadsRight[0]	.RelativeRotation 	= C_MaxRotationRight;
		GaugeUpdate(_QuadsLeft[1], _QuadsRight[1], _GaugeRatio);
	}
	else 
	if(Phase3)
	{
		_QuadsLeft[1]	.Visible 			= True;
		_QuadsRight[1]	.Visible 			= True;
		_QuadsLeft[2]	.Visible 			= True;
		_QuadsRight[2]	.Visible 			= True;
		_QuadsLeft[0]	.RelativeRotation 	= C_MaxRotationLeft;
		_QuadsRight[0]	.RelativeRotation 	= C_MaxRotationRight;
		_QuadsLeft[1]	.RelativeRotation 	= C_MaxRotationLeft;
		_QuadsRight[1]	.RelativeRotation 	= C_MaxRotationRight;
		GaugeUpdate(_QuadsLeft[2], _QuadsRight[2], _GaugeRatio);
	}
	else // (Phase1)
	{
		_QuadsLeft[1]	.Visible 			= False;
		_QuadsRight[1]	.Visible 			= False;
		_QuadsLeft[2]	.Visible 			= False;
		_QuadsRight[2]	.Visible 			= False;
		GaugeUpdate(_QuadsLeft[0], _QuadsRight[0], _GaugeRatio);
		
	}
}

Text GetTimeToText(Integer _Time)
{
	declare TimeText = TL::TimeToText(_Time, True);
	if(_Time < 600000) TimeText = "0"^TimeText;
	
	return TimeText;
}


Void UpdateCounter(CMlFrame _Frame, CMlLabel _LabelTitle, CMlLabel _LabelValue, Integer _Value, Boolean _VisibilityCondition, Vec3 _Pos, Real _SpeedImpact)
{
	declare Integer PrevValue 		for _Frame;
	declare Integer Trigger 		for _Frame;
	declare Integer TriggerFadeIn 	for _Frame;
	declare Boolean IsActive = False;
	
	if(_Value > PrevValue)
	{
		PrevValue 		= _Value;
		Trigger			= Now;
		IsActive		= True;
		_LabelValue.Value = ""^_Value;
		if(_Frame.Visible == False) TriggerFadeIn = Now;
	}
	
	declare OffsetY			= 20.;
	declare FadeDuration	= 500;
	declare FadeOutDuration	= 700;
	declare ShowDuration 	= 500 + FadeOutDuration; 
	
	declare FadeOutTrigger	= ShowDuration - FadeOutDuration;
	declare CurrTime		= Now - Trigger;
	declare CurrTimeFadeIn	= Now - TriggerFadeIn;
	declare CurrTimeFadeOut	= CurrTime - FadeOutTrigger;
	declare Opacity 		= 1.;
	
	if(CurrTime > ShowDuration)
	{
		PrevValue = 0;
		_Frame.Visible = False;
	}
	else
	{
		if(_VisibilityCondition) _Frame.Visible = True;
	}
	
	if(CurrTime > FadeOutTrigger) 
	{
		Opacity = AL::Ease("CircOut", CurrTimeFadeOut*1., 1., -1., FadeDuration*1.);
	}	
	else 
	if(CurrTimeFadeIn < FadeDuration) 
	{
		Opacity = AL::Ease("Linear", CurrTimeFadeIn*1., 0., 1., FadeDuration*1.);
	}
	
	Opacity *= G_FadeOpacity;
	
	_LabelValue.Opacity = Opacity;
	_LabelTitle.Opacity = Opacity;
	
	if(IsActive) 				
	{
		// (Value - MinValue) / MaxValue
		declare Ratio = (_Value - 50) / 600.;
		if		(Ratio > 1.) Ratio = 1.;
		else if	(Ratio < 0.) Ratio = 0.;
		declare Hue = Ratio * C_HUE_RANGE;
		_LabelTitle.TextColor = ToRGB(<Hue, 1., 1.>);
		_LabelValue.TextColor = ToRGB(<Hue, 1., 1.>);
		
		declare SpeedImpact = _SpeedImpact * GUIPlayer.DisplaySpeed / 1000.;
		declare Sinz		= 1.25 * SpeedImpact * ML::Sin(Now * 0.05);
		_Frame.RelativePosition = <_Pos.X + Sinz, _Pos.Y + Sinz, _Pos.Z>;
	}
	else 
	if(CurrTime > FadeOutTrigger)	
	{
		CheckToPlayMoveTo("CircOut", _Frame, Trigger+FadeOutTrigger, _Pos, <_Pos.X, _Pos.Y + OffsetY, _Pos.Z>, FadeOutDuration+15);
	}
	
	// DEBUG
	// _Frame.RelativePosition = <_Pos.X, _Pos.Y, _Pos.Z>;
	// _Frame.Visible = True;
	// _LabelValue.Opacity = 1.;
	// _LabelTitle.Opacity = 1.;
}



Void StopVideoQuad(CMlQuad _Quad) 
{
	_Quad.Hide();
	_Quad.Video_Rewind();
	_Quad.Video_IsPlaying = False;
}



Void PlayVideoQuad(CMlQuad _Quad, Integer _Duration) 
{
	StopVideoQuad(_Quad);
	_Quad.Video_IsPlaying = False;
	_Quad.Video_Rewind();
	_Quad.Show();
	_Quad.Video_IsPlaying = True;
	_Quad.Video_IsLooping = False;	
	
	declare Integer ForQuad_Video_LastPlayedTrigger for _Quad;
	declare Integer ForQuad_Video_Duration 			for _Quad;
	ForQuad_Video_Duration 			= _Duration;
	ForQuad_Video_LastPlayedTrigger = Now;
}



Void PlayVideoQuad(CMlQuad _Quad, Integer _Duration, Text _VideoUrl) 
{
	_Quad.ImageUrl = _VideoUrl;
	PlayVideoQuad(_Quad, _Duration);
}

{{{Volumes::GetPlayVoiceSoundML()}}}


main() 
{	
	{{{Prompter2::InjectInInit()}}}
	{{{UIBindingPadButtons::InjectInInit(C_LAYERNAME_UI)}}}
	
	declare Frame_Hud 						<=> (Page			.GetFirstChild("Frame_Hud") 					as CMlFrame);

	declare Quad_EngineOff 					<=> (Page			.GetFirstChild("Quad_EngineOff")				as CMlQuad);
	declare Quad_EngineOn 					<=> (Page			.GetFirstChild("Quad_EngineOn")					as CMlQuad);
	declare Quad_ButtonBoost				<=> (Page			.GetFirstChild("Quad_ButtonBoost")					as CMlQuad);
	
	declare Frame_Chrono 					<=> (Page			.GetFirstChild("Frame_Chrono") 					as CMlFrame);
	declare Label_Chrono 					<=> (Page			.GetFirstChild("Label_Chrono") 					as CMlLabel);
	
	declare Frame_LapsToGo 					<=> (Page			.GetFirstChild("Frame_LapsToGo") 				as CMlFrame);
	declare Frame_LapsToGoAnim 				<=> (Page			.GetFirstChild("Frame_LapsToGoAnim") 			as CMlFrame);
	declare Frame_LapsToGoContent 			<=> (Page			.GetFirstChild("Frame_LapsToGoContent") 		as CMlFrame);
	declare Label_LapCurrent 				<=> (Page			.GetFirstChild("Label_LapCurrent") 				as CMlLabel);
	declare Label_LapMax 					<=> (Page			.GetFirstChild("Label_LapMax") 					as CMlLabel);
	declare Label_LapMessage 				<=> (Page			.GetFirstChild("Label_LapMessage") 				as CMlLabel);
	
	
	// declare Label_CheckpointTime 		<=> (Page			.GetFirstChild("Label_CheckpointTime") 			as CMlLabel);
	declare Label_CheckpointDiff 			<=> (Page			.GetFirstChild("Label_CheckpointDiff") 			as CMlLabel);
	declare Label_CheckpointLap 			<=> (Page			.GetFirstChild("Label_CheckpointLap") 			as CMlLabel);
	
	declare Frame_DriftInfo 				<=> (Page			.GetFirstChild("Frame_DriftInfo") 				as CMlFrame);
	declare Label_DriftValue 				<=> (Frame_DriftInfo.GetFirstChild("Label_Value") 					as CMlLabel);
	declare Label_DriftTitle 				<=> (Frame_DriftInfo.GetFirstChild("Label_Title") 					as CMlLabel);
	
	declare Frame_JumpInfo 					<=> (Page			.GetFirstChild("Frame_JumpInfo") 				as CMlFrame);
	declare Label_JumpValue 				<=> (Frame_JumpInfo	.GetFirstChild("Label_Value") 					as CMlLabel);
	declare Label_JumpTitle 				<=> (Frame_JumpInfo	.GetFirstChild("Label_Title") 					as CMlLabel);	
	
	declare Frame_HeightInfo				<=> (Page			.GetFirstChild("Frame_HeightInfo") 				as CMlFrame);
	declare Label_HeightValue 				<=> (Frame_HeightInfo	.GetFirstChild("Label_Value") 				as CMlLabel);
	declare Label_HeightTitle 				<=> (Frame_HeightInfo	.GetFirstChild("Label_Title") 				as CMlLabel);
		
	declare Label_ModeName 					<=> (Page			.GetFirstChild("Label_ModeName") 				as CMlLabel);
	declare Label_SeriesName				<=> (Page			.GetFirstChild("Label_SeriesName") 				as CMlLabel);
		
	declare Frame_MapName 					<=> (Page			.GetFirstChild("Frame_MapName") 				as CMlFrame);
	declare Frame_MapNameAnim 				<=> (Frame_MapName	.GetFirstChild("Frame_MapNameAnim") 			as CMlFrame);
	declare Frame_MapNameContent 			<=> (Frame_MapName	.GetFirstChild("Frame_MapNameContent") 			as CMlFrame);
	declare Label_MapName 					<=> (Frame_MapName	.GetFirstChild("Label_MapName") 				as CMlLabel);
	declare Frame_CampaignMapContent		<=> (Frame_MapName	.GetFirstChild("Frame_CampaignMapContent") 		as CMlFrame);
	declare Frame_NormalMode				<=> (Frame_MapName	.GetFirstChild("Frame_NormalMode") 		as CMlFrame);
	declare Frame_ChampionshipMode			<=> (Frame_MapName	.GetFirstChild("Frame_ChampionshipMode") 		as CMlFrame);
	declare Quad_MusicBg 						<=> (Frame_MapName	.GetFirstChild("Quad_MusicBg") 					as CMlQuad);
	declare Frame_MapNameBg					<=> (Frame_MapName  .GetFirstChild("Frame_MapNameBg")				as CMlFrame);
	declare Frame_MusicBg					<=> (Frame_MapName  .GetFirstChild("Frame_MusicBg")					as CMlFrame);

	declare Quad_ThirdChampionship 			<=> (Frame_MapNameAnim			.GetFirstChild("Quad_Bg3") 					as CMlQuad);
	declare Frame_RandomMapContent			<=> (Frame_MapName	.GetFirstChild("Frame_RandomMapContent") 		as CMlFrame);
	declare Quad_Lap 						<=> (Frame_MapName	.GetFirstChild("Quad_Lap") 						as CMlQuad);
	declare Frame_Medal 					<=> (Frame_MapName	.GetFirstChild("Frame_Medal") 					as CMlFrame);
	// declare Label_NumberSign 				<=> (Frame_MapName	.GetFirstChild("Label_NumberSign") 				as CMlLabel);
	declare Quad_Medal 						<=> (Frame_Medal	.GetFirstChild("Quad_Medal") 					as CMlQuad);
	

	declare Quad_DoubleDriverLogo 			<=> (Page			.GetFirstChild("Quad_DoubleDriverLogo")			as CMlQuad);
	
	declare Frame_Challenge 				<=> (Page			.GetFirstChild("Frame_Challenge") 				as CMlFrame);
	declare Frame_ChallengeAnim 			<=> (Frame_Challenge.GetFirstChild("Frame_ChallengeAnim")			as CMlFrame);
	declare Frame_ChallengeContent 			<=> (Frame_Challenge.GetFirstChild("Frame_ChallengeContent")		as CMlFrame);
	
	declare Frame_Opponent 					<=> (Page			.GetFirstChild("Frame_Opponent") 				as CMlFrame);
	declare Frame_Music 					<=> (Page			.GetFirstChild("Frame_Music") 				as CMlFrame);
	declare Quad_OpponentAvatar 			<=> (Frame_Opponent	.GetFirstChild("Quad_Avatar") 					as CMlQuad);
	declare Label_OpponentName 				<=> (Frame_Opponent	.GetFirstChild("Label_Name") 					as CMlLabel);
	declare Label_OpponentTime 				<=> (Frame_Opponent	.GetFirstChild("Label_Time") 					as CMlLabel);
	declare Label_OpponentTimeDiff 			<=> (Frame_Opponent	.GetFirstChild("Label_TimeDiff") 				as CMlLabel);
	
	declare Frame_Player 					<=> (Page			.GetFirstChild("Frame_Player") 					as CMlFrame);
	declare Label_PlayerName 				<=> (Frame_Player	.GetFirstChild("Label_Name") 					as CMlLabel);
	declare Label_PlayerTime 				<=> (Frame_Player	.GetFirstChild("Label_Time") 					as CMlLabel);
	declare Label_PlayerTimeDiff			<=> (Frame_Player	.GetFirstChild("Label_TimeDiff") 				as CMlLabel);
	
	declare Frame_Speed 					<=> (Page			.GetFirstChild("Frame_Speed") 					as CMlFrame);
	declare Frame_SpeedGauge 				<=> (Page			.GetFirstChild("Frame_SpeedGauge") 				as CMlFrame);
	declare Label_Speed 					<=> (Frame_Speed	.GetFirstChild("Label_Speed") 					as CMlLabel);
	declare Quad_SpeedEffect 				<=> (Frame_Speed	.GetFirstChild("Quad_SpeedEffect") 				as CMlQuad);
	declare Quad_Turbo 						<=> (Frame_Speed	.GetFirstChild("Quad_Turbo") 					as CMlQuad);
	
	declare Quad_GaugeLeft1 				<=> (Frame_Speed	.GetFirstChild("Quad_GaugeLeft1") 				as CMlQuad);
	declare Quad_GaugeRight1				<=> (Frame_Speed	.GetFirstChild("Quad_GaugeRight1") 				as CMlQuad);
	declare Quad_GaugeLeft2 				<=> (Frame_Speed	.GetFirstChild("Quad_GaugeLeft2") 				as CMlQuad);
	declare Quad_GaugeRight2				<=> (Frame_Speed	.GetFirstChild("Quad_GaugeRight2") 				as CMlQuad);
	declare Quad_GaugeLeft3 				<=> (Frame_Speed	.GetFirstChild("Quad_GaugeLeft3") 				as CMlQuad);
	declare Quad_GaugeRight3				<=> (Frame_Speed	.GetFirstChild("Quad_GaugeRight3") 				as CMlQuad);
	
	declare Quad_GaugePersistentLeft1 		<=> (Frame_Speed	.GetFirstChild("Quad_GaugePersistentLeft1") 	as CMlQuad);
	declare Quad_GaugePersistentRight1 		<=> (Frame_Speed	.GetFirstChild("Quad_GaugePersistentRight1") 	as CMlQuad);
	declare Quad_GaugePersistentLeft2 		<=> (Frame_Speed	.GetFirstChild("Quad_GaugePersistentLeft2") 	as CMlQuad);
	declare Quad_GaugePersistentRight2 		<=> (Frame_Speed	.GetFirstChild("Quad_GaugePersistentRight2") 	as CMlQuad);
	declare Quad_GaugePersistentLeft3 		<=> (Frame_Speed	.GetFirstChild("Quad_GaugePersistentLeft3") 	as CMlQuad);
	declare Quad_GaugePersistentRight3 		<=> (Frame_Speed	.GetFirstChild("Quad_GaugePersistentRight3") 	as CMlQuad);
	
	declare Quad_Gauge 						 = [Quad_GaugeLeft1,  			Quad_GaugeRight1, 			Quad_GaugeLeft2, Quad_GaugeRight2, Quad_GaugeLeft3, Quad_GaugeRight3];
	declare Quad_GaugeRight					 = [Quad_GaugeRight1, 			Quad_GaugeRight2, 			Quad_GaugeRight3];
	declare Quad_GaugeLeft 					 = [Quad_GaugeLeft1,  			Quad_GaugeLeft2,  			Quad_GaugeLeft3];
	
	declare Quad_GaugePersistent 			 = [Quad_GaugePersistentLeft1, 	Quad_GaugePersistentRight1, Quad_GaugePersistentLeft2, Quad_GaugePersistentRight2, Quad_GaugePersistentLeft3, Quad_GaugePersistentRight3];
	declare Quad_GaugePersistentLeft		 = [Quad_GaugePersistentLeft1,	Quad_GaugePersistentLeft2, 	Quad_GaugePersistentLeft3];
	declare Quad_GaugePersistentRight 		 = [Quad_GaugePersistentRight1, Quad_GaugePersistentRight2, Quad_GaugePersistentRight3];
	
	
	declare	netread 	Integer 	Net_BestMedal 					for UI;
	declare	netread 	Text 		Net_PlayerNickname 				for UI;
	declare	netread 	Integer 	Net_OpponentType 				for UI;
	declare	netread 	Integer 	Net_BestTime 					for UI;
	declare	netread 	Integer[] 	Net_OpponentCheckpointsTime 	for UI;
	declare	netread 	Boolean 	Net_ChallengeFrameVisibility 	for UI;
	declare	netread 	Boolean 	Net_MapNameFrameVisibility 		for UI;
	declare netread 	Integer 	Net_GamePhase 					for UI;
	declare netread 	Boolean 	Net_SymbioseActive 				for UI;
	declare netread		Boolean 	Net_IsTrackRandom 				for UI;
	declare netread 	Text		Net_ModeName					for UI;
	declare netread 	Boolean		Net_CheatUniqueCamera			for UI;
	declare netread		Integer		Net_NbLaps						for UI;
	declare netwrite 	Integer		Net_CurrentTrackJoker			for UI;
	declare netread Integer 		Net_ChampionshipTrackIndex		for UI;
	
	//ONLY IN ARCADE MODE
	declare netwrite 	Integer 	Net_ReplayFocusOutUpdate 		for UI;
	declare netread 	Integer 	Net_IdleFocusInUpdate 			for UI;
	declare 			Integer		Pre_IdleFocusInUpdate			for UI;
	declare				Integer		Pre_ReplayFocusOutUpdate		for UI;
	
	declare netwrite 	Integer 	Net_MusicNextTempoDelay 		for UI;
	declare netwrite 	Integer 	Net_MusicBeatDuration	 		for UI;
	declare netwrite 	Boolean 	Net_IsPauseMenuEnabled 			for UI;
	declare netwrite 	Boolean 	Net_IsPadMissingMenuEnable		for UI;
	declare netwrite 	Boolean 	Net_IsPluginEnabled 			for UI;
	declare netwrite 	Real 		Net_CoopSymbiosysRatio			for UI;
	declare netread		Integer		Net_OpponentUpdate				for UI;
	declare				Integer		Pre_OpponentUpdate				for UI;
	declare Text					Net_TrackFinalName				for UI;
	declare 			Integer 	Net_PlayerMusicState			for UI;
	declare				Boolean		Net_HudIsVisible				for UI;
	
	
	declare netwrite Integer Net_LibLastDeviceUsed_LastDeviceUsed for UI;
	
	declare M_PrevBestMedal			 	= -1;
	declare M_PrevJoker					= 0;
	declare M_PrevOpponentType			= -1; 	
	declare M_PrevBestTime				= -1; 	
	declare M_PrevSpeedValue 			= -1; 	
	declare M_PrevRaceState 		 	= CTmMlPlayer::ERaceState::Running;
	declare M_PrevUIStatus 				= CUIConfig::EUIStatus::None;
	
	
	declare M_PluginInterface_UIPlugin = GetPluginInterface("UIPlugin");
	
	declare Integer M_CpCountVoice;
	declare Integer M_LatestCarHitSound;
	declare Integer M_CpCommentariesToPlayEachXXCp = ML::Rand({{{C_COMMENTARIES_TOPLAY_EACH_XX_CP_MIN}}}, {{{C_COMMENTARIES_TOPLAY_EACH_XX_CP_MAX}}});
	declare Integer M_RemainingLap;
	declare Integer M_PrevRemainingLap = M_RemainingLap;
	declare Integer M_OpponentTime;
	declare Integer M_TimeDiff; 
	declare Integer M_LastCpTime; 
	declare Integer M_TriggerWoosh;
	declare Integer M_TriggerShowLapsToGo;
	declare Integer M_TriggerShowAnim;
	declare Integer M_TriggerHideAnim;
	declare Integer M_TriggerAnim;
	declare Integer M_TriggerChallengeAnim;
	declare Integer M_TriggerCheckpoint;
	declare Integer M_TriggerMessage;
	declare Integer M_TriggerFreewheel;
	declare Integer M_CurCheckpointIndex = -1;
	declare Integer M_PrevTriggerMessage;
	declare Integer M_PrevTriggerChallengeAnim;
	declare Integer M_PrevTriggerWoosh;
	declare Integer M_PrevLastCpTime = -1;
	declare Real 	M_ChronoBlinkOpacity = 1.;
	declare Real 	M_PrevGaugeRatioAnim;
	declare Real 	M_PrevGaugeRatioPersistent; 	
	declare Real 	M_LatestGaugeRatioStep = -1.; 
	declare Real 	M_GaugeRatioPersistent;
	declare Real 	M_GaugeRatio = 0.;
	declare Integer M_LatestUpGaugeRatio;	
	declare Vec3 	M_GaugeColor;
	declare Boolean	M_SwitchUpdateAlternate;
	declare Boolean M_ResetGaugeNeeded;
	declare Boolean M_PrevIsFreeWheel;
	declare Boolean M_PrevHudIsVisible;
	declare Boolean M_PrevPageIsVisible;
	declare Text 	M_PrevMapName;
	declare Integer	M_PrevTrackChampionshipIndex = -1;
	declare Text 	M_MessageSound;
	declare CAudioSource M_SFX_Rise;
	declare Text PreMusicFinalName;
	declare Boolean[] M_OpponentCheckpointValidated;
	foreach (Checkpoint in Net_OpponentCheckpointsTime) M_OpponentCheckpointValidated.add(False);
	if(Net_OpponentCheckpointsTime.count > 0) M_PrevLastCpTime = Net_OpponentCheckpointsTime[Net_OpponentCheckpointsTime.count-1];
	
	declare Vec3 	M_AnimStartPosOpponent 	= C_POS_SECOND;
	declare Vec3 	M_AnimStartPosPlayer 	= C_POS_FIRST;
	declare Vec3 	M_AnimEndPosOpponent 	= C_POS_FIRST;
	declare Vec3 	M_AnimEndPosPlayer 		= C_POS_SECOND;
	
	declare CAudioSource M_SoundWhoosh = Audio.CreateSound("{{{SOUNDPATH ^ SOUND_WHOOSHTEST}}}", 0., False, False, True);
	declare M_RandomDir = -1.;
	
	PreloadSounds();
	StopVideoQuad(Quad_SpeedEffect);
	foreach(Quad in Quad_Gauge) 			Quad.Blend = CMlQuad::EBlendMode::Add;
	foreach(Quad in Quad_GaugePersistent) 	Quad.Blend = CMlQuad::EBlendMode::Add;
	Quad_Turbo				.Blend = CMlQuad ::EBlendMode::Add;
	Quad_SpeedEffect		.Blend = CMlQuad ::EBlendMode::Add;
	Quad_EngineOff			.Blend = CMlQuad ::EBlendMode::Add;
	Quad_EngineOn			.Blend = CMlQuad ::EBlendMode::Add;
	Quad_DoubleDriverLogo	.Blend = CMlQuad ::EBlendMode::Add;
	Label_Speed				.Blend = CMlLabel::EBlendMode::Add;
	Label_Chrono			.Blend = CMlLabel::EBlendMode::Add;
	Label_DriftValue		.Blend = CMlLabel::EBlendMode::Add;
	Label_DriftTitle		.Blend = CMlLabel::EBlendMode::Add;
	Label_JumpValue			.Blend = CMlLabel::EBlendMode::Add;
	Label_JumpTitle			.Blend = CMlLabel::EBlendMode::Add;
	Label_HeightValue		.Blend = CMlLabel::EBlendMode::Add;
	Label_HeightTitle		.Blend = CMlLabel::EBlendMode::Add;
	// Label_CheckpointTime	.Blend = CMlLabel::EBlendMode::Add;
	Label_CheckpointDiff	.Blend = CMlLabel::EBlendMode::Add;
	Label_CheckpointLap		.Blend = CMlLabel::EBlendMode::Add;
	
	Label_ModeName			.Value 		= "$ff0" ^ TL::ToUpperCase("{{{G_ModeName}}}") ^ " $fffMODE";
	Label_DriftTitle		.Value		= _("DRIFT DISTANCE (m)");
	Label_JumpTitle			.Value		= _("JUMP DISTANCE (m)");
	Label_HeightTitle		.Value		= _("HEIGHT (m)");
	Label_JumpTitle			.TextColor	= {{{ColorYellow}}};
	Label_HeightTitle		.TextColor	= {{{ColorYellow}}};
	
	Frame_Hud				.Hide();
	Label_ModeName			.Hide();
	Label_OpponentTimeDiff	.Hide();
	Label_PlayerTime		.Hide();
	
	if(Net_ModeName == "Rounds Splitscreen")
	{
		Frame_DriftInfo	.Visible = False;
		Frame_JumpInfo	.Visible = False;
		Frame_HeightInfo.Visible = False;
	}
	
	if(Net_NbLaps > 9)
	{
		Label_LapCurrent.TextFont = "{{{G_FontTitle}}}";
		Label_LapMax	.TextFont = "{{{G_FontTitle}}}";
	}
	else
	{
		Label_LapCurrent.TextFont = "{{{G_FontNumberBig}}}";
		Label_LapMax	.TextFont = "{{{G_FontNumberBig}}}";
	}
	
	G_FadeOpacity = 1.;
	
	M_SFX_Rise = Audio.CreateSound("{{{SOUNDPATH^SOUND_DRIFTRISE}}}", {{{Volumes::GetVolumedB("SFXRise")}}}, False, True, False);
	M_SFX_Rise.Stop();	
	
	
	// VOICE : CHECKPOINT 
	declare CAudioSource[] M_SoundsCheckpointYes;
	declare CAudioSource[] M_SoundsCheckpointNo;
	
	for(I, 1, {{{C_COMMENTARIES_MAXCOUNT_CP_YES}}})
		M_SoundsCheckpointYes	.add(Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_VOICE_CHECKPOINT_YES}}}"^I^".wav", {{{Volumes::GetVolumedB("VoiceCommentaries")}}}, False, False, False));
	for(I, 1, {{{C_COMMENTARIES_MAXCOUNT_CP_NO}}})
		M_SoundsCheckpointNo	.add(Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_VOICE_CHECKPOINT_NO}}}" ^I^".wav", {{{Volumes::GetVolumedB("VoiceCommentaries")}}}, False, False, False));
		
	M_SoundsCheckpointYes.add(Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_VOICE_CHECKPOINT_1}}}", {{{Volumes::GetVolumedB("VoiceCommentaries")}}}, False, False, False));
	M_SoundsCheckpointYes.add(Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_VOICE_CHECKPOINT_2}}}", {{{Volumes::GetVolumedB("VoiceCommentaries")}}}, False, False, False));
	M_SoundsCheckpointNo.add(Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_VOICE_CHECKPOINT_3}}}", {{{Volumes::GetVolumedB("VoiceCommentaries")}}}, False, False, False));
	M_SoundsCheckpointNo.add(Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_VOICE_CHECKPOINT_4}}}", {{{Volumes::GetVolumedB("VoiceCommentaries")}}}, False, False, False));
		
		
		
	// VOICE : CAR HIT
	declare CAudioSource[] M_SoundsCarHit;
	
	for(I, 1, {{{C_COMMENTARIES_MAXCOUNT_CARHIT}}})
		M_SoundsCarHit	.add(Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_VOICE_CARHIT}}}" ^I^".wav", {{{Volumes::GetVolumedB("VoiceCommentaries")}}}, False, False, False));
		
		
		
	declare M_SoundSpeedEffect 				= Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_SPEEDEFFECT}}}", 	{{{Volumes::GetVolumedB("SpeedEffect")}}}, 		False, False, False);
	declare M_SoundIsFreewheel				= Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_ISFREEWHEEL}}}", 	{{{Volumes::GetVolumedB("StateFreewheel")}}}, 	False, True, False);
	declare M_SoundIsFlying 				= Audio.CreateSound("{{{SOUNDPATH}}}{{{SOUND_ISFLYING}}}", 		0., False, True, False);
	declare M_SoundIsFlyingDesiredVolume 	= 0.;
	M_SoundSpeedEffect	.PanRadiusLfe 		= {{{Volumes::GetPanRadiusLfe("SpeedEffectStart")}}};
	M_SoundIsFlying		.PanRadiusLfe 		= {{{Volumes::GetPanRadiusLfe("StateFlying")}}};
	M_SoundIsFlying		.Stop();
	// M_SoundIsFlying.FadeDuration  = 2.;

	// Frame_ClipLeft	.ClipWindowActive = False; 
	// Frame_ClipRight	.ClipWindowActive = False;
	
	declare Video_BgAnim = Video.CreateVideo("{{{VIDEOPATH^VIDEO_BGANIM_MESSAGE}}}", False, False);
	
	declare netread Net_LibUI_IsEditor for UI = False;
	
	declare PrevLapRaceTime = -1;

	while(True)  
	{
		yield;
		// log(PageIsVisible^" "^GUIPlayer);
		{{{UIBindingPadButtons::InjectInLoop()}}}

		if(!PageIsVisible || GUIPlayer == Null) continue;
		
		if(Net_ModeName != "Rounds Splitscreen") {
			{{{Prompter2::InjectInLoop()}}}
		}

		if (Net_LibUI_IsEditor) {
			Frame_NormalMode.Visible 		= False;
			Frame_ChampionshipMode.Visible	= False;
			Frame_MapNameBg.Visible			= False;
			Frame_MusicBg.Visible			= !Map.TMObjective_IsLapRace;
		} else if (Net_ModeName == "Championship") {
			Frame_NormalMode.Visible 		= False;
			Frame_ChampionshipMode.Visible	= True;
			Frame_MapNameBg.Visible			= True;
			Frame_MusicBg.Visible			= False;
			// Quad_ThirdChampionship.Visible	= False;
		} else {
			Frame_NormalMode.Visible 		= True;
			Frame_ChampionshipMode.Visible	= False;
			Frame_MapNameBg.Visible			= True;
			Frame_MusicBg.Visible			= False;
			// Quad_ThirdChampionship.Visible	= True;
		}
		
		if(M_PrevPageIsVisible != PageIsVisible)
		{
			M_PrevPageIsVisible = PageIsVisible;
			if(M_PrevPageIsVisible) 
				M_TriggerShowAnim = Now;
		}
		
		////////////////////////////////////////
		// RACE STATE                           
		if(M_PrevRaceState != GUIPlayer.RaceState) 
		{
			M_PrevRaceState = GUIPlayer.RaceState;


			
			M_TimeDiff = -1;
			if(Net_OpponentCheckpointsTime.count > 0)
			{
				if(Net_BestTime > 0)
				{
					M_TimeDiff 				= Net_BestTime - M_OpponentTime;
					M_TriggerChallengeAnim 	= Now;
				}
			}
				
			if (M_PrevRaceState == CTmMlPlayer::ERaceState::Finished) 
			{
				if(GUIPlayer.CurRace != Null && GUIPlayer.CurRace.Time >= 0)
					Label_Chrono.Value 	= GetTimeToText(GUIPlayer.CurRace.Time);
				else
					Label_Chrono.Value 	= "--:--:--";
				
				// Frame_ClipLeft	.ClipWindowActive = False; 
				// Frame_ClipRight	.ClipWindowActive = False; 
				
			} 
			else 
			if (M_PrevRaceState == CTmMlPlayer::ERaceState::BeforeStart) 
			{
				if(Net_BestTime <= 0)
				{
					Label_PlayerTimeDiff	.Value 		= "";
					Label_OpponentTimeDiff	.Value 		= "";
					M_AnimEndPosOpponent = C_POS_FIRST;
					M_AnimEndPosPlayer   = C_POS_SECOND;
				}
				M_CpCountVoice 		 = M_CpCommentariesToPlayEachXXCp;
				
				M_CurCheckpointIndex 	= -1;
				M_ResetGaugeNeeded 		= True;
				for(I, 0, M_OpponentCheckpointValidated.count-1) M_OpponentCheckpointValidated[I] = False;
				Label_Chrono	.Value 	= "00:00.00";
				// Frame_ClipLeft	.ClipWindowActive = True; 
				// Frame_ClipRight	.ClipWindowActive = True; 
				M_RemainingLap = -1;
				M_PrevRemainingLap = -1;
				M_TriggerShowLapsToGo = 0;
			} 
		}
		
		
		declare IsRunning 		= M_PrevRaceState == CTmMlPlayer::ERaceState::Running;
		declare IsBeforeStart 	= M_PrevRaceState == CTmMlPlayer::ERaceState::BeforeStart;
		declare IsThereOpponent = Net_OpponentType != TMC_MEDAL_NONE && Net_OpponentType != -1;
		
		//////////////////////////////
		// MAP NAME BUSINESS          
		if(M_PrevMapName != Map.MapName) 
		{
			M_PrevMapName = Map.MapName;
			
			// GET NUMBER TO SHOW FROM MAP NAME				
			// declare Text 	MapName 	= TL::Trim(TL::StripFormatting(Map.MapName));
			// declare Text 	MapName 	= TL::Trim(TL::StripFormatting(TL::Split("_", Map.MapName)[0]));
			declare Text 	MapName 	= TL::Trim(TL::StripFormatting(Map.MapName));
			declare Integer MapNumber 	= TL::ToInteger	(MapName);

			MapName = ""^MapNumber;
			if(MapNumber < 10)
				MapName = "0"^MapNumber;
				
			declare Vec3		MapNameColor 	= GetSeriesColorFromMapNumber(MapNumber);
			declare Real 		MapNameScale 	= 1.;
			
			if(Map.MapInfo.MapType == "TrackMania\\RaceCE") {
				MapNameColor = <1.0, 1.0, 1.0>;
			}
			
			if(MapName == "200" || MapNumber >= 200) MapNameScale = 0.82;
			
			Label_MapName.Scale 		= MapNameScale;
			Label_MapName.Value 		= MapName;
			Label_MapName.TextColor 	= MapNameColor;
			
			// MULTI LAP ICON
			Quad_Lap		.Visible = Map.TMObjective_IsLapRace;
			
			// SERIES + ENVIRONMENT NAME
			declare SeriesName 	= GetSeriesNameFromMapNumber(MapNumber);
			declare EnvName		= TL::ToUpperCase(Map.CollectionName);
			Label_SeriesName.Value = EnvName ^ " " ^ SeriesName ^ " SERIES";
		}
		
		// log(Now^" "^Net_ChampionshipTrackIndex);
		if(M_PrevTrackChampionshipIndex != Net_ChampionshipTrackIndex) 
		{
			Prompter_SetBanner("ChampionshipTrackName", TL::ToUpperCase("#"^Net_ChampionshipTrackIndex+1^" "^Map.AuthorNickName^" - "^Map.MapName), 4000, 20, <0.879, 0.879, 0.879>);
			Prompter_SetBannerIsActive("ChampionshipTrackName", True, True);
			
			M_PrevTrackChampionshipIndex = Net_ChampionshipTrackIndex;
		}
		
		if(Net_IsTrackRandom) {
			
			Frame_CampaignMapContent.Visible = False;
			Label_MapName.Value = "00";
			Frame_Medal.Visible = False;
			Frame_RandomMapContent.Visible = True;
		} else {
			
			Frame_RandomMapContent.Visible 	= False;
			// log(Map.MapInfo.MapType^" "^(Map.MapInfo.MapType == "Trackmania\\Race")^" "^(Map.MapInfo.MapType == "TrackMania\\Race"));
			
			if(Map.MapInfo.MapType == "Trackmania\\Race" || Map.MapInfo.MapType == "TrackMania\\Race") {
				if(M_PrevBestMedal != Net_BestMedal) {
					M_PrevBestMedal = Net_BestMedal;
					Quad_Medal.ImageUrl = GetMedalUrl(Net_BestMedal);
				}
				if(M_PrevJoker != Net_CurrentTrackJoker) {
					if(Net_CurrentTrackJoker != TMC_MEDAL_NONE) {
						Quad_Medal.ImageUrl = GetJokerUrl(Net_CurrentTrackJoker);
						M_PrevJoker = Net_CurrentTrackJoker;
					}
				}
			} else if(Map.MapInfo.MapType == "Trackmania\\RaceCE") {
				Frame_Medal.Visible = False;
				Quad_Medal.ImageUrl = "";	
			}
		}
		// StartPosLeft 	= PosVisible;
		// StartPosRight 	= PosVisible;
		// EndPosLeft		= <{{{-C_RACE_MAPNAME_SIZE_X}}},	0., 	1.>;
		// EndPosRight		= <{{{ C_RACE_MAPNAME_SIZE_X}}},	0., 	1.>;
		// CheckToPlayMoveTo("BackOut", Frame_MapNameAnim,  Trigger, StartPosLeft, EndPosLeft, C_ANIMSHOW_DURATION);	
		
		/////////////////////////////////////
		// FRAME HUD VISIBILITY CHANGE
		declare HudDesiredVisible = False;
		
		if(LocalUser.StereoDisplayMode == CUser::EStereoDisplayMode::None) {
			if(Net_ModeName != "Rounds Splitscreen") {
				HudDesiredVisible = !Net_IsPadMissingMenuEnable && !Net_IsPauseMenuEnabled && (IsRunning || IsBeforeStart && Net_GamePhase == C_GAMEPHASE_GAME) && !Net_CheatUniqueCamera;
			} else {
				HudDesiredVisible = !Net_IsPadMissingMenuEnable && (IsRunning || IsBeforeStart && Net_GamePhase == C_GAMEPHASE_GAME) && !Net_CheatUniqueCamera;
			}
		}
		Net_HudIsVisible = HudDesiredVisible;
		
		/*
		log(Now^" DESIRED VISIBLE: "^HudDesiredVisible);
		log(Now^" Pause menu enabled: "^Net_IsPauseMenuEnabled);
		log(Now^" Is running: "^IsRunning);
		log(Now^" Before start: "^IsBeforeStart);
		log(Now^" game phase: "^Net_GamePhase);
		*/
		
		if(Net_PlayerMusicState == 1) {
			Quad_MusicBg.BgColor = {{{Colors::GetColor("Yellow")}}};
		} else if(Net_PlayerMusicState == 0) {
			Quad_MusicBg.BgColor = {{{Colors::GetColor("White")}}};
		} else if(Net_PlayerMusicState == 2) {
			Quad_MusicBg.BgColor = {{{Colors::GetColor("Black")}}};
		}
		
		if(Net_ModeName != "Rounds Splitscreen" ) {
			declare	Text	Net_MusicFinalName	for UI;
			if(PreMusicFinalName != Net_MusicFinalName && GameTime > InputPlayer.RaceStartTime && Net_MusicFinalName != "") {
				Prompter_SetBanner("MusicName", Net_MusicFinalName, 4000, 20, <0.129, 0.129, 0.129>);
				Prompter_SetBannerIsActive("MusicName", True, True);
				PreMusicFinalName = Net_MusicFinalName;
				// Frame_Music.Visible = True;
			} else if(GameTime < InputPlayer.RaceStartTime) {
				Prompter_SetBanner("MusicName", "", 4000, 20, <0.129, 0.129, 0.129>);
				Prompter_SetBannerIsActive("MusicName", True, True);
				PreMusicFinalName = "";
				// Frame_Music.Visible = False;
			}
		}
		
		SetBindableKeysVisible("{{{MusicBoosterName}}}", True);
		Quad_ButtonBoost.Visible = False;
		
		/*
		if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Keyboard) {
			
		} else if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Pad) {
			SetBindableKeysVisible("{{{MusicBoosterName}}}", False);
			Quad_ButtonBoost.Visible = True;
			Quad_ButtonBoost.ImageUrl = GetImageForButton("{{{UIButtons::GetAlternateImage("View")}}}");
		}
		*/
		
		if(M_PrevHudIsVisible != HudDesiredVisible)
		{
			M_PrevHudIsVisible = HudDesiredVisible;
			
			if(Net_ModeName != "Rounds Splitscreen") {
				Frame_Music.Visible = True;
			} else {
				Frame_Music.Visible = False;
			}
			
			if(HudDesiredVisible)
			{
				M_TriggerShowAnim = Now;
				Audio.PlaySoundEvent("{{{SOUNDPATH^SOUND_SHOWLINE}}}", {{{Volumes::GetVolumedB("ShowLine") - 7.5}}}, 150);
				
				if(Net_ModeName == "Rounds Splitscreen") {
					// log(Now^"> Splitscreen");
					// Frame_Speed.Visible = False;
					// Frame_DriftInfo.Visible = False;
					// Frame_JumpInfo.Visible = False;
					Frame_Chrono.Visible = False;
					// Frame_LapsToGoContent.Visible = False;
					Frame_MapName.Visible = False;
				}
				
				Frame_Hud.Visible = True;
				Frame_MapName.Visible = Net_MapNameFrameVisibility;
			}
			else {
				M_TriggerHideAnim = Now;
				M_SoundIsFlying.Stop();
				M_SFX_Rise.Stop();
				M_SoundSpeedEffect.Stop();
				M_SoundIsFreewheel.Stop();
			}
		}

		// Frame_MapNameAnim	.RelativePosition = <0.,0.,1.>;
		
		if(Net_ModeName != "Rounds Splitscreen")
		//if(True)
		{	
			declare Trigger 			= M_TriggerShowAnim;
			
			declare StartOpacity 		= 0.;
			declare DiffOpacity			= 1.;
			
			declare PosVisible 			= <0., 					0., 	1.>;
			
			declare StartPosLeft		= <-C_ANIMSHOW_OFFSET,	0., 	1.>;
			declare StartPosRight		= < C_ANIMSHOW_OFFSET,	0., 	1.>;
			declare EndPosLeft 			= PosVisible;
			declare EndPosRight 		= PosVisible;
			
			if(HudDesiredVisible)
			{
				
				Frame_MapNameAnim	.RelativePosition = <0.,0.,1.>;
				Frame_LapsToGoAnim	.RelativePosition = <0.,0.,1.>;
				
				if(Now > Trigger + C_ANIMSHOW_DURATION)
				{
					Frame_LapsToGoContent	.RelativePosition.X = 0.;
					Frame_MapNameContent	.RelativePosition.X = 0.;				
				} 
				else 
				{
					CheckToPlayMoveTo("BackOut", Frame_MapNameContent, 	Trigger, StartPosLeft, EndPosLeft, C_ANIMSHOW_DURATION);	
					CheckToPlayMoveTo("BackOut", Frame_LapsToGoContent, Trigger, StartPosLeft, EndPosLeft, C_ANIMSHOW_DURATION);
					
				}

				if(IsThereOpponent && Net_ChallengeFrameVisibility)
				{
					Frame_ChallengeAnim	.RelativePosition = <0.,0.,1.>;
					CheckToPlayMoveTo("BackOut", Frame_ChallengeContent, 	Trigger, StartPosRight, EndPosRight, C_ANIMSHOW_DURATION);
					if(Now > Trigger + C_ANIMSHOW_DURATION)
						Frame_ChallengeContent.RelativePosition.X = 0.;		
				}
			}
			else
			{
				Trigger = M_TriggerHideAnim;
				if(Now <= Trigger + C_ANIMSHOW_DURATION)
				{
					
					StartOpacity 	= 1.;
					DiffOpacity		= -1.;
					StartPosLeft 	= PosVisible;
					StartPosRight 	= PosVisible;
					EndPosLeft		= <{{{-C_RACE_MAPNAME_SIZE_X-10.}}},	0., 	1.>;
					EndPosRight		= <{{{C_RACE_MAPNAME_SIZE_X+10}}},	0., 	1.>;
					CheckToPlayMoveTo("Linear", Frame_MapNameAnim,  Trigger, StartPosLeft, EndPosLeft, C_ANIMSHOW_DURATION);	
					CheckToPlayMoveTo("Linear", Frame_LapsToGoAnim, Trigger, StartPosLeft, EndPosLeft, C_ANIMSHOW_DURATION);	
					if(IsThereOpponent && Net_ChallengeFrameVisibility) 
						CheckToPlayMoveTo("Linear", Frame_ChallengeAnim, Trigger, StartPosRight, EndPosRight, C_ANIMSHOW_DURATION);
				} else
				{
					// log(Now^" "^Frame_Hud.Visible);
					Frame_Hud.Visible = False;
				}
			}
			// log(Now^HudDesiredVisible^" "^Frame_Hud.Visible);
			G_FadeOpacity = AL::Ease("Linear", Now - Trigger*1., StartOpacity, DiffOpacity, C_ANIMSHOW_DURATION*1.);
			
			declare OpacitySpeedAnim = 1.;
			if(GUIPlayer.DisplaySpeed <= 0)
			{
				OpacitySpeedAnim = 0.5 + 0.5 * ML::Sin(Now*{{{C_SPEED_ANIM_BLINKSPEED}}});
			}
			Label_Chrono			.Opacity = {{{C_WHITE_OPACITY}}} * G_FadeOpacity * M_ChronoBlinkOpacity;
			Label_Speed				.Opacity = {{{C_WHITE_OPACITY}}} * OpacitySpeedAnim * G_FadeOpacity;
			Quad_DoubleDriverLogo	.Opacity = 1. * G_FadeOpacity;
			Quad_DoubleDriverLogo	.Visible = False;
			{
				Label_LapMessage.Opacity = 0.5 + 0.5 * ML::Sin(Now*{{{C_SPEED_ANIM_BLINKSPEED}}});
			}
		}
		
		// SHOW/HIDE HUD ANIM
		// if(!Frame_Hud.Visible && Net_ModeName != "Rounds Splitscreen") 
		if(!Frame_Hud.Visible) 
			continue;
		
		// UPDATE IF OPPONENT CHANGE
		declare OpponentCpLast = Net_OpponentCheckpointsTime.count-1;
		declare IsThereOpponentCpTime = OpponentCpLast >= 0;
		if(IsThereOpponentCpTime && M_PrevLastCpTime != Net_OpponentCheckpointsTime[OpponentCpLast])
		{
			M_PrevLastCpTime = Net_OpponentCheckpointsTime[Net_OpponentCheckpointsTime.count-1];
			M_OpponentCheckpointValidated.clear();
			foreach(Checkpoint in Net_OpponentCheckpointsTime) 
				M_OpponentCheckpointValidated.add(False);
		}
		
		
		/////////////////////
		// CONTINUE UPDATE   
		
		declare SpeedValue 		= GUIPlayer.DisplaySpeed;
		declare DriftDuration 	= GUIPlayer.SkiddingDuration;
		declare DriftDistance 	= ML::FloorInteger(GUIPlayer.SkiddingDistance);
		declare JumpDuration 	= GUIPlayer.FlyingDuration;
		declare JumpDistance 	= ML::FloorInteger(GUIPlayer.FlyingDistance);
		declare CarHeight 		= ML::FloorInteger(GUIPlayer.Position.Y);
		
		if(IsRunning) 
			Net_CoopSymbiosysRatio = GUIPlayer.CoopSymbiosysPercentTotal * 0.01;
		
		
		
		/////////////////////
		// VIDEO CHECK
		
		foreach(Quad in [Quad_SpeedEffect])
		{
			declare Integer ForQuad_Video_LastPlayedTrigger 	for Quad;
			declare Integer ForQuad_Video_Duration 				for Quad;
			if(Now > ForQuad_Video_LastPlayedTrigger + ForQuad_Video_Duration)
			{
				StopVideoQuad(Quad);
			}
		}
		
		
		/////////////////////
		// LAP EVENT
		
		if(IsRunning && Net_NbLaps > 1 && Net_ModeName != "Rounds Splitscreen" && Map.TMObjective_IsLapRace) 
		{
			M_RemainingLap = Net_NbLaps - GUIPlayer.CurrentNbLaps;
			if(M_PrevRemainingLap != M_RemainingLap)
			{
				M_PrevRemainingLap = M_RemainingLap;
				if(M_RemainingLap == 1) {
					M_MessageSound 	= "voice-lap-final.wav";
				} else if(M_RemainingLap <= 5) {
					M_MessageSound 	= "voice-lap-"^M_RemainingLap^".wav";
				}
				M_TriggerShowLapsToGo = Now;
				
				if(M_RemainingLap == Net_NbLaps)
					M_TriggerMessage = Now + 1500;
				else
					M_TriggerMessage = Now + Net_MusicNextTempoDelay;					
			}
		}
		
		
		
		/////////////////////
		// RACE EVENTS LOOP
		
		foreach(Event in RaceEvents)
		{
			if(Event.Player.Id != GUIPlayer.Id)
			{
				continue;
			}
			
			// events for local player:
			switch(Event.Type)
			{
				case CTmRaceClientEvent::EType::WayPoint : 
				{
					// declare PlayDefaultVoice = True;
					M_CurCheckpointIndex += 1;
					M_TimeDiff = -1;
					
					declare EndRace 				= Event.IsEndRace;
					declare EndLap 					= Event.IsEndLap;
					M_LastCpTime 					= GUIPlayer.CurCheckpointRaceTime;
					declare CurCheckpointLapTime 	= GUIPlayer.CurCheckpointLapTime;
					if(Net_OpponentCheckpointsTime.existskey(M_CurCheckpointIndex))
					{
						declare CurCheckpointTimeOpponent 	= Net_OpponentCheckpointsTime[M_CurCheckpointIndex];
						M_TimeDiff 							= M_LastCpTime - CurCheckpointTimeOpponent;
						M_TriggerChallengeAnim 				= Now;
					}
					else
					{
						M_TimeDiff = 0;
					}
					if(!EndRace)
					{
						declare LapTime = GUIPlayer.CurCheckpointLapTime;
						if (GUIPlayer.CurCheckpointLapTime < 0) {
							if (GUIPlayer.CurrentNbLaps <= 1) {
								LapTime = GUIPlayer.CurCheckpointRaceTime;
							} else {
								LapTime = GUIPlayer.CurCheckpointRaceTime - PrevLapRaceTime;
							}
							PrevLapRaceTime = GUIPlayer.CurCheckpointRaceTime;
						} else {
							LapTime = GUIPlayer.CurCheckpointLapTime;
						}
						
						// Label_CheckpointTime	.Value 				= GetTimeToText(M_LastCpTime);
						Label_CheckpointDiff	.Value 				= GetTimeDiffToText	(M_TimeDiff, GUIPlayer);
						Label_CheckpointDiff	.TextColor 			= GetTimeDiffColor	(M_TimeDiff, GUIPlayer);
						Label_CheckpointDiff	.RelativePosition.X = GetTimeDiffPosX	(M_TimeDiff, GUIPlayer);
						Label_CheckpointLap		.Value 				= GetTimeToText		(LapTime);
						if(LapTime < 10) {
							Label_CheckpointLap.Value = GetTimeToText(M_LastCpTime);
						}
						
						if(GUIPlayer.CurrentNbLaps > 0 && Map.TMObjective_IsLapRace) 
							Audio.PlaySoundEvent("{{{SOUNDPATH ^ SOUND_CHECKPOINT_LAP}}}", 	{{{Volumes::GetVolumedB("CheckpointLap")}}}, 	{{{C_DELAY_LAP}}});
						
						M_TriggerCheckpoint = Now;
						M_TriggerWoosh = Now;
					}
					
					if(Net_ModeName != "Rounds Splitscreen") {
						declare IsAhead = M_TimeDiff <= 0;
						if(M_TimeDiff != 0 && !EndRace)
						{
							if(IsAhead)
								PlayVoiceSound("{{{SOUNDPATH ^ SOUND_CHECKPOINT_YES}}}", 	{{{Volumes::GetVolumedB("CheckpointYes")}}}, 0);
							else
								PlayVoiceSound("{{{SOUNDPATH ^ SOUND_CHECKPOINT_NO}}}", 	{{{Volumes::GetVolumedB("CheckpointNo")}}},  0);
						}
						
						M_CpCountVoice  += 1;
						
						if(M_CpCountVoice > M_CpCommentariesToPlayEachXXCp && !EndLap)
						{
								
							declare CAudioSource SoundToPlay;
							declare Delay = {{{C_COMMENTARIES_DELAY}}};
							
							if(!EndRace)
							{
								if(IsAhead)
									SoundToPlay = M_SoundsCheckpointYes[ML::Rand(0, M_SoundsCheckpointYes.count-1)];
								else
									SoundToPlay = M_SoundsCheckpointNo[ML::Rand(0, M_SoundsCheckpointNo.count-1)];
								PlayVoiceSound(SoundToPlay, {{{Volumes::GetVolumedB("VoiceCommentaries")}}}, Delay);
							}
							
							M_CpCountVoice   = 0;
							M_CpCommentariesToPlayEachXXCp = ML::Rand({{{C_COMMENTARIES_TOPLAY_EACH_XX_CP_MIN}}}, {{{C_COMMENTARIES_TOPLAY_EACH_XX_CP_MAX}}});
						}
					}
					if(!EndRace && !EndLap) {
						Audio.PlaySoundEvent("{{{SOUNDPATH ^ SOUND_CHECKPOINT_TIME}}}", 	{{{Volumes::GetVolumedB("CheckpointTime")}}}, 	{{{C_DELAY_LAP}}});
						// log("¨Play sound");
					}
					
				}
				
				case CTmRaceClientEvent::EType::Impact : 
				{
					if(Now > M_LatestCarHitSound + {{{C_COMMENTARIES_CARHIT_MIN_INTERVAL}}}
						&& 	Event.Player.DamageHullRatio >= 0.1 && Net_ModeName != "Rounds Splitscreen")
					{
						// M_SoundsCarHit[ML::Rand(0, M_SoundsCarHit.count-1)].Play();
						PlayVoiceSound(M_SoundsCarHit[ML::Rand(0, M_SoundsCarHit.count-1)], 	{{{Volumes::GetVolumedB("VoiceCommentaries")}}}, 800);
						M_LatestCarHitSound = Now;
					}
				}
			}
		}
		
		
		
		//////////////////////////////
		// PLUGIN EVENTS LOOP
		
		if(M_PluginInterface_UIPlugin == Null)
		{
			M_PluginInterface_UIPlugin = GetPluginInterface("UIPlugin");
			// log(Now^"> Warning : M_PluginInterface_UIPlugin == Null");
		}
		else
		{
			foreach(Event in M_PluginInterface_UIPlugin.PendingEvents)
			{
				// log(Now ^ "> UI> Received : " ^ Event.EventType);
				
				switch(Event.EventType)
				{
					case "ShowPlugin" : Net_IsPluginEnabled = True;
					case "HidePlugin" : Net_IsPluginEnabled = False;
				}
			}
		}
		
		
		
		//////////////////////////////
		// WHOOSHS        
		
		if(M_PrevTriggerWoosh != M_TriggerWoosh)
		{
			M_PrevTriggerWoosh = M_TriggerWoosh;
			M_SoundWhoosh.Play();
			M_SoundWhoosh.RelativePosition = <0., 0., 0.>;
			M_RandomDir = ML::Rand(-0.5, 0.5);
		}	
		
		if(M_SoundWhoosh != Null)
		{
			declare Speed 			= GUIPlayer.DisplaySpeed;
			declare MinSpeed		= 100.;
			declare MinVolume		= 0.25;
			declare MinPitch		= 0.33;
			if(Speed > MinSpeed)
			{
				declare VolumeRatio	 	= (Speed - MinSpeed) / 500.;
				declare PitchRatio	 	= (Speed - MinSpeed) / 300.;
				declare Volume 			= MinVolume + VolumeRatio;
				declare Pitch 			= MinPitch 	+ PitchRatio;
				
				M_SoundWhoosh.Volume 	= Volume * 0.5;
				M_SoundWhoosh.Pitch 	= Pitch;
				
				declare Pos = AL::Ease("Linear", Now - M_PrevTriggerWoosh*1., 0., -2., 1200.);
				M_SoundWhoosh.RelativePosition = 
				<
					M_RandomDir * Pos * 1., 
					Pos*0.33, 
					Pos
				>;
			}
			else 
			{
				M_SoundWhoosh.Volume = 0.;
			}
		}
		
		
		
		/////////////////////////////
		// CHECKPOINT TIMERS         
		
		declare CpVisibility 	 = Now <= M_TriggerCheckpoint + {{{C_CHECKPOINT_SHOW_DURATION}}};
		declare CpTimeFreeze 	 = Now <= M_TriggerCheckpoint + {{{C_CHECKPOINT_SHOW_DURATION*0.5}}};
		declare CpFade			 = 50;
		declare CpStartOpacity	 = 0.;
		declare CpDiffOpacity	 = 1.;
		declare CpTrigger 		 = M_TriggerCheckpoint;
		declare CpFadeOutTrigger = M_TriggerCheckpoint + {{{C_CHECKPOINT_SHOW_DURATION}}} - C_ANIMSHOW_DURATION;
		
		if(Now >= CpFadeOutTrigger) 
		{
			CpTrigger 		= CpFadeOutTrigger;
			CpStartOpacity 	= 1.;
			CpDiffOpacity 	= -1.;
			CpFade 			= C_ANIMSHOW_DURATION;
		}
		
		declare CpOpacity = G_FadeOpacity * AL::Ease("Linear", Now - CpTrigger*1., CpStartOpacity, CpDiffOpacity, CpFade*1.);
		Label_CheckpointDiff.Visible = CpVisibility && IsThereOpponent;
		Label_CheckpointLap	.Visible = CpVisibility && GUIPlayer.CurrentNbLaps > 0;
		Label_CheckpointLap	.Opacity = CpOpacity;
		Label_CheckpointDiff.Opacity = CpOpacity;
		
		M_ChronoBlinkOpacity = 1.;
		if(CpTimeFreeze) 
		{
			M_ChronoBlinkOpacity = ML::Sin(Now*C_CHECKPOINT_SIN_SPEED) * 0.5 + 0.5;
			Label_Chrono.Value = GetTimeToText(M_LastCpTime);
		}
		
		
		
		/////////////////////////////////
		// OPPONENT BEING CHALLENGED
		
		declare NeedTextUpdate = True;
		
		Frame_Challenge.Visible = IsThereOpponent && Net_ChallengeFrameVisibility;
		
		if(IsThereOpponent && Net_ChallengeFrameVisibility)
		{
			// CHECK WHO'S FIRST WHEN THE GHOST HITS A CHECKPOINT
			
			foreach (I => Checkpoint in Net_OpponentCheckpointsTime)
			{
				if(M_OpponentCheckpointValidated.existskey(I))
				{
					if(M_OpponentCheckpointValidated[I] == False && GUIPlayer.CurRace.Time > Checkpoint) 
					{
						M_OpponentCheckpointValidated[I] 	= True;
						NeedTextUpdate						= False;
						if(M_CurCheckpointIndex < I && M_TimeDiff < 0) 
						{
							M_TriggerChallengeAnim = Now;
							M_TimeDiff = 1;
						}
					}
				}
			}
			
			if(M_PrevTriggerChallengeAnim != M_TriggerChallengeAnim)
			{
				M_PrevTriggerChallengeAnim = M_TriggerChallengeAnim;
				
				if(NeedTextUpdate)
				{
					declare TimeDiffToText 				= GetTimeDiffToText	( M_TimeDiff, GUIPlayer);
					declare TimeDiffToTextOpponent		= GetTimeDiffToText	(-M_TimeDiff, GUIPlayer);
					declare TimeDiffColorPlayer			= GetTimeDiffColor 	( M_TimeDiff, GUIPlayer);
					declare TimeDiffColorOpponent		= GetTimeDiffColor 	(-M_TimeDiff, GUIPlayer);
					if(TimeDiffToText == "" || M_OpponentTime <= 0)
					{
						TimeDiffToText = "--:--.--";
						TimeDiffColorPlayer = {{{ColorWhite}}};
					}
					
					Label_PlayerTimeDiff	.TextColor 	= TimeDiffColorPlayer;
					Label_OpponentTimeDiff	.TextColor 	= TimeDiffColorOpponent;
					
					Label_PlayerTimeDiff	.Value 		= TimeDiffToText;
					Label_OpponentTimeDiff	.Value 		= TimeDiffToTextOpponent;
				}
				
				M_AnimStartPosOpponent 		= Frame_Opponent.RelativePosition;
				M_AnimStartPosPlayer 		= Frame_Player	.RelativePosition;
				if(M_TimeDiff <= 0)
				{
					M_AnimEndPosOpponent 	= C_POS_SECOND;
					M_AnimEndPosPlayer 		= C_POS_FIRST;
				}
				else
				{
					M_AnimEndPosOpponent 	= C_POS_FIRST;
					M_AnimEndPosPlayer 		= C_POS_SECOND;
				}
			}
			
			CheckToPlayMoveTo("BackOut", Frame_Opponent, 	M_TriggerChallengeAnim, M_AnimStartPosOpponent, M_AnimEndPosOpponent, 	C_CHALLENGE_ANIM_DURATION);
			CheckToPlayMoveTo("BackOut", Frame_Player, 		M_TriggerChallengeAnim, M_AnimStartPosPlayer, 	M_AnimEndPosPlayer, 	C_CHALLENGE_ANIM_DURATION);
			
			
			
			// UPDATE THE CHALLENGE FRAME (ONLY WHEN YOU CHANGE THE OPPONENT TYPE - TO BE CHECKED WHEN "CHALLENGING REAL PEOPLE" WILL BE AVAILABLE)
			
			if(M_PrevOpponentType != Net_OpponentType || M_PrevBestTime != Net_BestTime || Pre_OpponentUpdate != Net_OpponentUpdate)
			{
				Pre_OpponentUpdate	= Net_OpponentUpdate;
				M_PrevOpponentType 	= Net_OpponentType;
				M_PrevBestTime 		= Net_BestTime;
				
				M_OpponentCheckpointValidated.clear();
				foreach (Checkpoint in Net_OpponentCheckpointsTime) M_OpponentCheckpointValidated.add(False);
				
				declare Text OpponentImage;
				declare Text OpponentName;
				declare Text OpponentTimeToText;
				M_OpponentTime = -1;
				M_TimeDiff = -1;
				
				switch(Net_OpponentType)
				{
					case TMC_MEDAL_AUTHOR : 
					{
						OpponentImage 		= "medalsmall-author.dds";
						M_OpponentTime		= Net_OpponentCheckpointsTime[OpponentCpLast];
					}
					
					case TMC_MEDAL_GOLD : 
					{
						OpponentImage 		= "";
						OpponentName 		= _("Gold Medal");
						M_OpponentTime		= Net_OpponentCheckpointsTime[OpponentCpLast];
					}
					
					case TMC_MEDAL_SILVER : 
					{
						OpponentImage 		= "";
						OpponentName 		= _("Silver Medal");
						M_OpponentTime		=Net_OpponentCheckpointsTime[OpponentCpLast];
					}
					
					case TMC_MEDAL_BRONZE : 
					{
						OpponentImage 		= "";
						OpponentName 		= _("Bronze Medal");
						M_OpponentTime		= Net_OpponentCheckpointsTime[OpponentCpLast];
					}
					
					case TMC_MEDAL_PLAYER : 
					{
						OpponentName 		= _("Personal record");
						OpponentImage 		= "";
						if(IsThereOpponentCpTime) 
							M_OpponentTime = Net_OpponentCheckpointsTime[OpponentCpLast];
					}
					
					case TMC_MEDAL_ANOTHERPLAYER : 
					{
						declare netread Text Net_OpponentName for UI;
						if(Net_OpponentName == "")
							OpponentName 		= _("Opponent");
						else
							OpponentName 		= TL::ToUpperCase(Net_OpponentName);
							
						OpponentImage 		= "";
						
						if(IsThereOpponentCpTime) 
							M_OpponentTime = Net_OpponentCheckpointsTime[OpponentCpLast];
					}
					case TMC_MEDAL_RECORDCENTER : 
					{
						declare netread Text Net_OpponentName for UI;
						if(Net_OpponentName == "")
							OpponentName 		= _("Opponent");
						else
							OpponentName 		= TL::ToUpperCase(Net_OpponentName);
							
						OpponentImage 		= "";
						
						if(IsThereOpponentCpTime) 
							M_OpponentTime = Net_OpponentCheckpointsTime[OpponentCpLast];
					}
				}	
				
				Quad_OpponentAvatar.Visible 	= False;
				if(OpponentImage != "")
				{
					OpponentImage 				= "{{{IMGPATH}}}" ^ OpponentImage;
					Quad_OpponentAvatar.Visible = True;
				}
				OpponentTimeToText	= TL::TimeToText(M_OpponentTime, True);
				if(OpponentTimeToText == "" || M_OpponentTime <= 0) OpponentTimeToText = "--:--.--";
				
				Label_OpponentName	.Value 		= OpponentName;
				Label_OpponentTime	.Value 		= OpponentTimeToText;
				Quad_OpponentAvatar	.ImageUrl 	= OpponentImage;
				
				if(Net_OpponentCheckpointsTime.count > 0)
				{
					if(Net_BestTime > 0)
					{
						M_TimeDiff 				= Net_BestTime - M_OpponentTime;
						M_TriggerChallengeAnim 	= Now;
					}
				}
			}
			
			
			
			// PLAYER NAME
			declare PlayerNameParts = TL::Split("_", GUIPlayer.Login);
			declare PlayerName = "";
		
			if(PlayerNameParts.existskey(0))
				PlayerName = PlayerNameParts[0];
			if(Net_PlayerNickname != "")
				PlayerName = Net_PlayerNickname;
			
			if(PlayerNameParts.existskey(0))
			{
				// Label_PlayerName.Value = TL::ToUpperCase(PlayerName);
				Label_PlayerName.Value = TL::ToUpperCase(GUIPlayer.User.Name);
				Label_PlayerName.TextColor = {{{ColorYellow}}};
			}
			
			
			
			// PLAYER TIME
			
			declare PlayerTime = TL::TimeToText(Net_BestTime, True);
			if(PlayerTime == "" || PlayerTime == "???") PlayerTime = "--:--.--";
			Label_PlayerTime.Value = PlayerTime;
		}
		
		
		// FREEWHEEL STATE
		declare Hack_CheatEventWarningTimeMax = 5000;	// copie de C_CHEAT_EVENT_WARNING_TIME_MAX dans UI_CheatCode
		declare Hack_HideForBonusModeFreeWheelEvent = (GUIPlayer.BonusModeEventType != CTmMlPlayer::ETmBonusModeEventType::None && 
														(	(GUIPlayer.BonusModeTimeTillEvent == 0	&&	GUIPlayer.BonusModeTimeTillEndEvent > 0) || 
															(GUIPlayer.BonusModeTimeTillEvent > 0	&&	GUIPlayer.BonusModeTimeTillEvent < Hack_CheatEventWarningTimeMax)));
															
		declare IsFreeWheel 	= !Hack_HideForBonusModeFreeWheelEvent && GUIPlayer.FreeWheelingDuration > 0;
		declare IsAnimBackOn	= !Hack_HideForBonusModeFreeWheelEvent && !IsFreeWheel && Now < M_TriggerFreewheel + C_FREEWHEEL_BACKON_DURATION;
		
		if(M_PrevIsFreeWheel != IsFreeWheel)
		{
			M_PrevIsFreeWheel 		= IsFreeWheel;
			Quad_EngineOff.Visible 	= IsFreeWheel;
			M_TriggerFreewheel 		= Now;
			
			if(M_PrevIsFreeWheel)
				M_SoundIsFreewheel.Play();
			else
				M_SoundIsFreewheel.Stop();
		}
		
		Quad_EngineOn.Visible = IsAnimBackOn;
		
		if(IsFreeWheel) 
			Quad_EngineOff.Opacity = C_FREEWHEEL_OPACITY * G_FadeOpacity * (0.5 + ML::Sin(Now * C_FREEWHEEL_SIN_SPEED_OFF)*0.5);
		else 
		if(IsAnimBackOn)
			Quad_EngineOn .Opacity = C_FREEWHEEL_OPACITY * G_FadeOpacity * (0.5 + ML::Sin(Now * C_FREEWHEEL_SIN_SPEED_ON)*0.5);
		
		// FEEDBACK : DRIFT SOUND
		
		if(!Net_IsPauseMenuEnabled && IsRunning && DriftDuration > 500 && Net_ModeName != "Rounds Splitscreen")
		{
			declare PitchRatio 	= DriftDistance / 125.;
			declare MinPitch	= 0.5;
			M_SFX_Rise.VolumedB = {{{Volumes::GetVolumedB("SFXRise")}}};
			M_SFX_Rise.Play();
			M_SFX_Rise.Pitch = MinPitch + PitchRatio;
		}
		else
		{
			M_SFX_Rise.Stop();
		}

		// FEEDBACK : DRIFT && JUMP LABEL
		
		declare JumpVisibility 	= False;
		
		if(Net_ModeName != "Rounds Splitscreen")
		{
			JumpVisibility = IsRunning && (JumpDuration > 500 || (JumpDistance > 50 && JumpDuration > 0)) && (GUIPlayer.InWaterDuration < 500);
			declare CounterPosX		= -74.;
			declare CounterPosY		=  147.;
			declare DriftVisibility = IsRunning && (DriftDuration > 500 || DriftDistance > 50);
			declare DriftPos 		= <-{{{_PosXRatio}}}*CounterPosY, CounterPosX, 3.>;
			declare JumpPos 		= <-{{{_PosXRatio}}}*CounterPosY, CounterPosX+25, 3.>;
			declare HeightVisibility = IsRunning && JumpVisibility && (CarHeight > 1000);
			
			UpdateCounter(Frame_DriftInfo, 	Label_DriftTitle, 	Label_DriftValue, 	DriftDistance, DriftVisibility, DriftPos, 1.);
			UpdateCounter(Frame_JumpInfo, 	Label_JumpTitle, 	Label_JumpValue, 	JumpDistance,  JumpVisibility,  JumpPos,  1.);
			UpdateCounter(Frame_HeightInfo, Label_HeightTitle, 	Label_HeightValue, 	CarHeight,  HeightVisibility,  DriftPos,  1.);
		}
		
		/////////////////////////////////
		// SOUND WHEN CAR IS FYLING (WIND)
		if(!Net_IsPauseMenuEnabled && JumpVisibility && Net_ModeName != "Rounds Splitscreen")
		{
			if(!M_SoundIsFlying.IsPlaying)
				M_SoundIsFlying.Play(); 
			
			if(M_SoundIsFlyingDesiredVolume < {{{Volumes::GetVolume("StateFlying")}}})
			{
				M_SoundIsFlyingDesiredVolume += Period * 0.0009;
				if(M_SoundIsFlyingDesiredVolume > {{{Volumes::GetVolume("StateFlying")}}})
					M_SoundIsFlyingDesiredVolume = {{{Volumes::GetVolume("StateFlying")}}};
			}
		}
		else
		{
			if(M_SoundIsFlyingDesiredVolume > 0. && !Net_IsPauseMenuEnabled)
			{
				M_SoundIsFlyingDesiredVolume -= Period * 0.0009;
				if(M_SoundIsFlyingDesiredVolume < 0.)
					M_SoundIsFlyingDesiredVolume = 0.;
			}
			else
			{
				if(M_SoundIsFlying.IsPlaying) 
					M_SoundIsFlying.Stop(); 
			}
		}
		
		if(M_SoundIsFlying.IsPlaying)
		{	
			M_SoundIsFlying.Volume = M_SoundIsFlyingDesiredVolume;
			M_SoundIsFlying.Pitch = AL::Ease("Linear", SpeedValue*1., 0.5, 1., 350.);
		}
		
		
		
		/////////////////////////////////
		// MESSAGE
		
		
		if(M_PrevTriggerMessage != M_TriggerMessage)
		{
			if(Now >= M_TriggerMessage)
			{
				M_PrevTriggerMessage = M_TriggerMessage;
				if(M_MessageSound != "") 
				{
					PlayVoiceSound("{{{SOUNDPATH_VOICES}}}"^M_MessageSound, {{{Volumes::GetVolumedB("VoiceMessage")}}});
					Video_BgAnim.Stop();
					Video_BgAnim.Play();
				}
			}
		}
		
		
		
		
		/////////////////////////////////
		// TURBO VISIBILITY AND BLINK      
		
		if(GUIPlayer.EngineTurboRatio > 0)
		{
			// log(" : "^0.5 + 0.5 * (1.-GUIPlayer.EngineTurboRatio));
			Quad_Turbo.Visible = True;
			Quad_Turbo.Opacity = {{{C_WHITE_OPACITY}}} * (0.5 + 0.5 * ML::Sin(Now * {{{C_TURBO_ANIM_BLINKSPEED}}}));
		}
		else
		{
			Quad_Turbo.Visible = False;
		}
		
		
		/////////////////////////////////
		// MAIN UPDATE (ALTERNATED)      
		
		M_SwitchUpdateAlternate = !M_SwitchUpdateAlternate;
		if(M_SwitchUpdateAlternate) // UPDATE : A-SIDE
		{
			declare CurrentNbLapsToText 	= ""^GUIPlayer.CurrentNbLaps + 1;
			declare MapNbLapsToText 		=  ""^Net_NbLaps;
			Label_LapCurrent	.Value 		= CurrentNbLapsToText;
			Label_LapMax		.Value 		= MapNbLapsToText;
			Frame_LapsToGo		.Visible 	= Map.TMObjective_IsLapRace && GUIPlayer.RaceState != CTmMlPlayer::ERaceState::BeforeStart;
			
			
			
			if(M_PrevSpeedValue != SpeedValue || M_ResetGaugeNeeded) 
			{
				if(!GUIPlayer.InputIsBraking && M_PrevSpeedValue <= 5 && SpeedValue > 5) 
				{ 
					if(Net_ModeName != "Rounds Splitscreen") {
						Quad_SpeedEffect.Scale = 1.;
						PlayVideoQuad(Quad_SpeedEffect, 1500, "{{{VIDEOPATH^VIDEO_SPEEDSTEP}}}"); 
						M_SoundSpeedEffect.Stop();
						Audio.PlaySoundEvent(M_SoundSpeedEffect, {{{Volumes::GetVolumedB("SpeedEffectStart")}}}, 0);
					}
				}  
				M_PrevSpeedValue = SpeedValue;

				// SPEED COUNTER : LABEL
				declare Text SpeedToText = TL::ToText(SpeedValue);
				
				if	(SpeedValue < 100) 	
				{
					if (SpeedValue < 10) 	SpeedToText = "00"^	SpeedToText;
					else 					SpeedToText = "0"^	SpeedToText;
				}
				
				Label_Speed.Value = SpeedToText;
				
				
				
				// SPEED COUNTER : GAUGE
				
				M_GaugeRatio = SpeedValue / {{{C_SPEED_FULLCIRCLEVALUE}}};
				
				if(M_GaugeRatioPersistent < M_GaugeRatio)
				{
					M_LatestUpGaugeRatio 		= Now;
					M_GaugeRatioPersistent 		= M_GaugeRatio;
				}
				else
				{
					declare CurrTime = Now - M_LatestUpGaugeRatio;
					if(CurrTime >= {{{C_GAUGEPERSISTENT_FADEDURATION}}})
					{
						M_LatestUpGaugeRatio  	= Now;
						M_GaugeRatioPersistent 	= M_GaugeRatio;
					}		
				}
				
				SetGauges(Quad_GaugeLeft, Quad_GaugeRight, M_GaugeRatio);
				
				if(M_PrevGaugeRatioPersistent != M_GaugeRatioPersistent || M_ResetGaugeNeeded) {
					M_PrevGaugeRatioPersistent = M_GaugeRatioPersistent;
					if(M_ResetGaugeNeeded) M_GaugeRatioPersistent = 0.;
					SetGauges(Quad_GaugePersistentLeft, Quad_GaugePersistentRight, 	M_GaugeRatioPersistent);
				}
				
				M_ResetGaugeNeeded = False;
			}
			
			
			
			if (UI != Null && M_PrevUIStatus != UI.UIStatus) 
			{
				M_PrevUIStatus = UI.UIStatus;
				switch (UI.UIStatus) 
				{
					case CUIConfig::EUIStatus::Warning	: Label_Chrono.TextColor = <1., 0., 0.>;
					case CUIConfig::EUIStatus::Error	: Label_Chrono.TextColor = <1., 0., 0.>;
					case CUIConfig::EUIStatus::Official	: Label_Chrono.TextColor = <0., 0., 0.>;
					default								: Label_Chrono.TextColor = <1., 1., 1.>;
				}
			}
			
			if(IsRunning && !CpVisibility)
			{
				// log(Now);
				if(GUIPlayer.CurRace != Null) Label_Chrono.Value = GetTimeToText(GUIPlayer.CurRace.Time);
			}
		}
		else // UPDATE : B-SIDE
		{
		
			// GAUGE COLOR SETTING
			
			declare GaugeColorUpdate = False;
			if(M_GaugeRatio > M_LatestGaugeRatioStep + 0.25 || M_GaugeRatio < M_LatestGaugeRatioStep)
			{
				declare Real GaugeHue;
				if		(M_GaugeRatio >= 0. 	&& M_GaugeRatio < 0.25) { M_LatestGaugeRatioStep = 0.00; GaugeHue = 0.00; 	}
				else if	(M_GaugeRatio >= 0.25 	&& M_GaugeRatio < 0.5) 	{ M_LatestGaugeRatioStep = 0.25; GaugeHue = 0.05;	}		
				else if	(M_GaugeRatio >= 0.5 	&& M_GaugeRatio < 0.75) { M_LatestGaugeRatioStep = 0.50; GaugeHue = 0.1;	}	
				else if	(M_GaugeRatio >= 0.75 	&& M_GaugeRatio < 1.) 	{ M_LatestGaugeRatioStep = 0.75; GaugeHue = 0.15;	}
				else if	(M_GaugeRatio >= 1.		&& M_GaugeRatio < 1.25) { M_LatestGaugeRatioStep = 1.00; GaugeHue = 0.3;	}
				else if	(M_GaugeRatio >= 1.25	&& M_GaugeRatio < 1.5) 	{ M_LatestGaugeRatioStep = 1.25; GaugeHue = 0.4;	}
				else if	(M_GaugeRatio >= 1.5	&& M_GaugeRatio < 1.75) { M_LatestGaugeRatioStep = 1.50; GaugeHue = 0.5;	}
				else if	(M_GaugeRatio >= 1.75	&& M_GaugeRatio < 2.) 	{ M_LatestGaugeRatioStep = 1.75; GaugeHue = 0.6;	}
				else if	(M_GaugeRatio >= 2.		&& M_GaugeRatio < 2.25) { M_LatestGaugeRatioStep = 2.00; GaugeHue = 0.7;	}
				else if	(M_GaugeRatio >= 2.25	&& M_GaugeRatio <= 2.5) { M_LatestGaugeRatioStep = 2.25; GaugeHue = 0.8;	}
				M_GaugeColor 		= ToRGB(<GaugeHue, 1., 1.>);
				
				declare Vec3 UI_GaugeColor for UI;
				UI_GaugeColor = M_GaugeColor;
				
				GaugeColorUpdate 	= True;
			}
			
			
			
			// GAUGE ANIMATION TRIGGER
			
			if(ML::FloorInteger(M_PrevGaugeRatioAnim) != ML::FloorInteger(M_GaugeRatio)) 
			{ 
				M_TriggerAnim = Now; 
				if(ML::FloorInteger(M_PrevGaugeRatioAnim) < ML::FloorInteger(M_GaugeRatio)) 
				{
					if(Net_ModeName != "Rounds Splitscreen") {
						Quad_SpeedEffect.Scale = 1.37;
						PlayVideoQuad(Quad_SpeedEffect, 1500, "{{{VIDEOPATH^VIDEO_SPEEDSTEP}}}");
						M_SoundSpeedEffect.Stop();
						Audio.PlaySoundEvent(M_SoundSpeedEffect, {{{Volumes::GetVolumedB("SpeedEffect")}}}, 0);
					}
					
					// Video_BgAnim.Stop();
					// Video_BgAnim.Play();
				}
				M_PrevGaugeRatioAnim = M_GaugeRatio; 
			}	

			CheckToPlayAnimScaleTo("ElasticOut", Frame_SpeedGauge, 	M_TriggerAnim, 0.5, 1., 750);
			
			
			
			// GAUGE PERSISTENT FADE OUT : OPACITY VALUE
			
			declare Real QuadOpacity = {{{C_GAUGEPERSISTENT_OPACITY}}};
			if(M_GaugeRatioPersistent != M_GaugeRatio)
			{
				
				
				declare CurrTime = Now - M_LatestUpGaugeRatio;
				if(M_GaugeRatioPersistent >= M_GaugeRatio && CurrTime < {{{C_GAUGEPERSISTENT_FADEDURATION}}}) 
				{
					QuadOpacity = (1. - CurrTime*1. / {{{1.* C_GAUGEPERSISTENT_FADEDURATION}}}) * {{{C_GAUGEPERSISTENT_OPACITY}}};
				}
				else
				{
					QuadOpacity = 0.;
				}
			}
			
			
			
			// GAUGE COLOR, AND PERSISTENT FADE OUT
			if(GaugeColorUpdate || QuadOpacity != -1.) 
			{
				foreach(I => Quad_Persistent in Quad_GaugePersistent) 
				{
					if(GaugeColorUpdate)
					{
						Quad_Gauge[I]	.Colorize 	= M_GaugeColor;
						Quad_Persistent	.Colorize 	= M_GaugeColor;
					}
					Quad_Gauge[I]		.Opacity 	= 1. 			* G_FadeOpacity; 
					Quad_Persistent		.Opacity 	= QuadOpacity 	* G_FadeOpacity; 
				}
				Quad_SpeedEffect.Colorize = M_GaugeColor;
				// Quad_Turbo		.Colorize = M_GaugeColor;
			}
		}
	}
}
--></script>""";
	Prompter2::Unload();
	return ML;
}

Text Private_GetML321Go() 
{
	// EG
	// Alors
	// le Frame_321Go contient en fait les images "Glow"
	// le Frame_321GoNormal contient les images "normales" du 3, 2, 1 go (GO x 2 pour l'effet de clignottement)
	declare Text ML =
	"""
	<framemodel id="Framemodel_321Go">
		<quad id="Quad_3" 	posn="0 0 .1" 	sizen="{{{C_INTRO_QUAD_SIZE}}} 		{{{C_INTRO_QUAD_SIZE}}}" image="{{{IMGPATH^IMG_INTRO_GLOW_3}}}" 	opacity="{{{C_INTRO_QUAD_OPACITY}}}" {{{hC}}} {{{vC}}} />
		<quad id="Quad_2" 	posn="0 0 .1" 	sizen="{{{C_INTRO_QUAD_SIZE}}} 		{{{C_INTRO_QUAD_SIZE}}}" image="{{{IMGPATH^IMG_INTRO_GLOW_2}}}" 	opacity="{{{C_INTRO_QUAD_OPACITY}}}" {{{hC}}} {{{vC}}} />
		<quad id="Quad_1"  	posn="0 0 .1" 	sizen="{{{C_INTRO_QUAD_SIZE}}} 		{{{C_INTRO_QUAD_SIZE}}}" image="{{{IMGPATH^IMG_INTRO_GLOW_1}}}" 	opacity="{{{C_INTRO_QUAD_OPACITY}}}" {{{hC}}} {{{vC}}} />
		<quad id="Quad_GoHead"  posn="0 0 .1" 	sizen="{{{C_INTRO_QUAD_SIZE*2.}}} 	{{{C_INTRO_QUAD_SIZE}}}" image="{{{IMGPATH^IMG_INTRO_GLOW_GO}}}" opacity="{{{C_INTRO_QUAD_OPACITY_NORMAL}}}" {{{hC}}} {{{vC}}} />
		<quad id="Quad_GoTail"  posn="0 0 .1" 	sizen="{{{C_INTRO_QUAD_SIZE*2.}}} 	{{{C_INTRO_QUAD_SIZE}}}" image="{{{IMGPATH^IMG_INTRO_GLOW_GO}}}" opacity="{{{C_INTRO_QUAD_OPACITY_NORMAL}}}" {{{hC}}} {{{vC}}} />
	</framemodel>
	
	<frameinstance id="Frame_321GoNormal" 	posn="{{{C_INTRO_POSX}}} {{{C_INTRO_POSY}}} 10." hidden="1" modelid="Framemodel_321Go" />
	<frameinstance id="Frame_321Go" 		posn="{{{C_INTRO_POSX}}} {{{C_INTRO_POSY}}} 9." hidden="1" modelid="Framemodel_321Go" />
	
	<script><!--
	
	{{{Manialink::GetIncludes()}}}
	#Const DebugName  "L_321Go"
	{{{Manialink::Load("GameTime")}}}
	
	{{{Volumes::GetPlayVoiceSoundML()}}}
	
	
	main() 
	{
		declare netread Integer LibTMC_321Go_TriggerAnim 		for UI;
		declare netread Integer LibTMC_321Go_TriggerCancelAnim 	for UI;
		
		declare CMlFrame	Frame_321Go 		<=> (Page.GetFirstChild("Frame_321Go") 			as CMlFrame);
		declare CMlFrame	Frame_321GoNormal 	<=> (Page.GetFirstChild("Frame_321GoNormal") 	as CMlFrame);
		
		declare CMlQuad 	Quad_3 				<=> (Frame_321Go.GetFirstChild("Quad_3") 		as CMlQuad);
		declare CMlQuad 	Quad_2 				<=> (Frame_321Go.GetFirstChild("Quad_2") 		as CMlQuad);
		declare CMlQuad 	Quad_1 				<=> (Frame_321Go.GetFirstChild("Quad_1") 		as CMlQuad);
		declare CMlQuad 	Quad_GoHead 			<=> (Frame_321Go.GetFirstChild("Quad_GoHead") 		as CMlQuad);
		declare CMlQuad 	Quad_GoTail 			<=> (Frame_321Go.GetFirstChild("Quad_GoTail") 		as CMlQuad);
		
		declare CMlQuad 	Quad_3Normal 		<=> (Frame_321GoNormal.GetFirstChild("Quad_3") 	as CMlQuad);
		declare CMlQuad 	Quad_2Normal 		<=> (Frame_321GoNormal.GetFirstChild("Quad_2") 	as CMlQuad);
		declare CMlQuad 	Quad_1Normal 		<=> (Frame_321GoNormal.GetFirstChild("Quad_1") 	as CMlQuad);
		declare CMlQuad 	Quad_GoNormalHead 		<=> (Frame_321GoNormal.GetFirstChild("Quad_GoHead") as CMlQuad);
		declare CMlQuad 	Quad_GoNormalTail 		<=> (Frame_321GoNormal.GetFirstChild("Quad_GoTail") as CMlQuad);
		
		declare CMlQuad[]	Quads 		= [Quad_3,  Quad_2, Quad_1, Quad_GoHead, Quad_GoTail];
		
		
		foreach(Quad in Quads) Quad.Blend = CMlQuad::EBlendMode::Add;
		
		Quad_3Normal		.ImageUrl 	= "{{{IMGPATH^IMG_INTRO_3}}}";
		Quad_2Normal		.ImageUrl 	= "{{{IMGPATH^IMG_INTRO_2}}}";
		Quad_1Normal		.ImageUrl 	= "{{{IMGPATH^IMG_INTRO_1}}}";
		Quad_GoNormalHead	.ImageUrl 	= "{{{IMGPATH^IMG_INTRO_GO}}}";
		Quad_GoNormalTail	.ImageUrl 	= "{{{IMGPATH^IMG_INTRO_GO2}}}";
		
		Frame_321Go			.Visible 	= False;
		Frame_321GoNormal	.Visible 	= False;
		
		Quad_3Normal.Visible = False;
		Quad_2Normal.Visible = False;
		Quad_1Normal.Visible = False;
		
		declare Countries = [
		 "ara"
		,"eng"
		,"fra"
		,"ger"
		,"ner"
		,"por"
		,"ita"
		,"jap"
		,"kor"
		,"rus"
		,"spa"
		// ,"swe"
		// ,"tur"
		];
		declare SoundRace3 		= Audio.CreateSound("{{{SOUNDPATH^SOUND_RACE_3}}}", 			{{{Volumes::GetVolumedB("VoiceRace321Go")}}}, False, False, False);
		declare SoundRace2 		= Audio.CreateSound("{{{SOUNDPATH^SOUND_RACE_2}}}", 			{{{Volumes::GetVolumedB("VoiceRace321Go")}}}, False, False, False);
		declare SoundRace1 		= Audio.CreateSound("{{{SOUNDPATH^SOUND_RACE_1}}}", 			{{{Volumes::GetVolumedB("VoiceRace321Go")}}}, False, False, False);
		declare SoundRaceGo 	= Audio.CreateSound("{{{SOUNDPATH^SOUND_RACE_GO}}}", 			{{{Volumes::GetVolumedB("VoiceRace321Go")}}}, 	False, False, False);
		
		declare CAudioSource[][] SoundsRaceAll;
		foreach(Country in Countries)
		{
			declare CAudioSource[] Sounds;
			Sounds.add(Audio.CreateSound("{{{SOUNDPATH}}}Race321Go/"^Country^"-{{{SOUND_RACE_3}}}", {{{Volumes::GetVolumedB("VoiceRace321")}}}, False, False, False));
			Sounds.add(Audio.CreateSound("{{{SOUNDPATH}}}Race321Go/"^Country^"-{{{SOUND_RACE_2}}}", {{{Volumes::GetVolumedB("VoiceRace321")}}}, False, False, False));
			Sounds.add(Audio.CreateSound("{{{SOUNDPATH}}}Race321Go/"^Country^"-{{{SOUND_RACE_1}}}", {{{Volumes::GetVolumedB("VoiceRace321")}}}, False, False, False));
			Sounds.add(Audio.CreateSound("{{{SOUNDPATH}}}Race321Go/"^Country^"-{{{SOUND_RACE_GO}}}", {{{Volumes::GetVolumedB("VoiceRaceGo")}}}, False, False, False));
			SoundsRaceAll.add(Sounds);
		}
		
		declare SoundsRace 		= [SoundRace3, SoundRace2, SoundRace1, SoundRaceGo];
		declare Integer Anim_321GoEnd 	= -1;
		declare Integer StepDuration 	= 920;
		declare Integer TimerGo			= 0;
		
		declare Integer WhichSec 		= 3;
		declare Integer PreWhichSec		= -1; ///< Not 3 or we do not play the first "3" sound
		
		declare netread Integer 	Net_SplitscreenMode 	for UI;
		declare			 Integer 	Pre_SplitscreenMode 	for UI;
		Pre_SplitscreenMode = -1;
		
		// Randomize first 321Go sounds
		if (SoundsRaceAll.count > 0) SoundsRace = SoundsRaceAll[ML::Rand(0, SoundsRaceAll.count-1)];
		
		while (True) 
		{
			yield;
			LibManialink_AnimLoop();
			if(GUIPlayer == Null) continue;

			if(Pre_SplitscreenMode != Net_SplitscreenMode) {
				if(Net_SplitscreenMode > 1) {
					Frame_321GoNormal.RelativePosition.Z 	= 40.;
					Frame_321Go.RelativePosition.Z 			= 39.;
				} else {
					Frame_321GoNormal.RelativePosition.Z 	= 10.;
					Frame_321Go.RelativePosition.Z 			= 9.;
				}
				Pre_SplitscreenMode = Net_SplitscreenMode;
			}
			
			if(GUIPlayer != Null && GameTime < GUIPlayer.RaceStartTime && GUIPlayer.RaceStartTime != -1) {
				Quad_GoTail			.Visible = False;
				Quad_GoHead			.Visible = False;
				Frame_321GoNormal	.Visible = True;
				Quad_GoNormalHead.Visible = False;
				Quad_GoNormalTail.Visible = False;

				// At least 500ms before the "go" to say "one"
				if (GUIPlayer.RaceStartTime - GameTime > 500 && GUIPlayer.RaceStartTime - GameTime <= 1000) {
					Quad_3Normal.Visible = False;
					Quad_2Normal.Visible = False;
					Quad_1Normal.Visible = True;
					Quad_1Normal.Opacity = 1.;
					
					WhichSec = 1;
					
					if(PreWhichSec != WhichSec) {
						declare Volume = {{{Volumes::GetVolumedB("VoiceRace321")}}};
						// PlayVoiceSound(SoundsRace[2], Volume, 100);
						Audio.PlaySoundEvent(SoundsRace[2], Volume, 100);
						PreWhichSec = WhichSec;
					}
				} else if (GUIPlayer.RaceStartTime - GameTime > 1500 && GUIPlayer.RaceStartTime - GameTime <= 2000) {
					Quad_3Normal.Visible = False;
					Quad_2Normal.Visible = True;
					Quad_3Normal.Visible = False;
					Quad_2Normal.Opacity = 1.;
					
					WhichSec = 2;
					
					if(PreWhichSec != WhichSec) {
						declare Volume = {{{Volumes::GetVolumedB("VoiceRace321")}}};
						// PlayVoiceSound(SoundsRace[1], Volume, 100);
						Audio.PlaySoundEvent(SoundsRace[1], Volume, 100);
						PreWhichSec = WhichSec;
					}
				} else if (GUIPlayer.RaceStartTime - GameTime > 2500 && GUIPlayer.RaceStartTime - GameTime <= 3000) {
					Quad_3Normal.Visible = True;
					Quad_2Normal.Visible = False;
					Quad_1Normal.Visible = False;
					Quad_3Normal.Opacity = 1.;
					
					WhichSec = 3;
					
					if(PreWhichSec != WhichSec) {
						SoundsRace = SoundsRaceAll[ML::Rand(0, SoundsRaceAll.count-1)];
						declare Volume = {{{Volumes::GetVolumedB("VoiceRace321")}}};
						// log("VOLUME 321 RACE: "^Volume);
						// PlayVoiceSound(SoundsRace[0], Volume, 100);
						Audio.PlaySoundEvent(SoundsRace[0], Volume, 100);
						PreWhichSec = WhichSec;
					}
				}
			} else if(GUIPlayer != Null && GUIPlayer.RaceState == CTmMlPlayer::ERaceState::Running) {
			
				Anim_321GoEnd = Now;
				WhichSec = 0;
					
				if(PreWhichSec != WhichSec) {
					declare Volume = {{{Volumes::GetVolumedB("VoiceRaceGo")}}};
					// PlayVoiceSound(SoundsRace[3], Volume, 100);
					Audio.PlaySoundEvent(SoundsRace[3], Volume, 100);
					PreWhichSec = WhichSec;
					TimerGo = Now + 1000;
				}
				
				if(Now < TimerGo) {
					Quad_1Normal.Visible = False;
					Quad_1Normal.Opacity = 1.;
					Quad_GoNormalTail.Opacity = 1.;
					if(Anim_321GoEnd > 0 && Now > (Anim_321GoEnd - StepDuration + 100)) { // petit delta
						declare Alternate = ML::Sin(Now*0.06) >= 0;
						if(Alternate) {
							Quad_GoNormalHead.Visible = True;
							Quad_GoNormalTail.Visible = False;
							
						} else {
							Quad_GoNormalHead.Visible = False;
							Quad_GoNormalTail.Visible = True;
						}
					}
				} else {
					Frame_321GoNormal	.Visible = False;
				}
			} else {
				Quad_GoTail			.Visible = False;
				Quad_GoHead			.Visible = False;
				Frame_321GoNormal	.Visible = False;
			}
		}
	}
	--></script>
	""";
	
	return ML;
}

Text Private_GetPressToRestart() 
{
	declare IMGSelect 		= UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Select);
	declare Color 			= Colors::GetColorXml("Red");
	declare RespawnName 	= UIBindingPadButtons::GetRespawnKeyCode();
	declare RestartName		= UIBindingPadButtons::GetRestartKeyCode();
	
	declare TextStyle = """ 
		sizen="320 180" 
		 
		textfont="{{{G_FontMain}}}"
		textsize="3"
	""";
	
	declare Text ML =

	"""
	
	<!--<frame id="Frame_PressToRestart" posn="{{{143-C_PRESSTORESTART_IMG_SIZE/2.}}} -40 10." hidden="0">-->
	<frame id="Frame_PressToRestart" posn="115 -68 10." hidden="0" scale="0.8">
		
		{{{UIBindingPadButtons::InjectInManialink(C_LAYERNAME_PRESS_TO_RESTART, RespawnName, <-5., 1.5, 1.>, 0.8)}}}
		
		<quad id="ButtonRespawn" image="{{{UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Action2)}}}" 
			posn="-5 1.5 0" 	halign="center" valign="center" sizen="6 6"/>
		<label id="LabelRespawn" text="{{{_("Respawn")}}}" {{{TextStyle}}} textprefix="$t" 
			posn="-15 2 0" 	halign="right" valign="center" textcolor="fff"/>
		<quad id="ButtonRestart" image="{{{UIButtons::GetIngameRestartImage()}}}" 
			posn="0 -5.5 0" 	halign="right" valign="center" sizen="6 6"/>
		
		{{{UIBindingPadButtons::InjectInManialink(C_LAYERNAME_PRESS_TO_RESTART, RestartName, <0., -5.5, 0.>, 0.8)}}}
		
		<label id="LabelRestart" text="{{{_("Restart")}}}" {{{TextStyle}}} textprefix="$t" 
			posn="-10 -5 0" 	halign="right" valign="center" textcolor="fff"/>
		
	<!--		
		<quad id="Quad_Bg" 
		posn="0  {{{-C_PRESSTORESTART_IMG_SIZE*0.032}}} .1" 
		sizen="{{{C_PRESSTORESTART_IMG_SIZE}}} {{{C_PRESSTORESTART_IMG_SIZE/2.}}}" 
		valign="center" 
		halign="center" 
		bgcolor="{{{Color}}}" 
		colorize="{{{Color}}}" 
		image="{{{IMGPATH^IMG_PRESS_TO_RESTART_BG}}}"
		/>	
		
		<label id="Label_Title" 
		posn="0 {{{C_PRESSTORESTART_TEXT_INTERLIGN}}} .2"
		valign="bottom" 
		{{{TextStyle}}}
		textcolor="{{{Color}}}"
		halign="center"
		textprefix="$t"
		/>
		
		
		<label id="Label_Subtitle" 
		posn="0 {{{-C_PRESSTORESTART_TEXT_INTERLIGN}}} .2"
		valign="top" 
		{{{TextStyle}}}
		halign="center"
		textcolor="{{{Color}}}"
		textprefix="$t"
		/>
--> 
	</frame>
	
	<script><!--
	
	#Include "MathLib" as ML
	#Include "TextLib" as TL
	#Const C_Device_Keyboard 	0
	#Const C_Device_Pad 		1
	
	{{{UIBindingPadButtons::InjectInGlobals()}}}
	{{{UIButtons::GetMLFunctionPcButtons()}}}
	declare Integer G_MyVariable;
	
	{{{UIBindingPadButtons::InjectInFunctions()}}}
	
	Void EmptyFunction() {
	
	}
	
	main()
	{
		declare Frame_PressToRestart 		<=> (Page.MainFrame.GetFirstChild("Frame_PressToRestart") 	as CMlFrame);
		declare ButtonRespawn 				<=> (Page.MainFrame.GetFirstChild("ButtonRespawn") 				as CMlQuad);
		declare ButtonRestart 				<=> (Page.MainFrame.GetFirstChild("ButtonRestart") 				as CMlQuad);
		declare LabelRespawn 				<=> (Frame_PressToRestart.GetFirstChild("LabelRespawn") 			as CMlLabel);
		declare LabelRestart				<=> (Frame_PressToRestart.GetFirstChild("LabelRestart") 		as CMlLabel);
		
		{{{UIBindingPadButtons::InjectInInit(C_LAYERNAME_PRESS_TO_RESTART)}}}
		
		
		
		declare Prev_PageIsVisible = !PageIsVisible;
		
		declare Vec3 UI_GaugeColor for UI;
		declare netwrite Integer Net_LibLastDeviceUsed_LastDeviceUsed for UI;
		declare netwrite Boolean Net_IsPauseMenuEnabled 		for UI;
		
		while(True) 
		{
			yield;
			
			{{{UIBindingPadButtons::InjectInLoop()}}}
			
			if(Prev_PageIsVisible != PageIsVisible)
			{
				Prev_PageIsVisible = PageIsVisible;
				// if(Prev_PageIsVisible) TriggerShow 	= Now;
			}
			
			if(Prev_PageIsVisible)
			{
				if(!Net_IsPauseMenuEnabled) {
					Frame_PressToRestart.Visible = True;
					declare Opacity = 0.5 + 0.5 * ML::Sin(Now*{{{C_SPEED_SLOWANIM_BLINKSPEED}}});
					
					ButtonRespawn.Visible = False;
					ButtonRestart.Visible = False;
									
					SetBindableKeysVisible("{{{RespawnName}}}", True);
					// SetBindableKeysOpacity("{{{RespawnName}}}", Opacity);
					SetBindableKeysVisible("{{{RestartName}}}", True);
					// SetBindableKeysOpacity("{{{RestartName}}}", Opacity);
					
					/*
					if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Keyboard) {
						
						
					} else if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Pad) {
						ButtonRespawn.Visible = True;
						ButtonRestart.Visible = True;
						
						ButtonRespawn.ImageUrl = GetImageForButton("{{{UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Action2)}}}");
						ButtonRestart.ImageUrl = GetImageForButton("{{{UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Cancel)}}}");
						
						SetBindableKeysVisible("{{{RestartName}}}", False);
						SetBindableKeysVisible("{{{RespawnName}}}", False);
						
						ButtonRespawn		.Opacity = Opacity;
						ButtonRestart		.Opacity = Opacity;
					}
					*/
					LabelRespawn		.Opacity = Opacity;
					LabelRestart		.Opacity = Opacity;
				} else {
					Frame_PressToRestart.Visible = False;
				}
			}
		}
	}
	--></script>
	""";
	
	return ML;
}


Text Private_CampaignHelper() 
{
	declare IMGSelect 		= UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Select);
	declare Color 			= Colors::GetColorXml("Red");
	declare RespawnName 	= UIBindingPadButtons::GetRespawnKeyCode();
	declare RestartName		= UIBindingPadButtons::GetRestartKeyCode();
	
	declare TextStyle = """ 
		sizen="320 180" 
		 
		textfont="{{{G_FontMain}}}"
		textsize="3"
	""";
	
	declare Text ML =
	"""
	<frame id="Frame_PressToRestart" posn="10 -50 10." hidden="0" scale="0.8">
		{{{UIBindingPadButtons::InjectInManialink("CampaignHelper", RespawnName, <5., 1.5, 1.>, 0.8)}}}
		
		<quad id="ButtonRespawn" image="{{{UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Action2)}}}" 
			posn="0 1.5 0" 	halign="center" valign="center" sizen="6 6"/>
		<label id="LabelRespawn" text="{{{_("Respawn")}}}" {{{TextStyle}}} textprefix="$t" 
			posn="-5 2 0" 	halign="right" valign="center" textcolor="fff"/>
		<quad id="ButtonRestart" image="{{{UIButtons::GetIngameRestartImage()}}}" 
			posn="0 -5.5 0" 	halign="right" valign="center" sizen="6 6"/>
		
		{{{UIBindingPadButtons::InjectInManialink("CampaignHelper", RestartName, <5., -5.5, 0.>, 0.8)}}}
		
		<label id="LabelRestart" text="{{{_("Restart")}}}" {{{TextStyle}}} textprefix="$t" posn="-5 -5 0" 	halign="right" valign="center" textcolor="fff"/>
		
	</frame>
	
	<script><!--
	
	#Include "MathLib" as ML
	#Include "TextLib" as TL
	#Const C_Device_Keyboard 	0
	#Const C_Device_Pad 		1
	
	{{{UIBindingPadButtons::InjectInGlobals()}}}
	{{{UIButtons::GetMLFunctionPcButtons()}}}
	declare Integer G_MyVariable;
	
	{{{UIBindingPadButtons::InjectInFunctions()}}}
	
	Void EmptyFunction() {
	
	}
	
	main()
	{
		declare Frame_PressToRestart 		<=> (Page.MainFrame.GetFirstChild("Frame_PressToRestart") 	as CMlFrame);
		declare ButtonRespawn 				<=> (Page.MainFrame.GetFirstChild("ButtonRespawn") 				as CMlQuad);
		declare ButtonRestart 				<=> (Page.MainFrame.GetFirstChild("ButtonRestart") 				as CMlQuad);
		declare LabelRespawn 				<=> (Frame_PressToRestart.GetFirstChild("LabelRespawn") 			as CMlLabel);
		declare LabelRestart				<=> (Frame_PressToRestart.GetFirstChild("LabelRestart") 		as CMlLabel);
		
		{{{UIBindingPadButtons::InjectInInit("CampaignHelper")}}}
		
		
		
		declare Prev_PageIsVisible = !PageIsVisible;
		
		declare Vec3 UI_GaugeColor for UI;
		declare netwrite Integer Net_LibLastDeviceUsed_LastDeviceUsed for UI;
		declare netwrite Boolean Net_IsPauseMenuEnabled 		for UI;
		
		while(True) 
		{
			yield;
			
			{{{UIBindingPadButtons::InjectInLoop()}}}
			
			if(Prev_PageIsVisible != PageIsVisible)
			{
				Prev_PageIsVisible = PageIsVisible;
			}
			declare Opacity = 0.5 + 0.5 * ML::Sin(Now*{{{C_SPEED_SLOWANIM_BLINKSPEED}}});
			// log(Now^"I am alive");
			
			ButtonRespawn.Visible = False;
			ButtonRestart.Visible = False;
							
			SetBindableKeysVisible("{{{RespawnName}}}", True);
			SetBindableKeysVisible("{{{RestartName}}}", True);
			
			/*
			if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Keyboard) {
				
			} else if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Pad) {
				ButtonRespawn.Visible = True;
				ButtonRestart.Visible = True;
				
				ButtonRespawn.ImageUrl = GetImageForButton("{{{UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Action2)}}}");
				ButtonRestart.ImageUrl = GetImageForButton("{{{UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Cancel)}}}");
				
				SetBindableKeysVisible("{{{RestartName}}}", False);
				SetBindableKeysVisible("{{{RespawnName}}}", False);
				
				ButtonRespawn		.Opacity = Opacity;
				ButtonRestart		.Opacity = Opacity;
			}
			*/
			
			LabelRespawn		.Opacity = Opacity;
			LabelRestart		.Opacity = Opacity;
		}
	}
	--></script>
	""";
	
	return ML;
}

Text Private_TimeOutTimer() 
{
	declare Color = Colors::GetColorXml("Red");
	
	declare Text ML =
	"""
	
	<frame id="Frame_TimeOutTimer" posn="0. 0. 0." hidden="0">
		<label id="Label_Explanation" 
			posn="0. 7. .2"
			valign="center"
			halign="center"
			textfont="{{{G_FontMain}}}"
			textcolor="{{{Color}}}"
			textsize="4"
			text="Warning Time out"
		/>
		
		<label id="Label_Title" 
			posn="0. 0. .2"
			valign="center"
			halign="center"
			textfont="{{{G_FontChrono}}}"
			textcolor="{{{Color}}}"
			
		/>
	</frame>
	
	<script><!--
	#Include "MathLib" as ML
	#Include "TextLib" as TL
	
	#Const DebugName  "L_PressToRestart"
	
	main() 
	{
		declare Label_Title 				<=> (Page.MainFrame.GetFirstChild("Label_Title") 			as CMlLabel);
		declare Label_Explanation 			<=> (Page.MainFrame.GetFirstChild("Label_Explanation") 		as CMlLabel);
		
		declare netread Integer Net_TimeOutTimer for UI;
		
		Label_Title.Value = "00:00.0";
		
		while(True) 
		{
			yield;

			if(PageIsVisible) 
			{
				
				if(Net_TimeOutTimer >= 0) 
				{
					if(Net_TimeOutTimer <= 5000) 
					{
						Label_Explanation.Visible 	= True;
						Label_Title.Visible 		= True;
						declare Opacity 			= 0.5 + 0.5 * ML::Sin(Now*0.01);
						Label_Title.Opacity 		= Opacity;
						Label_Explanation.Opacity 	= Opacity;
						Label_Title.Value 			= TL::TimeToText(Net_TimeOutTimer, True);
					} 
					else 
					{
						Label_Title.Visible 		= False;
						Label_Explanation.Visible 	= False;
					}
				} 
				else 
				{
					Label_Title.Opacity 	= 1.0;
					Label_Title.Value 		= TL::TimeToText(0, True);
				}
			}
		}
	}
	--></script>
	""";
	
	return ML;
}



Void SetChallengeFrameVisibility(Boolean _Visibility)
{
	foreach(Player in AllPlayers)
	{
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) return;
		
		
		
		declare	netwrite Boolean Net_ChallengeFrameVisibility for UI;
		// log("SET CHALLENGE FRAME VISIBILITY: "^Net_ChallengeFrameVisibility);
		Net_ChallengeFrameVisibility = _Visibility;
		
	}
}

Void SetMapNameFrameVisibility(Boolean _Visibility)
{
	foreach(Player in AllPlayers)
	{
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) return;
		
		declare	netwrite Boolean Net_MapNameFrameVisibility for UI;
		
		Net_MapNameFrameVisibility = _Visibility;
		
	}
}

Void SetPlayerNickname(Text _PlayerNickname)
{
	foreach(Player in AllPlayers)
	{
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) return;
		
		declare	netwrite Text Net_PlayerNickname for UI;
		
		Net_PlayerNickname = _PlayerNickname;
	}
}

Void SetOpponentName(Text _OpponentName)
{
	foreach(Player in AllPlayers)
	{
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) return;
		
		declare	netwrite Text Net_OpponentName for UI;
		// log(Net_OpponentName);
		Net_OpponentName = _OpponentName;
	}
}

Void SetIsTrackRandom(Boolean _IsTrackRandom)  {
	foreach(Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		declare netwrite Boolean Net_IsTrackRandom for UI;
		Net_IsTrackRandom = _IsTrackRandom;
	}
}

Void SetOpponent(Integer _OpponentType, Integer[] _OpponentCheckpointsTime)
{
	foreach(Player in AllPlayers)
	{
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) return;
		
		declare	netwrite Integer 	Net_OpponentType 			for UI;
		declare	netwrite Integer[] 	Net_OpponentCheckpointsTime for UI;
		declare netwrite Integer	Net_OpponentUpdate			for UI;
		Net_OpponentType 				= _OpponentType;
		Net_OpponentCheckpointsTime 	= _OpponentCheckpointsTime;
		Net_OpponentUpdate				+= 1;
		// Net_BestTime					+= 1;
	}
}

Void SetVisibilityInGame(Boolean _Visible) 
{
	// Layers::SetVisibility(C_LAYERNAME_UI, _Visible);
}

Void SetVisibilityPadAlert(Boolean _Visible) 
{
	Layers::SetVisibility(C_LAYERNAME_PADS, _Visible);
}

Void SetVisibilityPressToRestart(Boolean _Visible) 
{
	Layers::SetVisibility(C_LAYERNAME_PRESS_TO_RESTART, _Visible);
}

Void SetVisibilityTimeOut(Boolean _Visible) 
{
	Layers::SetVisibility(C_LAYERNAME_TIMEOUT, _Visible);
}

Void SetVisiblityCampaignHelper(Boolean _Visible) {
	Layers::SetVisibility("CampaignHelper", _Visible);
}

Void CancelAnim321Go(CTmPlayer _Player)
{
	declare UI <=> UIManager.GetUI(_Player);
	if(UI == Null) return;
	
	declare netwrite Integer LibTMC_321Go_TriggerCancelAnim for UI;
	
	LibTMC_321Go_TriggerCancelAnim = Now;
}

Void CancelAnim321Go()
{
	foreach(Player in AllPlayers) CancelAnim321Go(Player);
}

Void PlayAnim321Go(CTmPlayer _Player)
{
	declare UI <=> UIManager.GetUI(_Player);
	if(UI == Null) return;
	
	declare netwrite Integer LibTMC_321Go_TriggerAnim for UI;
	
	LibTMC_321Go_TriggerAnim = Now;
}

Void PlayAnim321Go()
{
	foreach(Player in AllPlayers) PlayAnim321Go(Player);
}

Void SetNbLaps(Integer _NbLaps) {
	foreach(Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) return;
		declare netwrite Integer Net_NbLaps for UI;
		Net_NbLaps = _NbLaps;
	}
}

Void LoadVolumes() 
{
	declare Real VolumeVoices for Users[0];
	Volumes::LoadVolumeVoicesSetting(VolumeVoices);
}

Void IsTrackbuilder(Boolean _IsTrackbuilder) {
	declare UI <=> UIManager.GetUI(Players[0]);
	declare netwrite Net_LibUI_IsEditor for UI = False;
	Net_LibUI_IsEditor = _IsTrackbuilder;
}

Void Load(CTmMode _Mode, Text _ModeName, Integer _SpawnDuration, Boolean _CheatUniqueCamera, Boolean _DontCreateCheatCodeLayer) 
{
	Layers::DestroyAll();
	LoadVolumes();
	declare UI <=> UIManager.GetUI(Players[0]);
	declare netwrite Integer Net_SplitscreenMode for UI;
	Net_SplitscreenMode = UIManager.UI.count-1;

	////////////////////////////////////////
	// INITS       
	UIButtons::Load();                         
	G_Mode 					   <=> _Mode;
	G_ModeName 					= _ModeName;
	G_CheatUniqueCamera			= _CheatUniqueCamera;
	
	G_SpawnDuration				= _SpawnDuration;
	
	G_FontTitle 				= Font::GetFontName("Title");
	G_FontMain 					= Font::GetFontName("Main");
	G_FontMainSmall 			= Font::GetFontName("MainSmall");
	G_FontChrono 				= Font::GetFontName("Chrono");
	G_FontNumberBig				= Font::GetFontName("NumberBig");
	
	foreach(Player in AllPlayers) 
	{
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) return;
		declare netwrite Boolean 	Net_IndependantLaps 	for UI;
		declare	netwrite Integer 	Net_OpponentType 		for UI;
		Net_IndependantLaps = G_Mode.IndependantLaps;
		Net_OpponentType	= TMC_MEDAL_NONE;
	}
	
	////////////////////////////////////////
	// VISIBILITY                           
	/*
	if(G_ModeName != "OnlineTimeAttack"){
		UIManager.UIAll.ScoreTableVisibility 				= CUIConfig::EVisibility::ForcedHidden;
	} else {
	
	}
	*/
	
	UIManager.UIAll.ScoreTableVisibility 				= CUIConfig::EVisibility::Normal;
	UIManager.UIAll.ScoreTableOnlyManialink 			= True;
	UIManager.UIAll.OverlayHideMapInfo 					= True;
	UIManager.UIAll.OverlayHideOpponentsInfo			= True;
	UIManager.UIAll.OverlayHideChat 					= True;
	UIManager.UIAll.OverlayHideCheckPointList 			= True;
	UIManager.UIAll.OverlayHideRoundScores 				= True;
	UIManager.UIAll.OverlayHideCountdown 				= True;
	UIManager.UIAll.OverlayHideChrono 					= True;
	UIManager.UIAll.OverlayHideSpeedAndDist 			= True;
	UIManager.UIAll.OverlayHidePersonnalBestAndRank 	= True;
	UIManager.UIAll.OverlayHidePosition 				= True;
	UIManager.UIAll.OverlayHideCheckPointTime 			= True;
	UIManager.UIAll.AltMenuNoDefaultScores 				= True;
	UIManager.UIAll.OverlayHideMultilapInfos 			= True;
	UIManager.UIAll.OverlayHide321Go 					= True;
	UIManager.UIAll.OverlayHideBackground				= True;
	UIManager.UIAll.AlliesLabelsVisibility 				= CUIConfig::ELabelsVisibility::Never;
	
	if(G_ModeName != "HotSeat" && G_ModeName != "Solo") {
		UIManager.UIAll.OpposingTeamLabelsVisibility	= CUIConfig::ELabelsVisibility::WhenVisible;
	} else {
		UIManager.UIAll.OpposingTeamLabelsVisibility	= CUIConfig::ELabelsVisibility::Never;
	}
	
	
	foreach(Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		declare netwrite Text Net_ModeName for UI;
		declare netwrite Boolean Net_CheatUniqueCamera for UI;
		Net_ModeName = _ModeName;
		Net_CheatUniqueCamera = _CheatUniqueCamera;
	}
	
	////////////////////////////////////////
	// CREATE LAYERS                        
	if(_ModeName == "Rounds Splitscreen") 
	{
		declare Integer PlayerCount = Players.count;
		
		declare Real ScaleUI 		= SplitScreenLibManialinkCoef::GetScaleFromPlayerCount(PlayerCount);
		declare Real CoefPosUI 		= SplitScreenLibManialinkCoef::GetCoefPosXFromPlayerCount(PlayerCount);
		declare Real SpecialScaleUI	= SplitScreenLibManialinkCoef::GetSpecialScaleFromPlayerCount(PlayerCount);
		
		UIManager.UILayerDestroyAll();
		foreach(IndexPlayer => Player in Players) 
		{
			
			declare UI 					<=> UIManager.GetUI(Player);
			declare Race 				<=> UIManager.UILayerCreate();
			declare LastDeviceUsed 		<=> UIManager.UILayerCreate();
			
			declare netwrite Boolean BindingPad_IsSplitscreen for UI;
			BindingPad_IsSplitscreen = True;
			// log("HERE SET BINDINGPAD"^BindingPad_IsSplitscreen);
			Race		.ManialinkPage = Private_GetMLRace(ScaleUI, CoefPosUI, SpecialScaleUI);
			UI.UILayers.add(Race);
			
			LastDeviceUsed.ManialinkPage = UILastDeviceUsed::GetMl();
			UI.UILayers.add(LastDeviceUsed);
			
			if(!_DontCreateCheatCodeLayer)	// optim pour le mode split screen sans cheat, où on est très limite en termes de perfs
			{
				declare Cheat 		<=> UIManager.UILayerCreate();
				Cheat		.ManialinkPage = UICheatCode::Private_GetCheatCodeML(ScaleUI, CoefPosUI, SpecialScaleUI);
				UI.UILayers.add(Cheat);
			}
		}
		
		Layers::Destroy(C_LAYERNAME_321GO);
		Layers::Create(C_LAYERNAME_321GO, Private_GetML321Go());
		Layers::Attach(C_LAYERNAME_321GO);
	} 
	else 
	{
		Layers::Create("LastDeviceUsed", UILastDeviceUsed::GetMl());
		Layers::Attach("LastDeviceUsed");
		Layers::Create(C_LAYERNAME_UI, 	Private_GetMLRace(1., 1., 1.));
		Layers::Attach(C_LAYERNAME_UI);
		declare Integer EndTime = Now + 100;
		wait(Now >= EndTime);
		Layers::Create(C_LAYERNAME_UICHEATCODE, UICheatCode::Private_GetCheatCodeML(1., 1., 1.));
		Layers::Attach(C_LAYERNAME_UICHEATCODE);
		EndTime = Now + 100;
		wait(Now >= EndTime);
		Layers::Destroy(C_LAYERNAME_321GO);
		Layers::Create(C_LAYERNAME_321GO, Private_GetML321Go());
		Layers::Attach(C_LAYERNAME_321GO);
		EndTime = Now + 100;
		wait(Now >= EndTime);
		Layers::Create(C_LAYERNAME_PRESS_TO_RESTART, Private_GetPressToRestart());
		Layers::Attach(C_LAYERNAME_PRESS_TO_RESTART);
		EndTime = Now + 100;
		wait(Now >= EndTime);
		Layers::Create(C_LAYERNAME_TIMEOUT, Private_TimeOutTimer());
		Layers::Attach(C_LAYERNAME_TIMEOUT);
		// log("PUTAIN DE MODE NAME: "^_ModeName);
		// if(_ModeName == "Campaign_Solo" && _ModeName == "Campaign_Duo") {
			// log("CREATE LAYUER");
			
		// }
		Layers::Create("CampaignHelper", Private_CampaignHelper());
		Layers::Attach("CampaignHelper");
		SetVisiblityCampaignHelper(False);
		SetVisibilityTimeOut(False); 
	}
	
	declare Boolean IsChallengeFrameVisible = _ModeName == "Campaign_Solo" || _ModeName == "Campaign_Duo" || _ModeName == "Arcade" || _ModeName == "Championship";
	SetChallengeFrameVisibility(IsChallengeFrameVisible);
	SetMapNameFrameVisibility(_ModeName != "OnlineTimeAttack" && _ModeName != "Rounds Splitscreen");
	SetVisibilityPressToRestart(False);
	
	//////////////////////////////////
	// PAD IS MISSING LAYER           
	foreach(Player in Players) 
	{
		declare UI <=> UIManager.GetUI(Player);
		declare netwrite Text 	Net_MiscMode_MenuPopupTitle		for UI;
		declare netwrite Text 	Net_MiscMode_MenuPopupSubTitle	for UI;
		declare netwrite Text[] Net_MiscMode_MenuPopupInputs	for UI;
		
		declare IMGSelect 				= UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Select);
		declare TXTOk 					= _("OK");
		Net_MiscMode_MenuPopupInputs 	= [IMGSelect, TXTOk];
		Net_MiscMode_MenuPopupTitle 	= _("PAD MISSING!");
		Net_MiscMode_MenuPopupSubTitle 	= _("No pad detected.");
		
		declare Text PleaseConnectPadText = TL::Compose(_("Please connect at least one %1"), UIButtons::GetPadName());
		
		declare Vec3 LayerPos = <-85., 15., 30.>;
		declare Text[][] LayersContent;
		LayersContent.add(["Title", 	"Title", 		_("HOTSEAT MODE"), 						"2",	"", "Red ColorBg", "Net_MiscMode_MenuPopupTitle Net_MiscMode_MenuPopupSubTitle"]);
		LayersContent.add(["Space", 	"", 		  	"", 									"1",	"", "", ""]);
		// TODO HACK : ajouter "Dualshock 4 (r) wireless controller, ou XB1
		LayersContent.add(["Label", 	"Message", 		PleaseConnectPadText, 	"1",	"", "", ""]);
		LayersContent.add(["Input", 	"Input", 		"", 									"1",	"", "", "Net_MiscMode_MenuPopupInputs"]);
		
		UIPopupBuilder::CreateLayer(
			C_LAYERNAME_PADS,
			"PadMissing",
			LayerPos,
			LayersContent 
		);
		Layers::SetVisibility(C_LAYERNAME_PADS, False);
	}
}

Void UpdateTimeOutTimer(Integer _Timer) {
	foreach(Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		declare netwrite Integer Net_TimeOutTimer for UI;
		Net_TimeOutTimer = _Timer;
	}
}
