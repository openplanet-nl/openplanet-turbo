/*
###########
### DOC ###



USED IN :
Menu_Solo
UIHotSeat
Ladder
MiscModesLib
ScoresTable
SplitScreen
TMC_SymbiosePickup (Arcade)

GENERAL PARAMS :
- "IngameMenu"
- "PadMissing"
- "CustomStartButton"

ELEMENT TYPES LIST :
- Title
- Medal
- Input
- Color
- Switch
- Image
- Label
- Button
- Rank
- Custom

PARAMS :

- Title		: ---
- Medal 	: Anim
- Input 	: PlayerSelection
- Color 	: Dark
- Switch 	: L1 R1
- Image     : ---
- Label 	: Dark
- Button 	: ---
- Rank 		: Button NoRank SmallRank Medal Timediff Points
- Custom 	: Bg Bg2 Fg



UPDATE VALUES :

- Title 	: Net_Title Net_Subtitle 		{Text Text}
- Medal 	: Net_CurrentMedal 				{Integer}
- Input 	: Net_InputContent 				{Text[]} 		(exemples : [Text1, Img1, Text2, Img2] || [Text1, Img1])
- Color 	: Net_LabelValue Net_BgColor 	{Text Vec3} 	(exemples : [Text1, Img1, Text2, Img2] || [Text1, Img1])
- Switch 	: Net_LabelValue 				{Text}
- Image 	: Net_ImageUrl 					{Text}
- Label 	: Net_LabelValue 				{Text}
- Button 	: Net_LabelValue 				{Text}
- Rank 		: (Net_Ranks) Net_Names Net_Times Net_Medals Net_HighlightedRank Net_RanksColor {(Integer[]) Text[] Integer[] Integer[] Integer Vec3[]} (() = don't put if param is "NoRank")
- Custom 	: ---



FEEDBACK VALUES : 

- Title 	: ---
- Medal 	: ---
- Input 	: Net_{{{_LayerName}}}_PopupChoice 	Net_{{{_LayerName}}}_PopupUpdate 	{Boolean Integer}
- Color 	: ---
- Switch 	: Net_InputPlayerTrigger_PageDown 	Net_InputPlayerTrigger_PageUp		{Integer Integer}
- Image 	: ---
- Label 	: ---
- Button 	: ---
- Rank 		: ---
- Custom 	: ---



DETAILS (WIP) :

- Rank 
Fill Update string of the first Rank element with "Net_ValueRank Net_ValueName Net_ValueTime Net_ValueMyRank"
Use space to separate values. 
Net_ValueMyRank = The rank of the player needed to be highlighted in yellow
Add "Small" in Param string to get a smaller RankSize (Example for Ranks from 1 to 10 in local mode)
Add "Button" in Param string to transform Rank item in a clickable button
Add "Timediff" in Param string to show the timediff with Rank 1st on all the other Rank items
Add "Points" in Param string to use Points instead of Time on the right side
Add "NoRank" in Param string to hide the Rank count on the left (you need to remove the ValueRank from the Update string)

- Button
Fill Code string with instructions to be played when button is validated 

- Label, Title & Image
Fill Update string with Net_LabelValue or Net_ImageUrl to update the control from the mode.



MISC :

!!! PRIORITY IS NOW SET BY THE _Pos.Z !!!
*/



#Include "MathLib" 										as ML
#Include "TextLib" 										as TL
// #Include "Libs/Openplanet/Layers2.Script.txt" 				as Layers
#Include "Libs/Openplanet/TMConsole/Menu/MenuLayers.Script.txt"									as Layers
#Include "Libs/Openplanet/TMConsole/UIXmlBuilder.Script.txt"	as UIXmlBuilder
#Include "Libs/Openplanet/UIPadButtons.Script.txt"			as UIButtons
#Include "Libs/Openplanet/TMConsole/Colors.Script.txt" 		as Colors
#Include "Libs/Openplanet/TMConsole/Volumes.Script.txt" 		as Volumes
#Include "Libs/Openplanet/Manialink2.Script.txt" 			as Manialink
#Include "Libs/Openplanet/Arrays.Script.txt"					as Arrays

#Const Version					"2015-01-02"
#Const ScriptName				"TMConsole/Ingame/UI/UIPopupBuilder.Script.txt"

#Const SoundPath				"file://Media/Sounds/TMConsole/"

// SOUNDS

#Const SoundOk 					"event-on.wav"
#Const SoundCancel 				"event-off.wav"
#Const SoundValidate 			"event-validate.wav"
#Const SoundMove	   	 		"event-focus.wav"
#Const SoundShowLine			"event-menushowline.wav"
#Const SoundShowMenu			"event-menushow.wav"
#Const SoundShowPauseMenu		"event-menupause.wav"
#Const SoundHideMenu 			"menu-page-back.wav"

// IMAGES


#Const C_TYPE 	0
#Const C_NAME 	1
#Const C_TEXT 	2
#Const C_SIZE 	3
#Const C_CODE 	4
#Const C_PARAM 	5
#Const C_UPDATE 6

#Const C_BlinkSpeed 0.01

#Const C_RollingSpeed1	16.
#Const C_RollingSpeed2	24.
#Const C_RollingSpeed3	36.

declare Text[] 	G_LayerNames;
declare Text[] 	G_OverLayerNames;
declare Boolean G_PrevIsPauseMenuEnable;
declare Boolean G_PrevIsPadMissingMenuEnable;

Text GetFunctions()
{
	
	declare ML =
	"""
	Void StopVideoQuad(CMlQuad _Quad) 
	{
		_Quad.Hide();
		_Quad.Video_Rewind();
		_Quad.Video_IsPlaying = False;
	}

	
	
	Void FreezeVideoQuad(CMlQuad _Quad) 
	{
		_Quad.Show();
		_Quad.Video_Rewind();
		_Quad.Video_IsPlaying = False;
		_Quad.Video_IsLooping = False;	
	}



	Void PlayVideoQuad(CMlQuad _Quad, Integer _Duration) 
	{
		StopVideoQuad(_Quad);
		_Quad.Show();
		_Quad.Video_IsPlaying = True;
		_Quad.Video_IsLooping = False;	
		declare Integer ForQuad_Video_LastPlayedTrigger for _Quad;
		declare Integer ForQuad_Video_Duration 			for _Quad;
		ForQuad_Video_Duration 			= _Duration;
		ForQuad_Video_LastPlayedTrigger = Now;
	}



	Void PlayVideoQuad(CMlQuad _Quad, Integer _Duration, Text _VideoUrl) 
	{
		_Quad.ImageUrl = _VideoUrl;
		PlayVideoQuad(_Quad, _Duration);
	}
	
	
	
	Void CheckForStopVideo(CMlQuad[] _Quads)
	{
		foreach(Quad in _Quads)
		{
			declare Integer ForQuad_Video_LastPlayedTrigger 	for Quad;
			declare Integer ForQuad_Video_Duration 				for Quad;
			if(Now > ForQuad_Video_LastPlayedTrigger + ForQuad_Video_Duration)
			{
				StopVideoQuad(Quad);
			}
		}
	}
	
	Vec3 GetSeriesColorFromMapNumber(Integer _MapNumber)
	{
		if		(_MapNumber >= 1 	&& _MapNumber <= 40) 	return {{{Colors::GetDifficultyColor(1)}}};
		else if	(_MapNumber >= 41 	&& _MapNumber <= 80) 	return {{{Colors::GetDifficultyColor(2)}}};
		else if	(_MapNumber >= 81 	&& _MapNumber <= 120) 	return {{{Colors::GetDifficultyColor(3)}}};
		else if	(_MapNumber >= 121 	&& _MapNumber <= 160) 	return {{{Colors::GetDifficultyColor(4)}}};
		else if	(_MapNumber >= 161 	&& _MapNumber <= 200) 	return {{{Colors::GetDifficultyColor(5)}}};
		
		return  <0.5, 0.5, 0.5>;
	}
	
	Text GetSeriesDescriptionFromMapNumber(Integer _MapNumber)
	{
		// CANYON GRAND DRIFT RED SERIES, TRY HARDER
		declare Environment = "";
		switch(Map.CollectionName)
		{
			case "Canyon" 	: Environment = "CANYON GRAND DRIFT";
			case "Valley" 	: Environment = "VALLEY DOWN & DIRTY";
			case "Lagoon" 	: Environment = "LAGOON ROLLERCOASTER";
			case "Stadium" 	: Environment = "STADIUM INTERNATIONAL";
		}
		
		if		(_MapNumber >= 1 	&& _MapNumber <= 40) 	return Environment^" WHITE SERIES, NOT FOR NEWBS";
		else if	(_MapNumber >= 41 	&& _MapNumber <= 80) 	return Environment^" GREEN SERIES, EASY TO PICKUP";
		else if	(_MapNumber >= 81 	&& _MapNumber <= 120) 	return Environment^" BLUE SERIES, TRY HARD";
		else if	(_MapNumber >= 121 	&& _MapNumber <= 160) 	return Environment^" RED SERIES, TRY HARDER";
		else if	(_MapNumber >= 161 	&& _MapNumber <= 200) 	return Environment^" BLACK SERIES, HARD TO MASTER";
		
		return  "";
	}
	
	""";
	
	return ML;
}

Text[] GetMLScrolling(Text _Name, Text _FrameClip, Text _Label, Real _Speed, Boolean _DeclareFrame, Boolean _CustomFrameName)
{
	
	declare FrameClip = _FrameClip;
	declare Label = _Label;
	declare TriggerAnim = "TriggerAnim"^_Name;

	if(!_CustomFrameName)
	{
		FrameClip = _FrameClip^_Name;
		Label = _Label^_Name;
	}
		
		
		
	declare MLInit = "";
	if(_DeclareFrame)
		MLInit ^= """declare {{{FrameClip}}} <=> (Page.MainFrame.GetFirstChild("{{{FrameClip}}}") as CMlFrame);""";
	MLInit ^= 
	"""
	declare {{{Label}}} 	<=> (Page.MainFrame.GetFirstChild("{{{Label}}}")	 as CMlLabel);
	
	declare {{{TriggerAnim}}} 		= Now;
	declare PrevLabelValue{{{_Name}}} 	= ""; 
	declare Size{{{_Name}}} 			= -1.;
	declare Speed{{{_Name}}} 			= -1.;
	""";
	
	
	
	declare MLWhile =
	"""
	if(PrevLabelValue{{{_Name}}} != {{{Label}}}.Value)
	{
		PrevLabelValue{{{_Name}}} = {{{Label}}}.Value;
		declare SizeText 			= {{{Label}}}.ComputeWidth({{{Label}}}.Value);
		declare SizeClip 			= {{{FrameClip}}}.ClipWindowSize.X / 1.;
		Size{{{_Name}}} 			= SizeClip / 2. + SizeText / 2.;
		Speed{{{_Name}}} 			= Size{{{_Name}}} / {{{_Speed}}} * 1000.;
		{{{Label}}}.Size.X 	= SizeText * 1.5; 
	}
	
	if(Speed{{{_Name}}} > 0)
	{	
		declare CurTime = (Now - {{{TriggerAnim}}}) * 1.;
		
		{{{Label}}}.RelativePosition.X = AL::Ease("Linear", CurTime, Size{{{_Name}}}*1., -Size{{{_Name}}}*2., Speed{{{_Name}}});
		
		if(CurTime >= Speed{{{_Name}}}) 
			{{{TriggerAnim}}} = Now;
	}
	""";
	
	
	
	return [MLInit, MLWhile];
}

Text GetMLMapName(Text _LabelName)
{
	
	declare ML = 
	""" 
	declare Text 	MapName 	= TL::Trim(TL::StripFormatting(Map.MapName));
	declare Integer MapNumber 	= TL::ToInteger	(MapName);
	
	MapName = ""^MapNumber;
	if(MapNumber < 10)
		MapName = "0"^MapNumber;
		
	declare Vec3		MapNameColor 	= GetSeriesColorFromMapNumber(MapNumber);
	declare Real 		MapNameScale 	= 1.;
	
	if(MapName == "200" || MapNumber >= 200) MapNameScale = 0.82;
	
	{{{_LabelName}}}.Scale 		= MapNameScale;
	{{{_LabelName}}}.Value 		= MapName;
	{{{_LabelName}}}.TextColor 	= MapNameColor;
	""";
	
	return ML;
}

Text[] GetMLScrolling(Text _Name, Text _FrameClip, Text _Label, Real _Speed)
{
	return GetMLScrolling(_Name, _FrameClip, _Label, _Speed, True, False);
}

Vec2 GetSize(Boolean _AfterScale)
{
	return UIXmlBuilder::GetSize(_AfterScale);
}

Vec2 GetSize()
{
	return UIXmlBuilder::GetSize();
}

Void CreateLayer(Text _LayerName, Text _Params, Real _Scale, Vec3 _Pos, Text[][] _Elements, Text _Functions, Text _CodeBeforeWhile, Text _CodeWhenShown, Text _CodeInLoop) 
{
	G_LayerNames.add(_LayerName);
	
	declare Text MLText;

	UIButtons::Load();
	declare IMGSelect  			= UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Select);
	declare IMGJoin  			= UIButtons::GetImage(CManiaAppEvent::EMenuNavAction::Action1);
	
	declare ColorWhite 			= Colors::GetColor("White");
	declare ColorCyan2 			= Colors::GetColor("Cyan2");
	declare ColorYellow			= Colors::GetColor("Yellow");
	declare ColorOrange			= Colors::GetColor("Orange");

	declare SizeX 				= GetSize().X;
	declare SizeY 				= GetSize().Y;
	
	// PARAMS
	
	declare Boolean IsIngameMenu 		= TL::Find("IngameMenu", 		_Params, False, False);
	declare Boolean IsPadMissingMenu	= TL::Find("PadMissing", 		_Params, False, False);
	declare Boolean IsCustomStartButton = TL::Find("CustomStartButton", _Params, False, False);
	declare Boolean IsScoreTable		= TL::Find("ScoresTable", 		_Params, False, False);
	
	if(IsIngameMenu || IsPadMissingMenu) G_OverLayerNames.add(_LayerName);
	
	declare Priority = ML::FloorInteger(_Pos.Z);
	if(IsIngameMenu) Priority = 99999;
	
	declare Integer[] ButtonIndex;
	declare Integer[] RankIndex;
	declare Integer[] UpdatableIndex;
	declare Integer[] UpdatableLocalIndex;
	
	declare TheParamInput = _Elements[_Elements.count-1][C_PARAM];
	declare Boolean IsPlayerSelection = TL::Find("PlayerSelection", TheParamInput, True, True);
	declare Boolean IsSelector;
	declare Boolean IsL1;
	declare Boolean IsR1;
	declare Boolean IsL1R1;
	declare Text	MainColorName = "";
	declare Text 	MainSelectorName;
	declare Text 	MainSelectorCode;
	declare Text 	MainSelectorUpdate;
	declare Integer	MainSelectorMinVal;
	declare Integer	MainSelectorMaxVal;
	
	foreach(I => Element in _Elements)
	{
		declare TheName 		= Element[C_NAME];
		declare TheType 		= Element[C_TYPE];
		declare TheParam 		= Element[C_PARAM];
		declare TheUpdate 		= Element[C_UPDATE];
		declare TheSize 		= TL::ToInteger(Element[C_SIZE]);
		if(TheType == "Medal") 
			TheSize = 4;
		declare TheSizeY 		= SizeY * TheSize;
		
		if(TheUpdate != "" 
		&& TheType != "Title" 
		&& TheType != "Rank" 
		&& TheType != "Medal" 
		&& TheType != "Input" 
		&& TheType != "Selector" 
		&& TheType != "Gauge" 
		&& TheType != "Color") 
		{
			UpdatableIndex.add(I);
		}
			
		if(TL::Find("Local", TheParam, False, False))
		{
			UpdatableLocalIndex.add(I);
		}
			
		if(TheType == "Button" 
		|| TheType == "Rank" && TL::Find("Button", TheParam, True, True)) 
		{
			ButtonIndex.add(I);
		}
			
		if(TheType == "Rank") 
		{
			RankIndex.add(I);
			if(TL::Find("MainColor", TheParam, False, False) && MainColorName == "") 
			{
				MainColorName = TheName;
			}
		}
				
		if(TheType == "Selector") 
		{
			if(!IsSelector) 
			{
				declare RefVal 		= TL::Split(" ", TL::Trim(Element[C_TEXT]));
				MainSelectorName 	= TheName;
				MainSelectorCode 	= Element[C_CODE];
				MainSelectorUpdate 	= TheUpdate;
				if(MainSelectorUpdate == "") 
					log("[WARNING] : YOU HAVEN'T SPECIFIED ANY UPDATE VALUE FOR YOUR SELECTOR => CRASH");
				if(RefVal.existskey(0)) MainSelectorMinVal 	= TL::ToInteger(RefVal[0]);
				if(RefVal.existskey(1)) MainSelectorMaxVal 	= TL::ToInteger(RefVal[1]);
				if(MainSelectorMaxVal < MainSelectorMinVal) MainSelectorMaxVal = MainSelectorMinVal;
			} 
			IsSelector = True;
		}
			
		if(TheType == "Switch")
		{
			IsL1 	= TL::Find("L1", TheParam, True, True);
			IsR1 	= TL::Find("R1", TheParam, True, True);
			IsL1R1	= IsL1 && IsR1;
		}
		
	}
	
	if(IsSelector) ButtonIndex.clear();
	
	//-------------------------------------------------
	// BUILD MANIALINK ITEMS                           
	
	MLText ^= UIXmlBuilder::GetXml(_LayerName, _Elements, _Scale, _Pos);
	
	MLText ^= """ 
	
	<script ><!--
	{{{Manialink::GetIncludes()}}}
	{{{UIXmlBuilder::GetConst()}}}
	#Const DebugName  "L_{{{_LayerName}}}"
	
	#Const C_Device_Keyboard 	0
	#Const C_Device_Pad 		1
	
	declare Integer G_LastDeviceUsed;
	
	{{{UIXmlBuilder::GetMLFunctions()}}}
	{{{GetFunctions()}}}
	{{{Manialink::Load()}}}
	{{{Arrays::Inject(["Text"])}}}
	{{{_Functions}}}
	{{{UIButtons::GetMLFunctionPcButtons()}}}
	{{{Volumes::GetPlayVoiceSoundML()}}}
	
	main() 
	{
	
	
	
	//-------------------------------------------------
	// INIT CODE BEFORE MAIN LOOP                      
	
	{{{_CodeBeforeWhile}}} 
	
	""";
	
	declare Boolean HasButtons = ButtonIndex.count > 0;
	
	if(HasButtons)
	{
		MLText ^= """ 
			declare netwrite Integer[Text] Net_FocusedButtonForLayer for UI;
			
			declare Button_Back <=> (Page.MainFrame.GetFirstChild("Button_Back") as CMlQuad);
			declare M_NeedFocus = False;
			declare M_KeepFocus = False;
			declare M_DiscardFocusEvent = False;
		""";
	}
	
	
	
	//-------------------------------
	// UPDATE RANKS      
	
	declare HasRank = False;
	declare Text ValueRank; 
	declare Text ValueName; 
	declare Text ValueTime; 	
	declare Text ValueMyRank; 	
	declare Text ValueMedal; 	
	declare Text ValueRankColor; 	
	declare Boolean HasRankColors;
	
	if(RankIndex.count > 0)
	{
		declare FirstRankIndex 	= RankIndex[0];
		declare TheValues 		= TL::Split(" ", _Elements[FirstRankIndex][C_UPDATE]);
		declare TheParam 		= _Elements[FirstRankIndex][C_PARAM];
		declare	TheValuesCount 	= TheValues.count;
		
		declare IsNoRank = TL::Find("NoRank", TheParam, True, True);

		HasRankColors = TheValuesCount == 6;
		
		if(TheValuesCount == 4 && IsNoRank)
		{
			HasRank 	= True;
			
			ValueRank 	= "NO_RANK_VALUE_NEEDED";
			ValueName 	= TheValues[0];
			ValueTime 	= TheValues[1];
			ValueMedal 	= TheValues[2];
			ValueMyRank = TheValues[3];
			
			
			MLText ^= """
			declare  		Integer[] 	{{{ValueRank}}};
			declare netwrite Text[] 		{{{ValueName}}}		for UI;
			declare netwrite Integer[] 	{{{ValueTime}}} 	for UI;
			declare netwrite Integer[] 	{{{ValueMedal}}} 	for UI;
			declare netwrite Integer 	{{{ValueMyRank}}} 	for UI;
			// foreach(I => Value in {{{ValueTime}}}) {{{ValueRank}}}.add(I);
			""";
		}
		else 
		if(TheValuesCount >= 5)
		{
			HasRank 		= True;
			ValueRank 		= TheValues[0];
			ValueName 		= TheValues[1];
			ValueTime 		= TheValues[2];
			ValueMedal 		= TheValues[3];
			ValueMyRank 	= TheValues[4];
			
			
			MLText ^= """
			declare netwrite Integer[] 	{{{ValueRank}}} 	for UI;
			declare netwrite Text[] 		{{{ValueName}}}		for UI;
			declare netwrite Integer[] 	{{{ValueTime}}} 	for UI;
			declare	netwrite Integer[] 	{{{ValueMedal}}}	for UI;
			declare netwrite Integer 	{{{ValueMyRank}}} 	for UI;
			""";
			if(HasRankColors) 
			{
				ValueRankColor = TheValues[5];
				MLText ^= """declare netwrite Vec3[] 		{{{ValueRankColor}}} 	for UI;""";
			}
		}
		
		if(HasRank)
		{
			foreach(Index in RankIndex)
			{
				declare Element = _Elements[Index];
				declare TheName = Element[C_NAME];
				MLText ^= """ 
				declare Label_Rank_{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Label_Rank_{{{TheName}}}") 		as CMlLabel);
				declare Label_Name_{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Label_Name_{{{TheName}}}") 		as CMlLabel);
				declare Label_Time_{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Label_Time_{{{TheName}}}") 		as CMlLabel);
				declare Quad_Medal_{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Quad_Medal_{{{TheName}}}") 		as CMlQuad);
				declare Quad_RankColor_{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_RankColor_{{{TheName}}}") 	as CMlQuad);
				""";
			}
		}
	}
	
	foreach(I => Index in ButtonIndex)
	{
		declare Button 	= _Elements[Index];
		declare TheName = Button[C_NAME];
		declare TheCode = Button[C_CODE];
		
		if(I == 0) MLText ^= """ 
					declare CMlQuad[] 	Buttons;
					declare CMlQuad 	ButtonSelected <=> (Page.MainFrame.GetFirstChild("Button_{{{TheName}}}") as CMlQuad);
					declare CMlQuad 	PrevButtonSelected <=> ButtonSelected;
		""";
		
		MLText ^= """ 
					declare Button_{{{TheName}}} <=> (Page.MainFrame.GetFirstChild("Button_{{{TheName}}}") as CMlQuad);
					Buttons.add(Button_{{{TheName}}});
		""";
	}
	
	
	//-------------------------------------------------
	// DECLARE UPDATABLE NET READ VALUES + PREVIOUS    
	
	foreach(Index in UpdatableIndex)
	{
		declare Element 	= _Elements[Index];
		declare UpdateValue = Element[C_UPDATE];
		
		MLText ^= """ 
		declare netwrite  Text {{{UpdateValue}}} for UI;
		declare 		 Text Prev_{{{UpdateValue}}};
		""";
	}
	
	
	
	foreach(I => Element in _Elements)
	{
		declare TheName 	= Element[C_NAME];
		declare TheType 	= Element[C_TYPE];
		declare TheUpdate	= Element[C_UPDATE];
		declare TheParam 	= Element[C_PARAM];
		
		if(TheName != "" && TheType != "Space")
		{
			
			if(I == 0) 
			{
				MLText ^= """declare CMlFrame[] Frames;
				""";
			}
			
			declare ControlName = "Frame_" ^ TheName;
			MLText ^= """declare {{{ControlName}}} <=> (Page.MainFrame.GetFirstChild("{{{ControlName}}}") as CMlFrame); 
				Frames.add({{{ControlName}}});
			""";
			
			if(TheType == "Medal")
			{
				MLText ^= GetMLScrolling(TheName, "Frame_Clip", "Label_", C_RollingSpeed1)[0];
				MLText ^= """
				declare netwrite  Integer 	{{{TheUpdate}}} for UI;
				declare 		 Integer 	Prev_{{{TheUpdate}}} = -1;
				declare 		 Integer 	OldMedal = {{{TheUpdate}}};
				declare Frame_Medal{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Frame_Medal{{{TheName}}}") 		as CMlFrame); 
				declare Label_MapName{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Label_MapName{{{TheName}}}") 	as CMlLabel); 
				
				
				
				declare 		 Vec3[Integer] 		Frame_MedalsPositions_LibPopup;
				declare 		 CMlFrame[Integer] 	Frame_Medals_LibPopup;
				declare 		 CMlQuad[Integer] 	Quad_MedalsVideo_LibPopup;
				
				declare Frame_Bronze{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Frame_Bronze{{{TheName}}}") 		as CMlFrame); 
				declare Frame_Silver{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Frame_Silver{{{TheName}}}") 		as CMlFrame); 
				declare Frame_Gold{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Frame_Gold{{{TheName}}}") 		as CMlFrame); 
				declare Frame_Author{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Frame_Author{{{TheName}}}") 		as CMlFrame); 
				
				declare Quad_Bronze{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Quad_Bronze{{{TheName}}}") 		as CMlQuad); 
				declare Quad_Silver{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Quad_Silver{{{TheName}}}") 		as CMlQuad); 
				declare Quad_Gold{{{TheName}}} 			<=> (Page.MainFrame.GetFirstChild("Quad_Gold{{{TheName}}}") 		as CMlQuad); 
				declare Quad_Author{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Quad_Author{{{TheName}}}") 		as CMlQuad); 
				
				declare Quad_BronzeVideo{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_BronzeVideo{{{TheName}}}") 	as CMlQuad); 
				declare Quad_SilverVideo{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_SilverVideo{{{TheName}}}") 	as CMlQuad); 
				declare Quad_GoldVideo{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_GoldVideo{{{TheName}}}") 	as CMlQuad); 
				declare Quad_AuthorVideo{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_AuthorVideo{{{TheName}}}") 	as CMlQuad); 
				
				Frame_Medals_LibPopup[TMC_MEDAL_BRONZE] 	= Frame_Bronze{{{TheName}}};
				Frame_Medals_LibPopup[TMC_MEDAL_SILVER] 	= Frame_Silver{{{TheName}}};
				Frame_Medals_LibPopup[TMC_MEDAL_GOLD] 		= Frame_Gold{{{TheName}}};
				Frame_Medals_LibPopup[TMC_MEDAL_AUTHOR] 	= Frame_Author{{{TheName}}};
				
				Quad_MedalsVideo_LibPopup[TMC_MEDAL_BRONZE] = Quad_BronzeVideo{{{TheName}}};
				Quad_MedalsVideo_LibPopup[TMC_MEDAL_SILVER] = Quad_SilverVideo{{{TheName}}};
				Quad_MedalsVideo_LibPopup[TMC_MEDAL_GOLD] 	= Quad_GoldVideo{{{TheName}}};
				Quad_MedalsVideo_LibPopup[TMC_MEDAL_AUTHOR] = Quad_AuthorVideo{{{TheName}}};
				
				foreach(Quad in Quad_MedalsVideo_LibPopup) Quad.Blend = CMlQuad ::EBlendMode::Add;
				""";
			}
			else
			if(TheType == "Title")
			{
				declare UpdateValues = TL::Split(" ", TheUpdate);
				
				declare Text Title;
				declare Text Subtitle;
				
				if(UpdateValues.existskey(0)) 
				{
					Title = UpdateValues[0];
					MLText ^= """ 
					declare netwrite Text {{{Title}}} for UI;
					declare 	  	Text Prev_{{{Title}}};
					
					declare Label_Title{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Label_Title{{{TheName}}}") as CMlLabel);  
					""";
				} 
				if(UpdateValues.existskey(1)) 
				{
					Subtitle = UpdateValues[1];
					MLText ^= """ 
					declare netwrite Text {{{Subtitle}}} for UI;
					declare 	  	Text Prev_{{{Subtitle}}};
					
					""";
				}
				
				MLText ^= GetMLScrolling(TheName, "Frame_Subtitle", "Label_Subtitle", C_RollingSpeed1)[0];
			}
			else
			if(TheType == "Input")
			{
				MLText ^= """ 
				declare netwrite  Text[] {{{TheUpdate}}} for UI;
				
				// log({{{TheUpdate}}});
				
				declare Frame_Left{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Frame_Left{{{TheName}}}") 		as CMlFrame); 
				declare Quad_LeftLight{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_LeftLight{{{TheName}}}") 	as CMlQuad); 
				declare Quad_RightLight{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_RightLight{{{TheName}}}") 	as CMlQuad); 
				declare Quad_LeftInput{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_LeftInput{{{TheName}}}") 	as CMlQuad); 
				declare Quad_RightInput{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_RightInput{{{TheName}}}") 	as CMlQuad); 
				declare Label_RightInput{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Label_RightInput{{{TheName}}}") 	as CMlLabel); 
				declare Label_LeftInput{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Label_LeftInput{{{TheName}}}") 	as CMlLabel);
				
				""";
			
			}
			else
			if(TheType == "Selector")
			{
				if(MainSelectorUpdate != "")
				{
					MLText ^= """ 
					declare netwrite 	Integer {{{MainSelectorUpdate}}} for UI;
					declare  			Integer M_MainSelectorValue;
					{{{MainSelectorUpdate}}} = 0;
					M_MainSelectorValue = {{{MainSelectorMinVal}}};
					
					declare Quad_SelectorButton{{{MainSelectorName}}} 	<=> (Page.MainFrame.GetFirstChild("Quad_SelectorButton{{{MainSelectorName}}}") 	as CMlQuad); 
					declare Label_Selector0{{{MainSelectorName}}} 		<=> (Page.MainFrame.GetFirstChild("Label_Selector0{{{MainSelectorName}}}") 		as CMlLabel); 
					declare Label_Selector1{{{MainSelectorName}}} 		<=> (Page.MainFrame.GetFirstChild("Label_Selector1{{{MainSelectorName}}}") 		as CMlLabel); 
					declare Label_Selector2{{{MainSelectorName}}} 		<=> (Page.MainFrame.GetFirstChild("Label_Selector2{{{MainSelectorName}}}") 		as CMlLabel); 
					declare Label_Selectors{{{MainSelectorName}}}		 =  [Label_Selector0{{{MainSelectorName}}}, Label_Selector1{{{MainSelectorName}}}, Label_Selector2{{{MainSelectorName}}}];
					declare PosY_Offset{{{MainSelectorName}}}			 =  29.5;
					declare PosY_Selectors{{{MainSelectorName}}}		 =  [
						<Label_Selector0{{{MainSelectorName}}}.RelativePosition.X, Label_Selector0{{{MainSelectorName}}}.RelativePosition.Y + PosY_Offset{{{MainSelectorName}}},	Label_Selector0{{{MainSelectorName}}}.RelativePosition.Z>,
						<Label_Selector0{{{MainSelectorName}}}.RelativePosition.X, Label_Selector0{{{MainSelectorName}}}.RelativePosition.Y,										Label_Selector0{{{MainSelectorName}}}.RelativePosition.Z>,
						<Label_Selector0{{{MainSelectorName}}}.RelativePosition.X, Label_Selector0{{{MainSelectorName}}}.RelativePosition.Y - PosY_Offset{{{MainSelectorName}}},	Label_Selector0{{{MainSelectorName}}}.RelativePosition.Z>
					];
					
					Label_Selector0{{{MainSelectorName}}}.Value 	= ""^M_MainSelectorValue-1;
					Label_Selector1{{{MainSelectorName}}}.Value 	= ""^M_MainSelectorValue;
					Label_Selector2{{{MainSelectorName}}}.Value 	= ""^M_MainSelectorValue+1;
					foreach(I => Label in Label_Selectors{{{MainSelectorName}}})
					{
						Label.RelativePosition = PosY_Selectors{{{MainSelectorName}}}[I];
					}
					""";
				}
			
			}
			else
			if(TheType == "Color")
			{
				declare TheValues = TL::Split(" ", Element[C_UPDATE]);
				
				declare Text ColorText;
				declare Text Color;
				
				if(TheValues.existskey(0)) ColorText = TheValues[0];
				if(TheValues.existskey(1)) Color 	 = TheValues[1];
				
				if(ColorText != "")
				{
					MLText ^= """ 
					declare netwrite Text {{{ColorText}}} 	for UI;
					declare 	  	Text Prev_{{{ColorText}}};
					""";
				}
					
				if(Color != "")
				{
					MLText ^= """ 
					declare netwrite Vec3 {{{Color}}} 		for UI;
					declare 	  	Vec3 Prev_{{{Color}}};
					""";
				}
					
				MLText ^= """ 
				declare Label_{{{TheName}}} 	<=> (Page.MainFrame.GetFirstChild("Label_{{{TheName}}}") 	as CMlLabel); 
				declare Quad_{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Quad_{{{TheName}}}") 	as CMlQuad); 
				""";
			}
			else
			if(TheType == "Gauge")
			{
				declare TheValues = TL::Split(" ", Element[C_UPDATE]);
				
				declare Text GaugeValue;
				declare Text ColorText;
				declare Text Color;
				
				if(TheValues.existskey(0)) GaugeValue 	= TheValues[0];
				if(TheValues.existskey(1)) ColorText 	= TheValues[1];
				if(TheValues.existskey(2)) Color 	 	= TheValues[2];
				
				if(GaugeValue != "")
				{
					MLText ^= """ 
					declare netwrite Real {{{GaugeValue}}} 	for UI;
					declare 	  	Real Prev_{{{GaugeValue}}};
					""";
				}
					
				if(ColorText != "")
				{
					MLText ^= """ 
					declare netwrite Text {{{ColorText}}} 	for UI;
					declare 	  	Text Prev_{{{ColorText}}};
					""";
				}
					
				if(Color != "")
				{
					MLText ^= """ 
					declare netwrite Vec3 {{{Color}}} 		for UI;
					declare 	  	Vec3 Prev_{{{Color}}};
					""";
				}
					
				MLText ^= """ 
				declare Label_Ratio{{{TheName}}}	<=> (Page.MainFrame.GetFirstChild("Label_Ratio{{{TheName}}}") 	as CMlLabel); 
				declare Label_{{{TheName}}} 		<=> (Page.MainFrame.GetFirstChild("Label_{{{TheName}}}") 	as CMlLabel); 
				declare Quad_{{{TheName}}} 			<=> (Page.MainFrame.GetFirstChild("Quad_{{{TheName}}}") 	as CMlQuad); 
				""";
			
			}
			else
			if(TheType == "Label")
			{
				if(TL::Find("Roll", TheParam, True, True))
				{
					MLText ^= GetMLScrolling(TheName, "Frame_Clip", "Label_", C_RollingSpeed2)[0];
				}
			}
		}
	}
	
	if(IsPlayerSelection)
	{ 
		MLText ^= """ 
		declare netwrite Integer[] 	LibTMC_ScoresTable_PadsPlaying 		for UI;
		declare netwrite Boolean 	LibTMC_PlayerManager_GameStarted 	for UI;
		LibTMC_PlayerManager_GameStarted = False;
		""";
	}
	
	MLText ^= """ 
		declare Frame_Bg 				<=> (Page.MainFrame.GetFirstChild("Frame_Bg") 				as CMlFrame);
		declare Frame_{{{_LayerName}}} 	<=> (Page.MainFrame.GetFirstChild("Frame_{{{_LayerName}}}") as CMlFrame);
		
		declare netwrite Integer[] Net_HiddenItemsForLayer_{{{_LayerName}}} for UI;
		declare CMlFrame[] 	Frames_Elements;
		declare Integer[] 	Frames_ElementsSize;
	""";
	
	foreach(Element in _Elements)
	{
		declare TheName 	= Element[C_NAME];
		declare TheSize 	= Element[C_SIZE];
		MLText ^= """ 
		Frames_Elements		.add((Page.MainFrame.GetFirstChild("Frame_{{{TheName}}}") as CMlFrame));
		Frames_ElementsSize	.add({{{TheSize}}});
		""";
	}
	
	MLText ^= """ 		
			
			
			
		//-------------------------------
		// WHILE LOOP                    
		
		// Script for {{{_LayerName}}}
		
		declare netwrite Boolean Net_IsPauseMenuEnabled for UI;
		declare netwrite Boolean Net_IsPadMissingMenuEnable for UI;
		declare netwrite Integer Net_LibLastDeviceUsed_LastDeviceUsed for UI;
		declare Boolean M_NeedInit = True;
		declare Boolean M_PrevPageIsVisible;
		declare Boolean M_LaunchShowAnim;
		declare Boolean M_HasTwoChoices;
		declare Boolean M_PrevIsPauseMenuEnabled;
		declare Boolean M_PrevIsPadMissingMenuEnable;
		declare Integer PauseMenuTimer = 2000;
		
		while(True) 
		{
			yield;
			LibManialink_AnimLoop();
			// continue;
			// declare Integer InputDevice = GetInputDevice();
			// if(InputDevice != -1) {
				// G_LastDeviceUsed = InputDevice;
			// }
	""";		
	
	if(IsIngameMenu)
	{ 
		MLText ^= """ 
				if(PauseMenuTimer > 0) {
					PauseMenuTimer -= Period;
				} else {
					Net_IsPauseMenuEnabled = M_PrevPageIsVisible;
				}
		""";
	}
	
	if(HasButtons && !IsIngameMenu)
	{
		MLText ^= """
			if(M_NeedFocus)
			{
				M_NeedFocus = False;
				declare FocusedButtonIndex = 2;
				
				if(Net_FocusedButtonForLayer.existskey("{{{_LayerName}}}"))
				{
					FocusedButtonIndex = Net_FocusedButtonForLayer["{{{_LayerName}}}"];
				}
					
				if(Buttons.existskey(FocusedButtonIndex))
				{
					ButtonSelected <=> Buttons[FocusedButtonIndex];
					ButtonSelected.Focus();
				}
			}
			
			if(M_KeepFocus)
			{
				M_KeepFocus = False;
				M_DiscardFocusEvent = True;
				if(PrevButtonSelected != Null)
				{
					ButtonSelected <=> PrevButtonSelected;
					ButtonSelected.Focus();
				}
			}
		""";		
	}
	
	///////////////////////////////
	// ON LAYER VISIBILITY CHANGE
	if(IsIngameMenu) {
		MLText ^= """
			if(M_PrevPageIsVisible != PageIsVisible) {
				if(!M_PrevPageIsVisible) {
					PauseMenuTimer = 10;
				} else {
					PauseMenuTimer = 500;
				}
			}
		""";
	}
	
	MLText ^= """
			if(M_PrevPageIsVisible != PageIsVisible || M_LaunchShowAnim || M_NeedInit)
			{
				M_PrevPageIsVisible = PageIsVisible;
	""";
	
	
	MLText ^= """
				if(!M_PrevPageIsVisible)
				{
					Audio.PlaySoundEvent("{{{SoundPath^SoundHideMenu}}}", {{{Volumes::GetVolumedB("MenuHide")}}});
	""";		
	
	
	
	if(IsPlayerSelection)
	{ 
		MLText ^= """ 
				LibTMC_PlayerManager_GameStarted = False;
		""";
	}
		
	MLText ^= """ 			
				}
				else
				{
	""";
	
	MLText ^= """
					Frame_Bg.RelativePosition = <90., 0., Frame_Bg.RelativePosition.Z>;
		
					LibManialink_AnimStop			(Frame_Bg);
					LibManialink_SetTargetPosition	(Frame_Bg, <0. , 0., Frame_Bg.RelativePosition.Z>);
					LibManialink_PresetAnim			(Frame_Bg, 250, "BackOut");
	""";
	
	if(IsIngameMenu)
	{
		MLText ^= """
					Audio.PlaySoundEvent("{{{SoundPath^SoundShowPauseMenu}}}", {{{Volumes::GetVolumedB("MenuPauseShow")}}});
		""";
	}
	else
	{
		MLText ^= """
					Audio.PlaySoundEvent("{{{SoundPath^SoundShowMenu}}}", {{{Volumes::GetVolumedB("MenuShow")}}});
		""";
	
	}
	
	declare AnimPos = 0.;
	declare AnimCount = -1;
	declare TotalCount = -1;
	
	foreach(I => Element in _Elements)
	{
		declare TheName 	= Element[C_NAME];
		declare TheType 	= Element[C_TYPE];
		if(TheName != "" && TheType != "Space") TotalCount += 1;
	}
	
	
	
	// TO DO : USE array "Frames" in ML INSTEAD
	
	foreach(I => Element in _Elements)
	{
		declare TheName 	= Element[C_NAME];
		declare TheType 	= Element[C_TYPE];
		declare TheParam 	= Element[C_PARAM];
		declare TheSizeY 	= SizeY * TL::ToInteger(Element[C_SIZE]);
		
		if(TheName != "" && TheType != "Space")
		{
			declare ControlName = "Frame_" ^ TheName;
			declare OffsetX		= - (SizeX + 160 + _Pos.X);
			AnimCount += 1;
			MLText ^= """
			
					{{{ControlName}}}.RelativePosition = <{{{OffsetX}}}, {{{AnimPos}}}, {{{ControlName}}}.RelativePosition.Z>;
				
					LibManialink_AnimStop			({{{ControlName}}});
					LibManialink_SetTargetPosition	({{{ControlName}}}, <0. , {{{AnimPos}}}, {{{ControlName}}}.RelativePosition.Z>);
					LibManialink_PresetAnimInsert	({{{ControlName}}}, {{{100 * AnimCount}}}, 300, "BackOut");
					Audio.PlaySoundEvent("{{{SoundPath^SoundShowLine}}}", {{{Volumes::GetVolumedB("ShowLine")}}}, {{{100 * AnimCount}}});
			""";
			
			if(TheType == "Medal")
			{
				declare IsAnim 		= TL::Find("Anim", TheParam, True, True);
				declare UpdateValue = Element[C_UPDATE]; // NEW MEDAL
				if(IsAnim)
				{
					MLText ^= """
					// CheckForStopVideo(Quad_MedalsVideo_LibPopup);
					if(OldMedal != {{{UpdateValue}}})
					{	
						declare AnimCountMedal 	= 0;
						declare Delay 			= 0;
						declare SoundVoice 		= Audio.CreateSound(GetMedalVoiceUrl(0), {{{Volumes::GetVolumedB("VoiceMedal")}}}, 	False, False, False);
						foreach(I => Frame in Frame_Medals_LibPopup)
						{
							if(I < OldMedal && I >= {{{UpdateValue}}})
							{
								FreezeVideoQuad(Quad_MedalsVideo_LibPopup[I]);
								declare MedalSound 	= GetMedalSoundUrl(I);
								declare MedalVoice 	= GetMedalVoiceUrl(I);
								Delay 				= {{{100 * TotalCount}}} + 1000 * AnimCountMedal;
								declare Duration 	= 350;
								declare Pos 		= Frame.RelativePosition;
								Frame_MedalsPositions_LibPopup[I] = Pos;
								declare SizeX 		= Quad_Bronze{{{TheName}}}.Size.X;
								Frame.RelativePosition = <-160-SizeX/2., Pos.Y, Pos.Z>;
								
								LibManialink_SetTargetPosition	(Frame, Pos);
								LibManialink_PresetAnimInsert	(Frame, Delay, Duration, "SineOut");
								
								if(MedalSound != "" && MedalVoice != "")
								{
									SoundVoice = Audio.CreateSound(MedalVoice, {{{Volumes::GetVolumedB("VoiceMedal")}}}, 	False, False, False);
									SoundVoice.PanRadiusLfe = {{{Volumes::GetPanRadiusLfe("MenuUISpreadLarge")}}};
									Audio.PlaySoundEvent(MedalSound, {{{Volumes::GetVolumedB("ShowMedal")}}}, Delay);
								}
								
								AnimCountMedal += 1;
							}
							else
							{
								StopVideoQuad(Quad_MedalsVideo_LibPopup[I]);
							}
						}
						SoundVoice.Stop();
						PlayVoiceSound(SoundVoice, {{{Volumes::GetVolumedB("VoiceMedal")}}}, Delay+750);
						OldMedal = {{{UpdateValue}}};
					}
					""";
				}
			}
		}
		
		AnimPos -= TheSizeY;
	}
	
	MLText ^= """ 			
				}
	""";
	
	
	
	if(IsPadMissingMenu)
	{ 
		MLText ^= """ 
				Net_IsPadMissingMenuEnable = M_PrevPageIsVisible;
		""";
	}
	
	if(HasButtons)
	{
		// declare FirstButtonIndex = ButtonIndex[0];
		// declare FirstButtonName = "Button_" ^ _Elements[FirstButtonIndex][C_NAME];
		MLText ^= """ 
				if(!M_LaunchShowAnim)
				{
					EnableMenuNavigation(M_PrevPageIsVisible, True, Button_Back, {{{Priority}}});
					M_NeedFocus = True;
				}
		""";
	} 
	else 
	{
		MLText ^= """ 
				EnableMenuNavigation(M_PrevPageIsVisible, False, Null, {{{Priority}}});
		""";
	
	}
	
	MLText ^= """ 
				M_NeedInit 				= False;
				M_LaunchShowAnim 		= False;
				{{{_CodeWhenShown}}}
			}		
			if(!M_PrevPageIsVisible) continue;
	""";		
	
	if(!(IsIngameMenu || IsPadMissingMenu))
	{
		MLText ^= """ 		
			declare IsLayerEnable = M_PrevPageIsVisible && !(Net_IsPauseMenuEnabled || Net_IsPadMissingMenuEnable);
			if(M_PrevIsPauseMenuEnabled != Net_IsPauseMenuEnabled || M_PrevIsPadMissingMenuEnable != Net_IsPadMissingMenuEnable)
			{
					
				Frame_{{{_LayerName}}}.Visible  = IsLayerEnable;
				M_PrevIsPauseMenuEnabled 		= Net_IsPauseMenuEnabled;
				M_PrevIsPadMissingMenuEnable 	= Net_IsPadMissingMenuEnable;
				M_LaunchShowAnim 				= IsLayerEnable;
		""";	
				
		if(HasButtons)
		{
			MLText ^= """ 
				if(!IsLayerEnable)
					PrevButtonSelected <=> ButtonSelected;
				else
					M_KeepFocus = True;
				EnableMenuNavigation(IsLayerEnable, True, Button_Back, {{{Priority}}});
			""";
		} 
		else 
		{
			MLText ^= """ 
				EnableMenuNavigation(IsLayerEnable, False, Null, {{{Priority}}});
			""";
		
		}
		
		MLText ^= """
			}
		""";
	}	
	
	
	
	MLText ^= """
	
			
			
			//--------------------------------
			// EVENTS LOOP                    
			
			foreach (Event in PendingEvents) 
			{
				// log(Event.MenuNavAction);
				if (Event.Type == CMlEvent::Type::MouseClick) 
				{
	""";
	
	if(HasButtons)
	{
		MLText ^= """ 
					if (Event.Control == Button_Back) 
					{
						declare netwrite Boolean 	Net_{{{_LayerName}}}_PopupChoice for UI;
						declare netwrite Integer 	Net_{{{_LayerName}}}_PopupUpdate for UI;
						Net_{{{_LayerName}}}_PopupChoice = False;
						Net_{{{_LayerName}}}_PopupUpdate = Now;
		""";
		if(IsIngameMenu) MLText ^= """CloseInGameMenu(CMlScriptIngame::EInGameMenuResult::Resume);""";
		MLText ^= """ 
					}
					else
					{
						if(DebugName != "L_TempQuestionThreeOptions") {
							Audio.PlaySoundEvent("{{{SoundPath^SoundValidate}}}", {{{Volumes::GetVolumedB("MenuClick")}}});	
						}
					}
		""";
		
	}
	
	foreach(Index in ButtonIndex)
	{
		declare Button 	= _Elements[Index];
		declare TheName = Button[C_NAME];
		declare TheCode = Button[C_CODE];
		MLText ^= """ 
					if (Event.Control == Button_{{{TheName}}}) 
					{
						{{{TheCode}}}
					}
		""";
	}
	
	MLText ^= """ 
				} 
				else 
				if(Event.Type == CMlEvent::Type::MouseOver) 
				{
					Audio.PlaySoundEvent("{{{SoundPath^SoundMove}}}", {{{Volumes::GetVolumedB("MenuMove")}}});
	""";
	
	if(HasButtons)
	{
		MLText ^= """ 
					if(M_DiscardFocusEvent)
						M_DiscardFocusEvent = False;
					else
					{
						foreach(Button in Buttons)
						{
							if(Button.ControlId == Event.Control.ControlId)
							{
								ButtonSelected <=> Button;
								break;
							}
						}
					}
		""";
	
	}
	
	MLText ^= """
				}
				else 
				if(Event.Type == CMlEvent::Type::MenuNavigation) 
				{
	""";
	
	if(IsL1R1 || IsL1 || IsR1)
	{
		declare L1Text = """
					if(Event.MenuNavAction == CMlEvent::EMenuNavAction::PageDown)
					{
						declare netwrite Integer Net_InputPlayerTrigger_PageDown for UI;
						Net_InputPlayerTrigger_PageDown = Now;
						M_LaunchShowAnim = True;
					}
		""";
		
		declare R1Text = """ 
					if(Event.MenuNavAction == CMlEvent::EMenuNavAction::PageUp)
					{
						declare netwrite Integer Net_InputPlayerTrigger_PageUp for UI;
						Net_InputPlayerTrigger_PageUp = Now;
						M_LaunchShowAnim = True;
					}
		""";
		
		if		(IsL1R1)	MLText ^= L1Text ^ "else" ^ R1Text;
		else if	(IsL1) 		MLText ^= L1Text;
		else if	(IsR1)		MLText ^= R1Text;
		
	}
	
	if(!HasButtons && !IsPlayerSelection && !IsSelector)
	{
		MLText ^= """  
					declare netwrite Text Net_{{{_LayerName}}}_ButtonPressed for UI;
					Net_{{{_LayerName}}}_ButtonPressed = ""^Event.MenuNavAction;
					
					if(Event.MenuNavAction == CMlEvent::EMenuNavAction::Select || Event.MenuNavAction == CMlEvent::EMenuNavAction::Cancel)
					{
						declare netwrite Boolean 	Net_{{{_LayerName}}}_PopupChoice for UI;
						declare netwrite Integer 	Net_{{{_LayerName}}}_PopupUpdate for UI;
						declare Boolean	IsPopupValidationFordidden		 for UI;
						
						switch(Event.MenuNavAction) 
						{
							case CMlEvent::EMenuNavAction::Select  : Net_{{{_LayerName}}}_PopupChoice = True;
							case CMlEvent::EMenuNavAction::Cancel  : Net_{{{_LayerName}}}_PopupChoice = False;
						}
						
						if(M_HasTwoChoices || Event.MenuNavAction == CMlEvent::EMenuNavAction::Select)
						{
							if(!IsPopupValidationFordidden) {
								Net_{{{_LayerName}}}_PopupUpdate = Now;
							}
						}
					}
		""";
	}
	else
	if(IsSelector)
	{
		MLText ^= """  
					if(Event.MenuNavAction == CMlEvent::EMenuNavAction::Up || Event.MenuNavAction == CMlEvent::EMenuNavAction::Down)
					{
						declare CMlLabel[] Label_SelectorsCopy{{{MainSelectorName}}};
						declare Index		= 0;
						declare Multiplier	= 1.;
						switch(Event.MenuNavAction) 
						{
							case CMlEvent::EMenuNavAction::Up  	: 
							{
								M_MainSelectorValue -= 1;
								Label_SelectorsCopy{{{MainSelectorName}}} = [
									Label_Selectors{{{MainSelectorName}}}[2],
									Label_Selectors{{{MainSelectorName}}}[0],
									Label_Selectors{{{MainSelectorName}}}[1]
								];
								
							}
							case CMlEvent::EMenuNavAction::Down : 
							{
								M_MainSelectorValue += 1;
								Label_SelectorsCopy{{{MainSelectorName}}} = [
									Label_Selectors{{{MainSelectorName}}}[1],
									Label_Selectors{{{MainSelectorName}}}[2],
									Label_Selectors{{{MainSelectorName}}}[0]
								];
								Index		= 2;
								Multiplier	= -1.;
							}
						}
						
						if(M_MainSelectorValue < {{{MainSelectorMinVal}}}) M_MainSelectorValue = {{{MainSelectorMaxVal}}};
						if(M_MainSelectorValue > {{{MainSelectorMaxVal}}}) M_MainSelectorValue = {{{MainSelectorMinVal}}};
						
						Label_Selectors{{{MainSelectorName}}} = Label_SelectorsCopy{{{MainSelectorName}}};
						foreach(I => Label in Label_Selectors{{{MainSelectorName}}})
						{
							if(I == Index) Label.RelativePosition.Y = PosY_Selectors{{{MainSelectorName}}}[Index].Y + Multiplier*PosY_Offset{{{MainSelectorName}}};
							LibManialink_AnimStop			(Label);
							LibManialink_SetTargetPosition	(Label, PosY_Selectors{{{MainSelectorName}}}[I]);
							LibManialink_PresetAnim			(Label, 225, "BackOut");
						}
					
						Label_Selectors{{{MainSelectorName}}}[0].Value 	= ""^M_MainSelectorValue-1;
						Label_Selectors{{{MainSelectorName}}}[1].Value 	= ""^M_MainSelectorValue;
						Label_Selectors{{{MainSelectorName}}}[2].Value 	= ""^M_MainSelectorValue+1;
					}
					else
					if(Event.MenuNavAction == CMlEvent::EMenuNavAction::Select)
					{
						{{{MainSelectorUpdate}}} = M_MainSelectorValue;
						{{{MainSelectorCode}}}
					}
		""";
	}
	
	if(!IsIngameMenu && !IsCustomStartButton)
	{
		MLText ^= """  
					if(Event.MenuNavAction == CMlEvent::EMenuNavAction::AppMenu)
					{
						ShowInGameMenu();
					}
		""";
	}
		
	MLText ^= """
				}
			}
	""";
		
	
	if(!HasButtons && IsPlayerSelection)
	{
		declare TextWaiting = _("Press to join");
		declare TextReady 	= _("let's go !");
		MLText ^= """ 
			if(IsLayerEnable)
			{
				declare netwrite Boolean 	Net_{{{_LayerName}}}_PopupChoice 	for UI;
				declare netwrite Integer 	Net_{{{_LayerName}}}_PopupUpdate 	for UI;
				foreach(PadIndex => Pad in Input.Pads) 
				{
					if(Input.Pads.existskey(Pad)) 
					{
						foreach(Button in Input.Pads[PadIndex].ButtonEvents) 
						{
							switch(Button) 
							{
								case CInputScriptPad::EButton::X :  
								{
									if(!LibTMC_ScoresTable_PadsPlaying	.exists(PadIndex) && LibTMC_ScoresTable_PadsPlaying.count < 2) 
									{
										LibTMC_ScoresTable_PadsPlaying	.add(PadIndex);
										Audio.PlaySoundEvent("{{{SoundPath^SoundOk}}}", {{{Volumes::GetVolumedB("JoinGame")}}});
									}
								}
								case CInputScriptPad::EButton::A :  
								{
									if(LibTMC_ScoresTable_PadsPlaying.count >= 1 && LibTMC_ScoresTable_PadsPlaying.exists(PadIndex)) 
									{
										LibTMC_PlayerManager_GameStarted 	= True;
										LibTMC_ScoresTable_PadsPlaying 		= LibTMC_ScoresTable_PadsPlaying.sort();
										Net_{{{_LayerName}}}_PopupChoice 	= True;
										Net_{{{_LayerName}}}_PopupUpdate 	= Now;
										EnableMenuNavigation(False, False, Null, 0);
										Audio.PlaySoundEvent("{{{SoundPath^SoundValidate}}}", {{{Volumes::GetVolumedB("MenuClickLow")}}});	
										
									}
								}
								
								case CInputScriptPad::EButton::B :  
								{
									if(LibTMC_ScoresTable_PadsPlaying	.exists(PadIndex))  
									{
										LibTMC_ScoresTable_PadsPlaying	.remove(PadIndex);
										Audio.PlaySoundEvent("{{{SoundPath^SoundCancel}}}", {{{Volumes::GetVolumedB("CancelJoinGame")}}});
									}
								}
							}
						}
					}
				}	
			}
		""";
	}		
	
	
	
	MLText ^= """ 
	if(Net_HiddenItemsForLayer_{{{_LayerName}}}.count > 0)
	{
		declare RowCount = 0.;
		declare PosY = 0.;
		foreach(I => Frame in Frames_Elements)
		{
			Frame.RelativePosition.Y = -PosY;
			if(Net_HiddenItemsForLayer_{{{_LayerName}}}.exists(I))
			{
				Frame.Visible = False;
			}
			else
			{
				Frame.Visible = True;
				PosY += Frames_ElementsSize[I]*{{{UIXmlBuilder::GetSize().Y}}};
				RowCount += Frames_ElementsSize[I];
			}
		}	
		
		foreach(I => Control in Frame_Bg.Controls)
		{
			if(I > RowCount-1) Control.Visible = False;
		}
	}
	
	// Frames_ElementsSize
	
	// declare netwrite Integer[] Net_GreyedItemsForLayer_{{{_LayerName}}};
	
		// if(Net_GreyedItemsForLayer_{{{_LayerName}}}.exists(I))
		// {
			// (Frame.GetFirstChild("Quad_Greyed") as CMlQuad).Visible = True;
		// }
	""";
	
	
	
	//-------------------------------
	// UPDATE BUTTONS RED BLINKING      
	if(IsPlayerSelection || HasButtons || IsSelector)
	{
		MLText ^= """ 
			declare ButtonSelectedSinVar 	= ML::Sin(Now * {{{C_BlinkSpeed}}}) * 0.5 + 0.5;
			declare ButtonSelectedOpacity 	= 0.0 + ButtonSelectedSinVar * 1.;
		""";
	
		if(IsSelector)
		{
			MLText ^= """ 
				Quad_SelectorButton{{{MainSelectorName}}}.Opacity = ButtonSelectedOpacity;
			""";
		}
	
		if(HasButtons)
		{
			MLText ^= """ 
			foreach(Button in Buttons)
			{
				Button.Opacity = 0.;
			}
			ButtonSelected.Opacity = ButtonSelectedOpacity;
			""";
		}
	}	
		
		
		
	//-------------------------------
	// UPDATE RANKS      
	if(HasRank)
	{
		foreach(I => Index in RankIndex)
		{
			declare Element		= _Elements[Index];
			declare TheName 	= Element[C_NAME];
			declare TheParam 	= Element[C_PARAM];
			if(HasRankColors)
			{
				MLText ^= """ 
				if({{{ValueRankColor}}}.existskey({{{I}}}))
				{
					Quad_RankColor_{{{TheName}}}.Visible = True;
					Quad_RankColor_{{{TheName}}}.BgColor = {{{ValueRankColor}}}[{{{I}}}];
				}
				""";
			}
			
			declare ML_SetColorYellow 	= """{{{TheName}}}.TextColor = {{{ColorYellow}}};""";
			declare ML_SetColorWhite 	= """{{{TheName}}}.TextColor = {{{ColorWhite}}};""";
			MLText ^= """ 
			if({{{ValueName}}}.existskey({{{I}}}) && {{{ValueTime}}}.existskey({{{I}}})) 
			{
				if({{{ValueMedal}}}.existskey({{{I}}})) 
				{
					declare MedalUrlSmall 	= GetMedalUrlSmall({{{ValueMedal}}}[{{{I}}}]);
					declare HasMedal 		= MedalUrlSmall != "";
					Quad_Medal_{{{TheName}}}.Visible = HasMedal;
					if(HasMedal) Quad_Medal_{{{TheName}}}.ImageUrl = MedalUrlSmall;
				}
				
				if({{{ValueRank}}}.existskey({{{I}}})) 
				{
					declare Rank = {{{ValueRank}}}[{{{I}}}];
					if({{{ValueMyRank}}} == Rank)
					{
						Label_Rank_{{{ML_SetColorYellow}}}
						Label_Name_{{{ML_SetColorYellow}}}
						Label_Time_{{{ML_SetColorYellow}}}
					}
					else
					{
						Label_Rank_{{{ML_SetColorWhite}}}
						Label_Name_{{{ML_SetColorWhite}}}
						Label_Time_{{{ML_SetColorWhite}}}
					}
					Label_Rank_{{{TheName}}}.Value = TL::ToText(Rank);
				} 
				else
				{
					Label_Rank_{{{TheName}}}.Value = "-";
					Label_Rank_{{{ML_SetColorWhite}}}
					Label_Name_{{{ML_SetColorWhite}}}
					Label_Time_{{{ML_SetColorWhite}}}
				}
				Label_Name_{{{TheName}}}.Value = TL::ToUpperCase({{{ValueName}}}[{{{I}}}]);
			""";
			
			declare IsPoints = TL::Find("Points", TheParam, True, True);
			declare IsScore = TL::Find("Score", TheParam, True, True);
			if(IsPoints)
			{
				MLText ^= """Label_Time_{{{TheName}}}.Value = {{{ValueTime}}}[{{{I}}}] ^ "pts" ;""";
			}
			else
			if(IsScore)
			{
				MLText ^= """Label_Time_{{{TheName}}}.Value = ""^{{{ValueTime}}}[{{{I}}}];""";
			}
			else
			{
				declare IsTimediff 	= TL::Find("Timediff", TheParam, True, True);
				declare IsBlink 	= TL::Find("Blink", TheParam, True, True);
				declare IsColor 	= IsTimediff && TL::Find("Color", TheParam, True, True);
				declare ML_SetTime 	= """Label_Time_{{{TheName}}}.Value = TL::TimeToText({{{ValueTime}}}[{{{I}}}], True);""";
				if(IsBlink)
				{
					MLText ^= """
						Label_Time_{{{TheName}}}.Opacity = 0.5 + 0.5 * ML::Sin(Now * {{{C_BlinkSpeed}}}); 
						""";
				
				}
				if(IsTimediff && I > 0)
				{
					MLText ^= """
						if({{{ValueTime}}}[0] > 0)
						{
							declare Timediff = {{{ValueTime}}}[{{{I}}}] - {{{ValueTime}}}[0];
							declare TimediffToText = TL::TimeToText(Timediff, True); 
							if(Timediff > 0) TimediffToText = "+"^TimediffToText; 
							Label_Time_{{{TheName}}}.Value = TimediffToText; 
						""";
					if(IsColor) 
					{
						declare ML_SetColorLate 	= """{{{TheName}}}.TextColor = {{{ColorOrange}}};""";
						declare ML_SetColorAhead 	= """{{{TheName}}}.TextColor = {{{ColorCyan2}}};""";
						MLText ^= """ 
							if(Timediff > 0) 
							{
								Label_Rank_{{{ML_SetColorLate}}}
								Label_Name_{{{ML_SetColorLate}}}
								Label_Time_{{{ML_SetColorLate}}}
							} 
							else
							{
								Label_Rank_{{{ML_SetColorAhead}}}
								Label_Name_{{{ML_SetColorAhead}}}
								Label_Time_{{{ML_SetColorAhead}}}
							}
						""";
					} 
					MLText ^= """
						}
						else
						{
							{{{ML_SetTime}}}
						}
					""";
				}
				else 														
				{
					MLText ^= ML_SetTime;
				}
			}
			
			MLText ^= """ 
				if({{{ValueTime}}}[{{{I}}}] <= 0) Label_Time_{{{TheName}}}.Value = "--:--.--";
			}
			""";
			
				
			
			
		}
	}
	
	
	//---------------------------------------------------
	// UPDATE VALUES IN netwrite (LABEL, IMAGES, BUTTONS) 
	
	foreach(Index in UpdatableIndex)
	{
		declare Element 	= _Elements[Index];
		declare TheType 	= Element[C_TYPE];
		declare TheName 	= Element[C_NAME];
		declare UpdateValue = Element[C_UPDATE];
		// log("THIS IS THE UPDATE: "^UpdateValue);
		if(TheType == "Label" && MainColorName != "")
		{
			MLText ^= """
			declare Label_{{{TheName}}} <=> (Page.MainFrame.GetFirstChild("Label_{{{TheName}}}") as CMlLabel);
			Label_{{{TheName}}}.TextColor = Label_Rank_{{{MainColorName}}}.TextColor;
			""";
		}
		
		MLText ^= """ 
			// log(Now^">CHANGE VALUE: "^{{{UpdateValue}}});
			if(Prev_{{{UpdateValue}}} != {{{UpdateValue}}})
			{
				// log("CHANGE VALUE: "^{{{UpdateValue}}});
				Prev_{{{UpdateValue}}} = {{{UpdateValue}}};
		""";	
		if(TheType == "Label" || TheType == "Title" || TheType == "Switch" || TheType == "Button")
		{
			MLText ^= """ 
				declare Label_{{{TheName}}} <=> (Page.MainFrame.GetFirstChild("Label_{{{TheName}}}") as CMlLabel);
				Label_{{{TheName}}}.Value = {{{UpdateValue}}};
			""";
		}
		else
		if(TheType == "Image")
		{
			MLText ^= """ 
				declare Quad_{{{TheName}}} <=> (Page.MainFrame.GetFirstChild("Quad_{{{TheName}}}") as CMlQuad);
				Quad_{{{TheName}}}.ImageUrl = TL::ToUpperCase({{{UpdateValue}}});
			""";
		}
		
		MLText ^= """ 
			}
		""";
	}
	
	//-----------------------------------
	// UPDATE VALUES IN netwrite (OTHERS) 
	
	foreach(Element in _Elements)
	{
		declare TheName 	= Element[C_NAME];
		declare TheType 	= Element[C_TYPE];
		declare TheParam 	= Element[C_PARAM];
	
		if(TheType == "Label" && TL::Find("Roll", TheParam, True, True))
		{
			MLText ^= GetMLScrolling(TheName, "Frame_Clip", "Label_", C_RollingSpeed2)[1];
		}
		else
		if(TheName != "" && TheType != "Space")
		{
			declare UpdateValue = Element[C_UPDATE];
			if(TheType == "Medal")
			{
				MLText ^= GetMLScrolling(TheName, "Frame_Clip", "Label_", C_RollingSpeed1)[1];
				MLText ^= """ 
				if(Prev_{{{UpdateValue}}} != {{{UpdateValue}}})
				{
					Prev_{{{UpdateValue}}} = {{{UpdateValue}}};
					{{{GetMLMapName("Label_MapName"^TheName)}}}
					Label_{{{TheName}}}.Value = GetSeriesDescriptionFromMapNumber(MapNumber);
					declare IsThereUpdateValue = {{{UpdateValue}}} != -1;
					Frame_Bronze{{{TheName}}}.Visible = {{{UpdateValue}}} <= TMC_MEDAL_BRONZE 	&& IsThereUpdateValue;
					Frame_Silver{{{TheName}}}.Visible = {{{UpdateValue}}} <= TMC_MEDAL_SILVER 	&& IsThereUpdateValue;
					Frame_Gold{{{TheName}}}	 .Visible = {{{UpdateValue}}} <= TMC_MEDAL_GOLD 	&& IsThereUpdateValue;
					Frame_Author{{{TheName}}}.Visible = {{{UpdateValue}}} <= TMC_MEDAL_AUTHOR 	&& IsThereUpdateValue;
				}
			
				if(Frame_MedalsPositions_LibPopup.count > 0)
				{
					foreach(I => Frame in Frame_Medals_LibPopup)
					{
						if(Frame_MedalsPositions_LibPopup.existskey(I) && Frame.RelativePosition.X >= Frame_MedalsPositions_LibPopup[I].X - 0.5)
						{
							PlayVideoQuad(Quad_MedalsVideo_LibPopup[I], 2000);
							Frame_MedalsPositions_LibPopup.removekey(I);
						}
					}
				}
				""";
			}
			else
			if(TheType == "Title")
			{
				declare TheValues = TL::Split(" ", Element[C_UPDATE]);
				
				declare Text Title;
				declare Text Subtitle;
				
				if(TheValues.existskey(0)) 
				{
					Title = TheValues[0];
					
					MLText ^= """ 
					if(Prev_{{{Title}}} != {{{Title}}})
					{
						Prev_{{{Title}}} = {{{Title}}};
						Label_Title{{{TheName}}}.Value = {{{Title}}}; // TL::ToUpperCase({{{Title}}});
					}
					""";
				} 
				if(TheValues.existskey(1)) 
				{
					Subtitle = TheValues[1];
					
					MLText ^= """ 
					if(Prev_{{{Subtitle}}} != {{{Subtitle}}})
					{
						Prev_{{{Subtitle}}} = {{{Subtitle}}};
						Label_Subtitle{{{TheName}}}.Value = TL::ToUpperCase({{{Subtitle}}});
					}
					""";
				}
				MLText ^= """ 
				// Label_Subtitle{{{TheName}}}.RelativePosition.X = ML::Sin(Now*0.001) * Frame_Subtitle{{{TheName}}}.ClipWindowSize.X * 2.;
				if(Label_Subtitle{{{TheName}}}.Value != "")
				{
					{{{GetMLScrolling(TheName, "Frame_Subtitle", "Label_Subtitle", C_RollingSpeed1)[1]}}}
				}
				""";
			}
			else
			if(TheType == "Input")
			{
				if(IsPlayerSelection)
				{
					declare TextWaiting = _("Press to join");
					declare TextReady 	= _("let's go !");
					MLText ^= """ 
					
					Quad_RightLight{{{TheName}}}		.Visible 	= True;
					Quad_LeftLight{{{TheName}}}			.Visible 	= True;
					
					if(LibTMC_ScoresTable_PadsPlaying	.exists(0)) 
					{
						Quad_RightLight{{{TheName}}}	.Opacity 	= ButtonSelectedOpacity;
						Quad_RightInput{{{TheName}}}	.ImageUrl 	= "{{{IMGSelect}}}";
						Label_RightInput{{{TheName}}}	.Value 		= TL::ToUpperCase("{{{TextReady}}}");
					}
					else
					{
						Quad_RightLight{{{TheName}}}	.Opacity 	= 0.;
						Quad_RightInput{{{TheName}}}	.ImageUrl 	= "{{{IMGJoin}}}";
						Label_RightInput{{{TheName}}}	.Value 		= TL::ToUpperCase("{{{TextWaiting}}}");
					}
					
					if(LibTMC_ScoresTable_PadsPlaying	.exists(1)) 
					{
						Quad_LeftLight{{{TheName}}}		.Opacity 	= ButtonSelectedOpacity;
						Quad_LeftInput{{{TheName}}}		.ImageUrl 	= "{{{IMGSelect}}}";
						Label_LeftInput{{{TheName}}}	.Value 		= TL::ToUpperCase("{{{TextReady}}}");
					}
					else
					{
						Quad_LeftLight{{{TheName}}}		.Opacity 	= 0.;
						Quad_LeftInput{{{TheName}}}		.ImageUrl 	= "{{{IMGJoin}}}";
						Label_LeftInput{{{TheName}}}	.Value 		= TL::ToUpperCase("{{{TextWaiting}}}");
					}
					""";
				}
				else
				{
					MLText ^= """
					declare Boolean	IsPopupValidationFordidden		 for UI;
					Quad_RightInput{{{TheName}}}.Visible 	= True;
					Label_RightInput{{{TheName}}}.Visible 	= True;
					Quad_LeftInput{{{TheName}}}.Visible 	= True;
					Label_LeftInput{{{TheName}}}.Visible 	= True;
					
					if(!IsPopupValidationFordidden) {
						
						declare CInputPad::EPadType Net_LibLastDeviceUsed_LastDeviceTypeUsed 	for UI;
						if({{{UpdateValue}}}.existskey(0)) Quad_RightInput{{{TheName}}}.ImageUrl 	= GetImageForButton({{{UpdateValue}}}[0], Net_LibLastDeviceUsed_LastDeviceTypeUsed);
						if({{{UpdateValue}}}.existskey(2)) Quad_LeftInput{{{TheName}}}.ImageUrl 	= GetImageForButton({{{UpdateValue}}}[2], Net_LibLastDeviceUsed_LastDeviceTypeUsed);
						
						/*
						if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Pad) {
							if({{{UpdateValue}}}.existskey(0)) Quad_RightInput{{{TheName}}}		.ImageUrl 	= {{{UpdateValue}}}[0];
						} else if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Keyboard) {
							if({{{UpdateValue}}}.existskey(0)) Quad_RightInput{{{TheName}}}		.ImageUrl 	= GetPcImageForButton({{{UpdateValue}}}[0]);
						}
						*/
						if({{{UpdateValue}}}.existskey(1)) Label_RightInput{{{TheName}}}	.Value 		= TL::ToUpperCase({{{UpdateValue}}}[1]);
						/*
						if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Pad) {
							if({{{UpdateValue}}}.existskey(2)) Quad_LeftInput{{{TheName}}}	.ImageUrl 		= TL::ToUpperCase({{{UpdateValue}}}[2]);
						} else if(Net_LibLastDeviceUsed_LastDeviceUsed == C_Device_Keyboard) {
							if({{{UpdateValue}}}.existskey(2)) Quad_LeftInput{{{TheName}}}	.ImageUrl 		= GetPcImageForButton({{{UpdateValue}}}[2]);
						}
						*/
						if({{{UpdateValue}}}.existskey(3)) Label_LeftInput{{{TheName}}}	.Value 		= TL::ToUpperCase({{{UpdateValue}}}[3]);
						
						
						
						Quad_RightInput{{{TheName}}}.Visible = True;
						Label_RightInput{{{TheName}}}.Visible = True;
					} else {
						Quad_RightInput{{{TheName}}}.Visible = False;
						Label_RightInput{{{TheName}}}.Visible = False;
					}
					""";
				}
			}
			else
			if(TheType == "Color")
			{
				declare TheValues = TL::Split(" ", Element[C_UPDATE]);
				
				declare Text ColorText;
				declare Text Color;
				
				if(TheValues.existskey(0)) ColorText 	= TheValues[0];
				if(TheValues.existskey(1)) Color 		= TheValues[1];
				
				if(ColorText != "")
				{				
					MLText ^= """ 
					if(Prev_{{{ColorText}}} != {{{ColorText}}})
					{
						Prev_{{{ColorText}}} = {{{ColorText}}};
						Label_{{{TheName}}}.Value = TL::ToUpperCase({{{ColorText}}});
					}
					""";
				}
				
				if(Color != "")
				{				
					MLText ^= """ 
					if(Prev_{{{Color}}} != {{{Color}}})
					{
						Prev_{{{Color}}} = {{{Color}}};
						Quad_{{{TheName}}}.BgColor = {{{Color}}};
					}
					""";
				}
			}
			else
			if(TheType == "Gauge")
			{
				declare TheValues = TL::Split(" ", Element[C_UPDATE]);
				
				declare Text GaugeValue;
				declare Text ColorText;
				declare Text Color;
				
				if(TheValues.existskey(0)) GaugeValue 	= TheValues[0];
				if(TheValues.existskey(1)) ColorText 	= TheValues[1];
				if(TheValues.existskey(2)) Color 	 	= TheValues[2];
				
				if(GaugeValue != "")
				{
					MLText ^= """ 
					if(Prev_{{{GaugeValue}}} != {{{GaugeValue}}})
					{
						Prev_{{{GaugeValue}}} = {{{GaugeValue}}};
						Quad_{{{TheName}}}.Size.X = {{{GaugeValue}}} * {{{SizeX}}};
						Label_Ratio{{{TheName}}}.Value = ML::NearestInteger({{{GaugeValue}}} * 100)^"%";
					}
					""";
				}
					
				if(ColorText != "")
				{
					MLText ^= """ 
					if(Prev_{{{ColorText}}} != {{{ColorText}}})
					{
						Prev_{{{ColorText}}} = {{{ColorText}}};
						Label_{{{TheName}}}.Value = TL::ToUpperCase({{{ColorText}}});
					}
					""";
				}
					
				if(Color != "")
				{
					MLText ^= """ 
					if(Prev_{{{Color}}} != {{{Color}}})
					{
						Prev_{{{Color}}} = {{{Color}}};
						Quad_{{{TheName}}}.BgColor = {{{Color}}};
					}
					""";
				}
			}
		}
	}
	
	
	
	MLText ^= """ 
			
			//----------------------------------
			// CUSTOM : EXTRA CODE IN LOOP      
			
			{{{_CodeInLoop}}}
		}
	}
	--></script>  
	""";
	
	Layers::Create(_LayerName, MLText);
	Layers::Attach(_LayerName);
	Layers::SetAnimationTypeOut(_LayerName, CUILayer::EUILayerAnimation::LeftFast);
	if(IsIngameMenu) Layers::SetType(_LayerName, CUILayer::EUILayerType::InGameMenu);
	if(IsScoreTable) Layers::SetType(_LayerName, CUILayer::EUILayerType::ScoresTable);
}

Void CreateLayer(Text _LayerName, Text _Params, Vec3 _Pos, Text[][] _Elements, Text _Functions, Text _CodeBeforeWhile, Text _CodeWhenShown, Text _CodeInLoop) 
{
	CreateLayer(_LayerName, _Params, 1., _Pos, _Elements, _Functions, _CodeBeforeWhile, _CodeWhenShown, _CodeInLoop);
}

Void CreateLayer(Text _LayerName, Text _Params, Vec3 _Pos, Text[][] _Elements, Text _CodeBeforeWhile) 
{
	CreateLayer(_LayerName, _Params, 1., _Pos, _Elements, "", _CodeBeforeWhile, "", "");
}

Void CreateLayer(Text _LayerName, Text _Params, Vec3 _Pos, Text[][] _Elements) 
{
	CreateLayer(_LayerName, _Params, 1., _Pos, _Elements, "", "", "", "");
}

Void CreateLayer(Text _LayerName, Vec3 _Pos, Text[][] _Elements) 
{
	CreateLayer(_LayerName, "", 1., _Pos, _Elements, "", "", "", "");
}

Void CreateLayer(Text _LayerName, Vec3 _Pos, Text[][] _Elements, Text _Functions, Text _CodeBeforeWhile, Text _CodeWhenShown, Text _CodeInLoop) 
{
	CreateLayer(_LayerName, "", 1., _Pos, _Elements, _Functions, _CodeBeforeWhile, _CodeWhenShown, _CodeInLoop);
}

Void CreateLayer(Text _LayerName, Vec3 _Pos, Text[][] _Elements, Text _CodeBeforeWhile, Text _CodeWhenShown, Text _CodeInLoop) 
{
	CreateLayer(_LayerName, "", 1., _Pos, _Elements, "", _CodeBeforeWhile, _CodeWhenShown, _CodeInLoop);
}

Void CreateLayer(Text _LayerName, Vec3 _Pos, Text[][] _Elements, Text _CodeBeforeWhile) 
{
	CreateLayer(_LayerName, "", 1., _Pos, _Elements, "", _CodeBeforeWhile, "", "");
}

Void SetDefaultFocusedButton(Text _LayerName, Integer _FocusedButtonIndex)
{
	declare netwrite Integer[Text] Net_FocusedButtonForLayer for UI;
	Net_FocusedButtonForLayer[_LayerName] = _FocusedButtonIndex;
}

Void Loop()
{
	declare netwrite Boolean Net_IsPauseMenuEnabled 		for UI;
	declare netwrite Boolean Net_IsPadMissingMenuEnable 	for UI;
	
	if(G_PrevIsPauseMenuEnable != Net_IsPauseMenuEnabled || G_PrevIsPadMissingMenuEnable != Net_IsPadMissingMenuEnable)
	{
		G_PrevIsPauseMenuEnable 		= Net_IsPauseMenuEnabled;
		G_PrevIsPadMissingMenuEnable 	= Net_IsPadMissingMenuEnable;
		
		declare IsOtherLayerVisible = False;
		
		// Checking if a layer is visible (except Special "Over" Layers such as InGameMenu or PadMissing)
		foreach(LayerName in G_LayerNames)
		{
			if(!G_OverLayerNames.exists(LayerName))
			{ 
				declare Layer <=> Layers::Get(LayerName);
				declare LayerVisible = Layer.IsVisible;
				if(LayerVisible) IsOtherLayerVisible = True;
			}
		}
		
		// If yes, the menu will leave without animation to avoid weird overlap
		foreach(LayerName in G_LayerNames)
		{
			if(G_OverLayerNames.exists(LayerName))
			{
				declare Layer <=> Layers::Get(LayerName);
				if(IsOtherLayerVisible) Layer.OutAnimation = CUILayer::EUILayerAnimation::None;
				else 					Layer.OutAnimation = CUILayer::EUILayerAnimation::LeftFast;
			}
		}
	}
}