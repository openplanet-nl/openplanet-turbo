/**
 *	Party Editor
 */
#RequireContext CEditorPlugin

#Const	Version			"2016-03-21"
#Const	ScriptName		"PartyEditor2.Script.txt"
#Const	C_EditorVersion	"11.1.1"

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "MapUnits" as MU
#Include "Libs/Openplanet/UIPadButtons.Script.txt" as Buttons
#Include "Libs/Openplanet/Buttons.Script.txt" as Buttons2
#Include "Libs/Openplanet/SystemText.Script.txt" as SystemText
#Include "Libs/Openplanet/TMConsole/MapEditor/Utils.Script.txt" as Utils
#Include "Libs/Openplanet/TMConsole/MapEditor/Sound.Script.txt" as Sound
#Include "Libs/Openplanet/TMConsole/MapEditor/Music.Script.txt" as Music
#Include "Libs/Openplanet/TMConsole/MapEditor/Random.Script.txt" as Random
#Include "Libs/Openplanet/TMConsole/MapEditor/Macroblock.Script.txt" as Macroblock
#Include "Libs/Openplanet/TMConsole/MapEditor/MapContent.Script.txt" as MapContent
#Include "Libs/Openplanet/TMConsole/MapEditor/Placement.Script.txt" as Placement
#Include "Libs/Openplanet/TMConsole/MapEditor/ThemePack.Script.txt" as ThemePack
#Include "Libs/Openplanet/TMConsole/MapEditor/Layers.Script.txt" as Layers
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/Stylesheet.Script.txt" as Styles
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/Header.Script.txt" as UI_Header
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/StyleSelection.Script.txt" as UI_StyleSelection
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/BlockHelp.Script.txt" as UI_BlockHelp
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/TerrainPreview.Script.txt" as UI_TerrainPreview
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/MacroblockSelection.Script.txt" as UI_MacroblockSelection
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/SkinSelection.Script.txt" as UI_SkinSelection
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/SpawnSelection.Script.txt" as UI_SpawnSelection
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/DecoSelection.Script.txt" as UI_DecoSelection
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/PopUp.Script.txt" as UI_PopUp
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/SimpleChoice.Script.txt" as UI_SimpleChoice
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/Menu.Script.txt" as UI_Menu
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/SimpleMenu.Script.txt" as UI_SimpleMenu
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/RandomMenu.Script.txt" as UI_RandomMenu
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/ShadowMenu.Script.txt" as UI_ShadowMenu
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/MapStyleSelection.Script.txt" as UI_MapStyleSelection
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/MenuOutro.Script.txt" as UI_MenuOutro
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/Tuto.Script.txt" as UI_Tuto
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/Progression.Script.txt" as UI_Progression
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/Multilaps.Script.txt" as UI_Multilaps
#Include "Libs/Openplanet/TMConsole/MapEditor/UI/MouseControl.Script.txt" as UI_MouseControl
#Include "Libs/Openplanet/TMConsole/MapEditor/CutPaste.Script.txt" as CutPaste
#Include "Libs/Openplanet/TMConsole/MapEditor/Collection.Script.txt" as Collection
#Include "Libs/Openplanet/TMConsole/MapEditor/RandomStyles.Script.txt" as RandomStyles
#Include "Libs/Openplanet/TMConsole/MapEditor/Transitions.Script.txt" as Transitions
#Include "Libs/Openplanet/TMConsole/MapEditor/AutoFinish.Script.txt" as AutoFinish
#Include "Libs/Openplanet/TMConsole/MapEditor/BlockVariant.Script.txt" as BlockVariant
#Include "Libs/Openplanet/TMConsole/MapEditor/History2.Script.txt" as History2
#Include "Libs/Openplanet/TMConsole/MapEditor/Terrain.Script.txt" as Terrain
#Include "Libs/Openplanet/TMConsole/MapEditor/Selection.Script.txt" as Selection
#Include "Libs/Openplanet/TMConsole/MapEditor/WeightedListStack.Script.txt" as List
#Include "Libs/Openplanet/TMConsole/MapEditor/Camera.Script.txt" as Camera
#Include "Libs/Openplanet/TMConsole/MapEditor/MapTypeSynchro.Script.txt" as MapTypeSynchro
#Include "Libs/Openplanet/TMConsole/MapEditor/MapInfo.Script.txt" as MapInfo
#Include "Libs/Openplanet/TMConsole/MapEditor/EditorAchievements.Script.txt"	as Achievements
#Include "Libs/Openplanet/TMConsole/UplayActionsSynchro.Script.txt" as UplayActionsSynchro

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_EditorLevel			0/*/1*/
#Setting S_TrialVersion			False/*/True*/
#Setting S_CreateCopy			False
#Setting S_ShadowQuality		0/*/2*/
#Setting S_RandomMap_Generate	False/*/True*/
#Setting S_RandomMap_Validate	False/*/True*/
#Setting S_RandomMap_Config		""/*/"""
<commands>
	<!--<seed>2</seed> tunnel -->
	<seed>23</seed>
	<!--<properties>
		<length>1200.</length>
		<checkpointsspacing>250.</checkpointsspacing>
	</properties>-->
	<!--<trackmultipliers>
		<multiplier isturning="0">0.5</multiplier>
	</trackmultiplier>-->
</commands>"""*/
#Setting S_RandomMap_Seed		0
#Setting S_RandomMap_Length		""
#Setting S_RandomMap_Speed		""
#Setting S_RandomMap_Style		""

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_TerrainPreviewThreshold	1500			///< Duration before placing a terrain
#Const C_DefaultDecoAmount				0.				///< Default amount of deco of each type
#Const C_DefaultPodiumAmount			0.				///< Default amount of podium
#Const C_MaxRecentMacroblocks			10				///< Maximum number of recent macroblock
#Const C_AutoFinish_MaxSteps			50				///< Maxium number of blocks to place when trying to auto-finish the track
#Const C_AutoFinish_MaxIterations	250				///< Maximum number of iterations during auto finish
#Const C_AutoFinish_PaddingTop		3				///< Minimum number of blocks between the clip and the top of the map
#Const C_RandomMap_MaxIterations	250				///< Maximum number of iterations during random map
#Const C_RandomMap_MaxTries				3				///< Maximum number of tries to generate a random map
#Const C_CameraCoord_Terraforming	<1297.7, 89.559, 112.73> ///< Random terraforming camera coordinates
#Const C_CameraRot_Terraforming		<317., 13.2>	///< Random terraforming camera rotation
#Const C_CameraZoom_Terraforming	["Canyon" => 1800., "Valley" => 1200., "Stadium" => 1000., "Lagoon" => 1200.] ///< Terraforming camera zoom
#Const C_CameraZoom_Reroll				1000.			///< Reroll camera zoom
#Const C_CameraCoord_Place				<127.12, 175.3, -84.15>	///< Random macroblock camera coordinates
#Const C_CameraRot_Place					<312., 46.8>	///< Random macroblock camera rotation
#Const C_RandomDecorationDelay		500				///< Delay between two random decoration macroblock
#Const C_RandomTerrainId					"PartyEditor_RandomTerrain"	///< Random terrain id
#Const C_InitialAutoRepeatDelay		250				///< Initial delay (in ms) before activating the autorepeat
#Const C_MaxAutoRepeatDelay				200				///< Maximum delay (in ms) between two press of a button to let the autorepeat active
#Const C_AutoRepeatTime					100				///< Time (in ms) between two activations of an autorepeat
#Const C_CursorVisibility				0.				///< Cursor visibility
#Const C_HideBlockHelpers				False			///< Hide block helpers
#Const C_Expert_AutoDir					False			///< Automatically direct the macroblock in a valid direction
#Const C_ShowPlacementGrid			False			///< Show the placement grid helper
#Const C_RandomLandscape				False			///< Use random terraforming in the normal editor
#Const C_RandomMusic 						True			///< Play music during the random generation
#Const C_FastTerraforming				True			///< Yield frequency during random terraforming
#Const C_FastLagoon							False			///< Speed up random generation on Lagoon
#Const C_Music									True			///< Enable the music
#Const C_CopperLimit_Soft				8000			///< Warn player that he's reaching the copper limit
#Const C_CopperLimit_Hard				8500			///< Copper price limit
#Const C_CopperLimit_Deco				7000			///< Copper limit that start to lessen decoration
#Const C_DecoLimiter						0.5				///< Limit the decoration amount (1.=>full, 0.5=>medium, 0.=>empty)
#Const C_WarnControllerOnPc			True			///< Warn player to connect a controller on PC
#Const C_CheckpointGap					300.			///< Best distance between checkpoints
#Const C_FastShadow							CEditorPlugin::ShadowsQuality::Fast	///< Fast shadow computation
#Const C_RemoveAutoSwitchMode		False			///< Automatically switch to the mode of the removed block
#Const C_CutPasteBeginner				True			///< Allow cut paste in the beginner editor

// Theme packs
#Const C_ThemePack_Beginner "file://Media/Config/TMConsole/MapEditor/BeginnerPack.xml"
#Const C_ThemePack_Advanced "file://Media/Config/TMConsole/MapEditor/ThemePacks.xml"
#Const C_ThemePack_Expert		"file://Media/Config/TMConsole/MapEditor/ExpertPacks.xml"

// Editor levels
#Const C_Editor_Beginner	0
#Const C_Editor_Advanced	1
#Const C_Editor_Expert		2
#Const C_Editor_Classic		3

// Shadow quality
#Const C_Shadow_AlwaysAsk	0
#Const C_Shadow_Fast			1
#Const C_Shadow_Nice			2

// Ticks
#Const C_Tick_FilterMacroblock		100
#Const C_Tick_GetFinishCoordBFS		100
#Const C_Tick_GetFinishCoordGBFS	100
#Const C_Tick_RandomDecorate			25
#Const C_Tick_BlockHelper					2500

// Sequences
#Const C_Sequence_MainMenu						0	///< The player is in the main menu
#Const C_Sequence_PopUp								1	///< The player is in a pop up
#Const C_Sequence_SelectTerrain				2	///< The player must select a terrain
#Const C_Sequence_RandomTerrain				3	///< Random terrain settings
#Const C_Sequence_AutoTerrain					4	///< Terraforming the map automatically
#Const C_Sequence_PlaceStart					5	///< The player must place a start block
#Const C_Sequence_ConnectMode					6	///< The player build the track after the start block in connect mode
#Const C_Sequence_FreeMode						7	///< Free mode
#Const C_Sequence_TestMode						8	///< The player select a checkpoint to spawn
#Const C_Sequence_AutoFinish					9	///< Auto-finishing the track
#Const C_Sequence_EditTerrain					10	///< Terrain edition : add mode
#Const C_Sequence_AutoDecoration			11	///< Decorating the map automatically
#Const C_Sequence_EditDecoration			12	///< Decoration edition : add mode
#Const C_Sequence_RandomMap						13	///< Full random map generation
#Const C_Sequence_RerollMap						14	///< Reroll random map
#Const C_Sequence_MapStyle						15	///< Map style selection
#Const C_Sequence_Simple_Terraforming	16	///< Simple mode terraforming
#Const C_Sequence_Simple_AutoTerrain	17	///< Simple mode auto terraform terrain
#Const C_Sequence_Simple_PlaceStart		18	///< Simple mode place start
#Const C_Sequence_Simple_BuildTrack		19	///< Simple mode build track
#Const C_Sequence_Simple_MoveCursor		20	///< Simple mode move cursor
#Const C_Sequence_Simple_Test					21	///< Simple mode test
#Const C_Sequence_Simple_Deco					22	///< Simple mode decoration
#Const C_Sequence_Simple_Outro				23	///< Simple mode outro
#Const C_Sequence_Classic_Build				24	///< Classic editor build mode
#Const C_Sequence_None								-1	///< No sequence selected

// Simple choice events
#Const C_SimpleChoice_SelectLandscape	0	///< Select landscape
#Const C_SimpleChoice_StartTrack		1	///< Start track after selecting a landscape
#Const C_SimpleChoice_DecoGenerate		2	///< Generate random decoration
#Const C_SimpleChoise_DecoValid			3	///< Confirm decoration and start validation
#Const C_SimpleChoice_DecoCancel		4	///< Cancel decoration step and go back to track editing
#Const C_SimpleChoice_DecoDefault		5	///< Set the amount of each decoration category to their default value
#Const C_SimpleChoice_RandomGenerate	6	///< Generate a new random map
#Const C_SimpleChoice_RandomSave		7	///< Save the random map
#Const C_SimpleChoice_RandomPlay		8	///< Play on the random map

// Category
#Const C_Categories [
	//L16N [MapEditor] Edit mode where the player modify the landscape
	_("Landscape"), 
	//L16N [MapEditor] Edit mode where the player modify the track
	_("Track")
]
#Const C_Categories_Landscape	0
#Const C_Categories_Construct	1
// Modes
#Const C_Modes [
	//L16N [MapEditor] Edit mode where the track is generated randomly
	_("Random"), 
	//L16N [MapEditor] Edit mode where the player select a preconstructed landscape by navigating between pictures of the landscapes
	_("Postcards"),
	//L16N [MapEditor] Edit mode where the player modify the landscape
	_("Landscape"), 
	//L16N [MapEditor] Edit mode where the player modify the track
	_("Track"), 
	//L16N [MapEditor] Edit mode where the player modify the decoration
	_("Decoration")]
#Const C_Modes_LandscapeRandom		0
#Const C_Modes_LandscapePostcards	1
#Const C_Modes_ConstructTerrain		2
#Const C_Modes_ConstructTrack		3
#Const C_Modes_ConstructDeco		4

#Const C_Translations [
	//L16N [MapEditor] List of blocks used recently
	_("Recents"), 
	//L16N [MapEditor] List of favorite blocks
	_("Favorites")
]

// Auto repeat
#Const C_AutoRepeatDisabled [CEditorPluginEvent::EInput::Unknown, CEditorPluginEvent::EInput::Menu, CEditorPluginEvent::EInput::SwitchToRace, CEditorPluginEvent::EInput::CursorTurn, CEditorPluginEvent::EInput::CursorPick, CEditorPluginEvent::EInput::CursorPlace, CEditorPluginEvent::EInput::RemoveAll, CEditorPluginEvent::EInput::CursorDelete, CEditorPluginEvent::EInput::CameraZoomNext]
#Const C_AutoRepeatEnabled [CEditorPluginEvent::EInput::Undo, CEditorPluginEvent::EInput::Redo, CEditorPluginEvent::EInput::CursorUp, CEditorPluginEvent::EInput::CursorRight, CEditorPluginEvent::EInput::CursorDown, CEditorPluginEvent::EInput::CursorLeft, CEditorPluginEvent::EInput::CursorRaise, CEditorPluginEvent::EInput::CursorLower, CEditorPluginEvent::EInput::CameraUp, CEditorPluginEvent::EInput::CameraRight, CEditorPluginEvent::EInput::CameraDown, CEditorPluginEvent::EInput::CameraLeft, CEditorPluginEvent::EInput::IconUp, CEditorPluginEvent::EInput::IconRight, CEditorPluginEvent::EInput::IconDown, CEditorPluginEvent::EInput::IconLeft]
#Const C_AutoRepeatCursor [CEditorPluginEvent::EInput::IconUp, CEditorPluginEvent::EInput::IconRight, CEditorPluginEvent::EInput::IconDown, CEditorPluginEvent::EInput::IconLeft, CEditorPluginEvent::EInput::CursorUp, CEditorPluginEvent::EInput::CursorRight, CEditorPluginEvent::EInput::CursorDown, CEditorPluginEvent::EInput::CursorLeft]
#Const C_AutoRepeatCamera [CEditorPluginEvent::EInput::CameraUp, CEditorPluginEvent::EInput::CameraRight, CEditorPluginEvent::EInput::CameraDown, CEditorPluginEvent::EInput::CameraLeft]
#Const C_StopGeneration [CEditorPluginEvent::EInput::Menu]

#Const C_Debug 				False	///< Global debug
#Const C_EnableLog			False	///< Global log switch
#Const C_LogToFile			False	///< Log to file
#Const C_LogThemePack		False	///< Log theme pack debug
#Const C_LogRandom 			False	///< Log random map generation progress
#Const C_DemoSony			False	///< Sony VR demo

// ---------------------------------- //
// Globales
// ---------------------------------- //
declare Integer G_CurrentSequence;		///< The current sequence
declare Integer G_PrevSequence;			///< The previous sequence
declare Boolean G_TestMode;				///< Player is in test mode
declare Integer G_FreeModeVariant;		///< Force a variant in free mode
declare Integer G_PreviewTerrainTime;	///< Time at which the terrain will be previewed
declare Text G_PreviewTerrainId;		///< Name of the terrain to preview
declare Boolean G_GeneratingTerrain;	///< Editor is randomly generating terrain
declare Boolean G_GeneratingDecoration;	///< Editor is randomly generating terrain
declare Boolean G_RandomMapGeneration;	///< Generate a random map
declare Boolean G_AutoFinishing;		///< Editor is trying to auto finish the map
declare Int3 G_CursorCoord;				///< Real cursor coord
declare CEditorPlugin::CardinalDirections G_CursorDir; ///< Real cursor dir
declare CMacroblockModel G_CursorMacroblockModel; ///< Real cursor macroblock model
declare Integer G_CursorConnectedTo;	///< Connection used for the current cursor
declare CMacroblockModel[][Text] G_AvailableMacroblocks; ///< Available macroblocks
declare Text[CMacroblockModel] G_DiscardedMacroblocks; ///< Macroblocks discarded by the filtering
declare Integer[] G_AvailableConnectors;///< Available connectors
declare Ident G_AvailableCheckpoint;	///< Is there a checkpoint available
declare Text[] G_RecentMacroblocks;		///< Recently used macroblocks
declare Integer[CEditorPluginEvent::EInput] G_AutoRepeatInput; ///< Input to auto repeat
declare Integer[CEditorPluginEvent::EInput] G_LastDeviceInput; ///< Last device use to do the input
declare CEditorPluginEvent::EInput[] G_InputBuffer;	///< Buffer the inputs
declare Integer[] G_DeviceBuffer;		///< Device used to generate the inputs
declare Text[][Text][] G_UIInputBuffer;	///< Buffer of UI inputs
declare Boolean G_CancelGeneration;		///< Stop the current auto-finish or random generation process
declare Boolean G_LeaveEditor;			///< Leave the editor
declare Boolean G_RestartGeneration;	///< Restart the random generation process
declare Boolean G_StartingNewMap;		///< True if we're starting a new map after placing the terrain
declare Boolean G_MainMenu;				///< True when in main menu
declare Boolean G_MapStyleSelection;	///< True when in map style selection menu
declare Integer G_Category;				///< Current category
declare Integer G_Mode;					///< Current mode
declare Boolean G_IsSkinning;			///< True when the player edit the skin of an object
declare Boolean G_IsEditing;			///< True when the player edit a macroblock
declare Int3 G_ForcedCursorCoord;		///< Force the cursor coordinates
declare Int3[Integer] G_SavedCursorCoord; ///< Saved cursor coordinates for differents sequences
declare Integer G_LastRandomPlace;		///< Last time a random macroblock was placed
declare Boolean G_AllowLongPress;		///< Allow long press
declare Int3 G_FilteringCoord;			///< Coordinates of the last macroblocks filter
declare Integer G_InactivityStartTime;	///< Time of the last player activity
declare Boolean G_AskForDeco;			///< Ask the player if he wants to decorate his map
declare Boolean G_AskForValidation;		///< Ask the player if he wants to validate his map
declare Integer G_MacroblocksCount;		///< Number of macroblocks available
declare Integer G_Setting_EditorLevel;	///< Editor mode
declare Boolean G_WaitingRerollAnswer;	///< Waiting an answer to know if we reroll or not
declare Boolean G_RerollRandomMap;		///< Reroll random map or not
declare Boolean G_TestedRandomMap;		///< The random map was tested
declare CEditorPlugin::PlaceMode G_PlaceMode; ///< Forced place mode
declare CEditorPlugin::EditMode G_EditMode; ///< Forced edit mode
declare Boolean G_HMD_IsActive;			///< HMD status
declare Boolean G_NeedRebuild;			///< Map must be rebuild to access history
declare Boolean G_MoveCursor;			///< Move cursor in simple mode
declare Boolean G_CanAskCheckpoint;		///< Can ask the player to place a checkpoint
declare Boolean G_TerrainCanPress;		///< Can press button to add terrain
declare CMacroblockModel[] G_RandomMacroblocks;	///< Macroblocks for the random generator
declare Boolean G_RebuildMap;			///< Trackbuilder is rebuilding a map
declare Integer[Ident] G_CacheBlocksSkins; ///< Save the index of the last skin used on a block
declare Integer G_Platform;				///< Current platform used for the buttons
declare Boolean G_StartClassicEditor;	///< Start the classic map editor on PC

// ---------------------------------- //
// Functions
// ---------------------------------- //
Void LogRandomMap(Text _Text) {
	if (C_LogRandom) Utils::Log(_Text);
}

// ---------------------------------- //
/** Check if an input is down
 *
 *	@param	_Input					The input to check
 *
 *	@return							True if the input is down, False otherwise 
 */
Boolean InputIsDown(CEditorPluginEvent::EInput _Input) {
	switch (_Input) {
		case CEditorPluginEvent::EInput::Menu			: return EditorInputIsDown_Menu;
		case CEditorPluginEvent::EInput::SwitchToRace	: return EditorInputIsDown_SwitchToRace;
		case CEditorPluginEvent::EInput::Undo			: return EditorInputIsDown_Undo;
		case CEditorPluginEvent::EInput::Redo			: return EditorInputIsDown_Redo;
		case CEditorPluginEvent::EInput::CursorUp		: return EditorInputIsDown_CursorUp;
		case CEditorPluginEvent::EInput::CursorRight	: return EditorInputIsDown_CursorRight;
		case CEditorPluginEvent::EInput::CursorDown		: return EditorInputIsDown_CursorDown;
		case CEditorPluginEvent::EInput::CursorLeft		: return EditorInputIsDown_CursorLeft;
		case CEditorPluginEvent::EInput::CursorRaise	: return EditorInputIsDown_CursorRaise;
		case CEditorPluginEvent::EInput::CursorLower	: return EditorInputIsDown_CursorLower;
		case CEditorPluginEvent::EInput::CursorTurn		: return EditorInputIsDown_CursorTurn;
		case CEditorPluginEvent::EInput::CursorPick		: return EditorInputIsDown_CursorPick;
		case CEditorPluginEvent::EInput::CursorPlace	: return EditorInputIsDown_CursorPlace;
		case CEditorPluginEvent::EInput::CursorDelete	: return EditorInputIsDown_CursorDelete;
		case CEditorPluginEvent::EInput::RemoveAll		: return EditorInputIsDown_RemoveAll;
		case CEditorPluginEvent::EInput::CameraUp		: return EditorInputIsDown_CameraUp;
		case CEditorPluginEvent::EInput::CameraRight	: return EditorInputIsDown_CameraRight;
		case CEditorPluginEvent::EInput::CameraDown		: return EditorInputIsDown_CameraDown;
		case CEditorPluginEvent::EInput::CameraLeft		: return EditorInputIsDown_CameraLeft;
		case CEditorPluginEvent::EInput::CameraZoomNext	: return EditorInputIsDown_CameraZoomNext;
		case CEditorPluginEvent::EInput::IconUp			: return EditorInputIsDown_IconUp;
		case CEditorPluginEvent::EInput::IconRight		: return EditorInputIsDown_IconRight;
		case CEditorPluginEvent::EInput::IconDown		: return EditorInputIsDown_IconDown;
		case CEditorPluginEvent::EInput::IconLeft		: return EditorInputIsDown_IconLeft;
	}
	
	return False;
}

// ---------------------------------- //
/// Clear the input buffers
Void ClearInputBuffer() {
	G_InputBuffer.clear();
	G_DeviceBuffer.clear();
	G_UIInputBuffer.clear();
}

// ---------------------------------- //
/** Update the input buffer
 *
 *	@param	_Input					The input to add
 *	@param	_IsPad					Input generated by a pad
 *	@param	_IsKeyboard				Input generated by a keyboard
 *	@param	_IsMouse				Input generated by a mouse
 */
Void UpdateInputBuffer(CEditorPluginEvent::EInput _Input, Boolean _IsPad, Boolean _IsKeyboard, Boolean _IsMouse) {
	// Ignore mouse input
	if (_IsMouse) return;
	if (G_InputBuffer.exists(_Input)) return;
	
	if (UI_MacroblockSelection::IsSelecting() || C_AutoRepeatDisabled.exists(_Input)) {
		G_InputBuffer.add(_Input);
		G_DeviceBuffer.add(Buttons2::GetInputDevice(_IsPad, _IsKeyboard, _IsMouse));
	} else {
		if (!G_AutoRepeatInput.existskey(_Input)) G_AutoRepeatInput[_Input] = 0;
		
		if (Now > G_AutoRepeatInput[_Input]) {
			declare TimeSinceLastTrigger = Now - G_AutoRepeatInput[_Input];
			if (C_AutoRepeatCursor.exists(_Input)) {
				foreach (Input in C_AutoRepeatCursor) {
					if (!G_AutoRepeatInput.existskey(Input)) continue;
					if (Now - G_AutoRepeatInput[Input] < TimeSinceLastTrigger) {
						TimeSinceLastTrigger = Now - G_AutoRepeatInput[Input];
					}
				}
			} else if (C_AutoRepeatCamera.exists(_Input)) {
				foreach (Input in C_AutoRepeatCamera) {
					if (!G_AutoRepeatInput.existskey(Input)) continue;
					if (Now - G_AutoRepeatInput[Input] < TimeSinceLastTrigger) {
						TimeSinceLastTrigger = Now - G_AutoRepeatInput[Input];
					}
				}
			}
			
			declare NextTriggerTime = Now + C_InitialAutoRepeatDelay;
			if (TimeSinceLastTrigger <= C_MaxAutoRepeatDelay) {
				NextTriggerTime = Now + C_AutoRepeatTime;
			}
			G_AutoRepeatInput[_Input] = NextTriggerTime;
			G_InputBuffer.add(_Input);
			G_DeviceBuffer.add(Buttons2::GetInputDevice(_IsPad, _IsKeyboard, _IsMouse));
		}
	}
}
// ---------------------------------- //
/** Update the input buffer
 *
 *	@param	_Input					The input to add
 */
Void UpdateInputBuffer(CEditorPluginEvent::EInput _Input) {
	declare IsPad = False;
	declare IsKeyboard = False;
	declare IsMouse = False;
	
	if (G_LastDeviceInput.existskey(_Input)) {
		declare Device = G_LastDeviceInput[_Input];
		IsPad = (Device == Buttons2::Device_Pad());
		IsKeyboard = (Device == Buttons2::Device_Keyboard());
		IsMouse = (Device == Buttons2::Device_Mouse());
	}
	
	UpdateInputBuffer(_Input, IsPad, IsKeyboard, IsMouse);
}

// ---------------------------------- //
/** Update the UI input buffer
 *
 *	@param	_Type					The event type
 *	@param	_Data					The data
 */
Void UpdateUIInputBuffer(Text _Type, Text[] _Data) {
	G_UIInputBuffer.add([_Type => _Data]);
}

// ---------------------------------- //
/** Get the name of the map
 *
 *	@return							The name of the map
 */
Text GetMapName() {
	declare metadata Text PartyEditor_MapName for Map;
	return PartyEditor_MapName;
}

// ---------------------------------- //
/** Check if we are in a given editor mode
 *
 *	@param	_Level					The level to check
 *
 *	@return							True if we are in the given editor mode, False otherwise
 */
Boolean IsEditor(Integer _Level) {
	if (S_RandomMap_Generate && _Level == C_Editor_Expert) return True; ///< Random editor is expert editor
	return (G_Setting_EditorLevel == _Level && !S_RandomMap_Generate);
}

// ---------------------------------- //
/** Check if we the user is allowed to cut and paste
 *
 *	@return							True if the user can cut and paste, False otherwise
 */
Boolean CutPasteIsAllowed() {
	return (
		!G_RandomMapGeneration && (
			IsEditor(C_Editor_Advanced) || (IsEditor(C_Editor_Beginner) && C_CutPasteBeginner)
		)
	);
}

// ---------------------------------- //
/// Check that a pad is connected
Void CheckPadConnection() {
	if (!IsEditorReadyForRequest || UI_PopUp::IsInLoading() || HoldLoadingScreen) return;
	
	if (
		(
			SystemPlatform == CManiaApp::ESystemPlatform::PS4 || 
			SystemPlatform == CManiaApp::ESystemPlatform::XBoxOne ||
			C_WarnControllerOnPc
		) && 
		UserMgr != Null &&
		UserMgr.MainUserPad == Null
	) {
		//L16N [MapEditor] Text of the pop-up displayed when all controllers are disconnected. The %1 will be replaced by the name of the controller, eg: Dualshock 4 (r) wireless controller or XB1 wireless controller.
		//declare PleaseConnectPadText = TL::Compose(_("Please reconnect the %1"), Buttons::GetPadName());
		
		UI_PopUp::PadDisconnected(True);
		declare SimpleMenuVisible = UI_SimpleMenu::IsVisible();
		declare MenuVisible = UI_Menu::IsVisible();
		if (SimpleMenuVisible) UI_SimpleMenu::Hide();
		if (MenuVisible) UI_Menu::Hide();
		
		Sound::Play("EditorPopUp");
		
		// Wait the reconnection of the controller + a press on the Cross or A button
		while ((UserMgr != Null && UserMgr.MainUserPad == Null)) {
			yield;
		}
		
		if (SimpleMenuVisible) UI_SimpleMenu::Show();
		if (MenuVisible) UI_Menu::Show();
		UI_PopUp::PadDisconnected(False);
		
		// Clear input buffer
		ClearInputBuffer();
		G_TerrainCanPress = False;
	}
}

// ---------------------------------- //
/// Display random generator menu
Void RandomMenu() {
	declare Wait = True;
	declare Answer = UI_RandomMenu::Selection_Null();
	if (G_CurrentSequence == C_Sequence_RandomMap) {
		UI_RandomMenu::SetOptions([UI_RandomMenu::Selection_Restart(), UI_RandomMenu::Selection_Quit(), UI_RandomMenu::Selection_Back()]);
	} else {
		if (S_RandomMap_Validate) {
			UI_RandomMenu::SetOptions([UI_RandomMenu::Selection_Quit(), UI_RandomMenu::Selection_Back()]);
		} else {
			UI_RandomMenu::SetOptions([UI_RandomMenu::Selection_Quit(), UI_RandomMenu::Selection_Back()]);
		}
	}
	UI_RandomMenu::Show();
	Sound::Play("EditorPopUp");
	
	while (Wait) {
		yield; ///< Yield before events to remove first menu button press
		
		foreach (Event in PendingEvents) {
			if (Event.Type == CEditorPluginEvent::Type::EditorInput) {
				switch (Event.Input) {
					case CEditorPluginEvent::EInput::Menu			: {
						Sound::Play("EditorMenuCancel");
						Wait = False;
					}
					case CEditorPluginEvent::EInput::CursorPlace	: {
						Answer = UI_RandomMenu::Valid();
						Wait = False;
					}
					case CEditorPluginEvent::EInput::RemoveAll	: {
						if (Event.IsFromKeyboard) {
							Sound::Play("EditorMenuCancel");
							Wait = False;
						}
					}
					case CEditorPluginEvent::EInput::CursorDelete	: {
						if (Event.IsFromPad) {
							Sound::Play("EditorMenuCancel");
							Wait = False;
						}
					}
					case CEditorPluginEvent::EInput::CursorUp		: UI_RandomMenu::Prev();
					case CEditorPluginEvent::EInput::CursorDown		: UI_RandomMenu::Next();
					case CEditorPluginEvent::EInput::IconUp			: UI_RandomMenu::Prev();
					case CEditorPluginEvent::EInput::IconDown		: UI_RandomMenu::Next();
				}
			} else if (Event.Type == CEditorPluginEvent::Type::LayerCustomEvent) {
				switch (Event.CustomEventType) {
					case UI_RandomMenu::Event_Hover(): UI_RandomMenu::Select(TL::ToInteger(Event.CustomEventData[0]), True);
					case UI_RandomMenu::Event_Click(): {
						UI_RandomMenu::Select(TL::ToInteger(Event.CustomEventData[0]));
						Answer = UI_RandomMenu::Valid();
						Wait = False;
					}
				}
			}
		}
		
		// Check after the events, to avoid validating in the menu when closing the pad pop-up
		CheckPadConnection();
	}
	
	switch (Answer) {
		case UI_RandomMenu::Selection_Restart(): {
			G_CancelGeneration = True;
			G_RestartGeneration = True;
		}
		case UI_RandomMenu::Selection_Quit(): {
			G_CancelGeneration = True;
			G_LeaveEditor = True;
		}
	}
	
	UI_RandomMenu::Hide();
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
}

// ---------------------------------- //
/// Check if we can display a tutorial to the player
Void CheckTuto() {
	if (G_RebuildMap) return; //< No tutorial during map rebuild
	
	if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
		declare StartDistance = MapContent::GetDistanceTo(MapContent::Block_Start());
		declare LastCheckpointDistance = MapContent::GetDistanceTo(MapContent::Block_Checkpoint());
		declare LastStopEngineDistance = MapContent::GetDistanceTo(MapContent::Block_StopEngine());
		
		// Checkpoint tuto
		if (IsEditor(C_Editor_Beginner)) {
			if (StartDistance > 1500. && StartDistance < 2000.) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Finish());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Finish());
			}
			
			if (G_AvailableCheckpoint != NullId && LastCheckpointDistance > C_CheckpointGap) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Checkpoint());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Checkpoint());
			}
		}
		
		// Switch tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Switch())) {
			if (UI_Tuto::Count(UI_Tuto::Tuto_Switch()) >= 1) {
				UI_Tuto::Validate(UI_Tuto::Tuto_Switch());
			} else if (G_AvailableConnectors.count > 1) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Switch());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Switch());
			}
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_Switch());
		}
		
		// Test tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Test()) && MapContent::HasCheckpoint()) {
			UI_Tuto::Enable(UI_Tuto::Tuto_Test());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_Test());
		}
		
		// Stop engine tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_StopEngine()) && LastStopEngineDistance < LastCheckpointDistance) {
			UI_Tuto::Enable(UI_Tuto::Tuto_StopEngine());
		} else if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_StopEngine()) && LastStopEngineDistance >= LastCheckpointDistance) {
			UI_Tuto::Validate(UI_Tuto::Tuto_StopEngine());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_StopEngine());
		}
	} else if (G_CurrentSequence == C_Sequence_Simple_MoveCursor) {
		// Connection modes tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_ConnectMode())) {
			UI_Tuto::Enable(UI_Tuto::Tuto_ConnectMode());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_ConnectMode());
		}
	} else if (
		G_CurrentSequence == C_Sequence_FreeMode ||
		G_CurrentSequence == C_Sequence_PlaceStart ||
		G_CurrentSequence == C_Sequence_EditDecoration
	) {
		// Move tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_MoveBlock()) && !G_IsEditing && !G_IsSkinning) {
			UI_Tuto::Enable(UI_Tuto::Tuto_MoveBlock());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_MoveBlock());
		}
		
		// Move tuto PC
		if (G_Platform == Buttons2::System_PC() && !UI_Tuto::IsValidated(UI_Tuto::Tuto_MoveBlock_Mouse())) {
			UI_Tuto::Enable(UI_Tuto::Tuto_MoveBlock_Mouse());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_MoveBlock_Mouse());
		}
		
		// Place tuto PC
		if (G_Platform == Buttons2::System_PC() && !UI_Tuto::IsValidated(UI_Tuto::Tuto_PlaceBlock_Mouse())) {
			UI_Tuto::Enable(UI_Tuto::Tuto_PlaceBlock_Mouse());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_PlaceBlock_Mouse());
		}
		
		if (G_CurrentSequence == C_Sequence_PlaceStart) {
			// Multilaps tuto
			if (CursorMacroblockModel != Null && CursorMacroblockModel.HasMultilap && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Multilaps())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Multilaps());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Multilaps());
			}
		}
		
		if (G_CurrentSequence == C_Sequence_FreeMode || G_CurrentSequence == C_Sequence_EditDecoration) {
			// Macroblock selection tuto
			if (!G_IsEditing && !G_IsSkinning && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Rosaces())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Rosaces());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Rosaces());
			}
			
			// Switch build mode tuto
			if (!G_IsEditing && !G_IsSkinning && !UI_Tuto::IsValidated(UI_Tuto::Tuto_ChangeMode())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_ChangeMode());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_ChangeMode());
			}
			
			// Editing tuto
			declare PartyEditor_TutoEditCopy for This = False;
			if ((G_IsEditing || G_IsSkinning) && PartyEditor_TutoEditCopy && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Edit())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Edit());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Edit());
			}
			
			// Skin tuto
			if (G_IsSkinning && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Skin())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Skin());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Skin());
			}
		}
	} else if (G_CurrentSequence == C_Sequence_EditTerrain) {
		// Edit terrain tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_EditTerrain())) {
			UI_Tuto::Enable(UI_Tuto::Tuto_EditTerrain());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_EditTerrain());
		}
	}
	
	if (
		G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
		G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
		G_CurrentSequence == C_Sequence_PlaceStart ||
		G_CurrentSequence == C_Sequence_FreeMode ||
		G_CurrentSequence == C_Sequence_EditTerrain ||
		G_CurrentSequence == C_Sequence_EditDecoration
	) {
		// Camera move tuto
		if (G_Platform == Buttons2::System_PC() && !UI_Tuto::IsValidated(UI_Tuto::Tuto_CameraMove_Mouse())) {
			UI_Tuto::Enable(UI_Tuto::Tuto_CameraMove_Mouse());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_CameraMove_Mouse());
		}
		if (G_Platform != Buttons2::System_PC() && !UI_Tuto::IsValidated(UI_Tuto::Tuto_CameraMove_Pad())) {
			UI_Tuto::Enable(UI_Tuto::Tuto_CameraMove_Pad());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_CameraMove_Pad());
		}
		
		/*
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_CameraZoom())) {
			UI_Tuto::Enable(UI_Tuto::Tuto_CameraZoom());
		}
		*/
	}
}

// ---------------------------------- //
/// Update the save status when the map is modified
Void MapModified() {
	if (GetMapName() == "") Utils::SetSaveStatus(Utils::SaveStatus_NotSaved());
	else Utils::SetSaveStatus(Utils::SaveStatus_Modified());
}

// ---------------------------------- //
/// Yield
Void Yield() {
	yield;
	
	if (UserMgr != Null && UserMgr.MainUser != Null) UplayActionsSynchro::CheckUplayActions();
	
	declare AskStopGeneration = False;
	
	foreach (Event in PendingEvents) {
		if (Event.Type == CEditorPluginEvent::Type::EditorInput) {
			// Launch classic map editor
			if (Event.Input == CEditorPluginEvent::EInput::ClassicMapEditor) {
				if (!IsEditor(C_Editor_Classic)) G_StartClassicEditor = True;
			} else {
				// Save device used to generate input
				if (Event.IsFromPad) {
					G_LastDeviceInput[Event.Input] = Buttons2::Device_Pad();
				} else if (Event.IsFromKeyboard) {
					G_LastDeviceInput[Event.Input] = Buttons2::Device_Keyboard();
				} else if (Event.IsFromMouse) {
					G_LastDeviceInput[Event.Input] = Buttons2::Device_Mouse();
				}
				
				if (UI_MacroblockSelection::IsSelecting() || C_AutoRepeatDisabled.exists(Event.Input)) {
					UpdateInputBuffer(Event.Input, Event.IsFromPad, Event.IsFromKeyboard, Event.IsFromMouse);
				}
				if (
					(G_CurrentSequence == C_Sequence_RandomMap || G_CurrentSequence == C_Sequence_AutoFinish) &&
					C_StopGeneration.exists(Event.Input)
				) {
					AskStopGeneration = True;
				}
			}
		} else if (Event.Type == CEditorPluginEvent::Type::MapModified) {
			MapModified();
		} else if (Event.Type == CEditorPluginEvent::Type::LayerCustomEvent) {
			declare Text[] Data;
			foreach (Value in Event.CustomEventData) Data.add(Value);
			UpdateUIInputBuffer(Event.CustomEventType, Data);
		}
	}

	foreach (Input in C_AutoRepeatEnabled) {
		if (!UI_MacroblockSelection::IsSelecting() && InputIsDown(Input)) {
			UpdateInputBuffer(Input);
		} else {
			G_AutoRepeatInput[Input] = 0;
		}
	}

	// Classic editor stop here
	if (IsEditor(C_Editor_Classic)) return;
	
// ------------------------------------------------------------------------------------------------------------------------ //
	
	// Play camera animations
	Camera::Loop();
	
	// Force cursor coordinates
	if (CursorCoord != G_ForcedCursorCoord) {
		CursorCoord = G_ForcedCursorCoord;
	}

	// Update platform
	declare Platform = UI_Tuto::GetPlatform();
	if (G_Platform != Platform) {
		G_Platform = Platform;
		CheckTuto();
	}

	// Block help
	if (UI_BlockHelp::CanBeVisible()) {
		// Force helper display when there are less than 5 blocks on the map
		if (
			IsEditor(C_Editor_Beginner) || 
			G_TestMode || 
			G_WaitingRerollAnswer ||
			(!IsEditor(C_Editor_Expert) && MapContent::Count() < 5)
		) {
			if (!UI_BlockHelp::IsVisible()) UI_BlockHelp::Show();
		} else {
			declare Activities = 
				PendingEvents.count > 0 || 
				G_InputBuffer.count > 0 || 
				G_UIInputBuffer.count > 0 ||
				IsEditor(C_Editor_Expert) && (
					UI_MacroblockSelection::IsSelecting() ||
					(UI_Tuto::IsVisible() && UI_Tuto::IsEnabled())
				);
				
			if (UI_BlockHelp::IsVisible()) {
				if (Activities) {
					UI_BlockHelp::Hide();
					G_InactivityStartTime = Now;
				}
			} else {
				if (Activities) {
					G_InactivityStartTime = Now;
				} else if (G_InactivityStartTime + C_Tick_BlockHelper <= Now) {
					UI_BlockHelp::Show();
					Sound::Play("EditorBlockHelp");
				}
			}
		}
	}
	
	// Force place and edit modes
	if (PlaceMode != G_PlaceMode) PlaceMode = G_PlaceMode;
	if (EditMode != G_EditMode) EditMode = G_EditMode;
	
	// Check if a pad is connected
	CheckPadConnection();
	
	// Stop random generation ?
	if (AskStopGeneration) {
		// Cancel random map
		if (G_CurrentSequence == C_Sequence_RandomMap) {
			RandomMenu();
		} 
		// Cancel auto-finish
		else {
			UI_PopUp::Confirm(
				//L16N [MapEditor] Title of the pop-up asking the player if he really wants to cancel the ongoing auto-finish process. The auto-finish is a function of the track editor that automatically place a finish block in an uncomplete track.
				_("Stop auto-finish"), 
				//L16N [MapEditor] Text of the pop-up asking the player if he really wants to cancel the ongoing auto-finish process. The auto-finish is a function of the track editor that automatically place a finish block in an uncomplete track.
				_("Do you want to stop the auto-finish?"), 
				//L16N [MapEditor] Confirm button in a pop-up
				_("Yes"), 
				//L16N [MapEditor] Cancel button in a pop-up
				_("No")
			);
		
			Sound::Play("EditorPopUp");
			
			while (UI_PopUp::Wait()) yield;
			
			// Clear input buffer
			ClearInputBuffer();
			G_TerrainCanPress = False;
			
			G_CancelGeneration = UI_PopUp::Answer();
		}
	}
}

// ---------------------------------- //
/// Sleep
Void Sleep(Integer _Duration) {
	declare EndTime = Now + _Duration;
	while (Now < EndTime) {
		Yield();
	}
}

// ---------------------------------- //
/// Wait for the editor to be ready
Void WaitReady() {
	while (!IsEditorReadyForRequest) Yield();
}

// ---------------------------------- //
/** Create a multilines Text from an array of messages
 *
 *	@param	_Messages				The messages to compose
 *
 *	@return							The multilines Text
 */
Text ComposeMultilines(Text[] _Messages) {
	if (_Messages.count <= 0) return "";
	
	declare ComposeMessage = "";
	for (I, 1, _Messages.count) {
		if (ComposeMessage != "") ComposeMessage ^= "\n";
		ComposeMessage ^= "%"^I;
	}
	
	declare Message = "";
	switch (_Messages.count) {
		case 1	: Message = TL::Compose(ComposeMessage, _Messages[0]);
		case 2	: Message = TL::Compose(ComposeMessage, _Messages[0], _Messages[1]);
		case 3	: Message = TL::Compose(ComposeMessage, _Messages[0], _Messages[1], _Messages[2]);
		case 4	: Message = TL::Compose(ComposeMessage, _Messages[0], _Messages[1], _Messages[2], _Messages[3]);
		default	: Message = TL::Compose(ComposeMessage, _Messages[0], _Messages[1], _Messages[2], _Messages[3], _Messages[4]);
	}
	
	return Message;
}

// ---------------------------------- //
/** Get the custom skin name of a block model
 *
 *	@param	_BlockModel				The BlockModel to check
 *	@param	_SkinIndex				The index of the skin
 *
 *	@return							The custom skin name
 */
Text GetSkinName(CBlockModel _BlockModel, Integer _SkinIndex) {
	return "|"^_SkinIndex^"|"^GetBlockModelSkinName(_BlockModel, _SkinIndex);
}

// ---------------------------------- //
/** Set the name of the map
 *
 *	@param	_MapName				The name of the map
 */
Void SetMapName(Text _MapName) {
	declare metadata Text PartyEditor_MapName for Map;
	PartyEditor_MapName = _MapName;
}

// ---------------------------------- //
/** Check if we are in a constrained editor mode
 *
 *	@return							True if we are in constrained editor mode, False otherwise
 */
Boolean IsSimpleEditor() {
	return (!S_RandomMap_Generate && (G_Setting_EditorLevel == C_Editor_Beginner || G_Setting_EditorLevel == C_Editor_Advanced));
}

// ---------------------------------- //
/** Check if we can display a notification in the cursor helper
 *
 *	@return							True if we can display a notification, False otherwise
 */
Boolean CanNotify() {
	return (
		!G_RebuildMap && (
			G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
			G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
			G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
			G_CurrentSequence == C_Sequence_PlaceStart ||
			G_CurrentSequence == C_Sequence_FreeMode ||
			G_CurrentSequence == C_Sequence_EditTerrain ||
			G_CurrentSequence == C_Sequence_EditDecoration
		)
	);
}

// ---------------------------------- //
/** Check if we have to check coppers limit
 *
 *	@return							True if we have to check the coppers limit, False otherwise
 */
Boolean MustCheckCoppersLimit() {
	return (
		!G_RandomMapGeneration &&
		!G_RebuildMap &&
		(
			G_CurrentSequence == C_Sequence_ConnectMode ||
			G_CurrentSequence == C_Sequence_FreeMode ||
			G_CurrentSequence == C_Sequence_EditTerrain ||
			G_CurrentSequence == C_Sequence_EditDecoration ||
			G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
			G_CurrentSequence == C_Sequence_Simple_MoveCursor
		)
	);
}

// ---------------------------------- //
/** Check if the map is terraformed
 *
 *	@return							True if the map is terraformed, False otherwise
 */
Boolean IsTerraformed() {
	if (!IsSimpleEditor() && !S_RandomMap_Generate) return True;
	
	declare metadata Boolean PartyEditor_IsTerraformed for Map;
	return PartyEditor_IsTerraformed;
}

// ---------------------------------- //
/** Check if the map is decorated in simple mode
 *
 *	@return							True if the map is decorated, False otherwise
 */
Boolean IsDecorated() {
	declare metadata Boolean PartyEditor_IsDecorated for Map;
	return PartyEditor_IsDecorated;
}

// ---------------------------------- //
/** Check if the decoration was confirmed
 *
 *	@return							True if the decoration was confirmed, False otherwise
 */
Boolean DecoConfirmed() {
	declare metadata Boolean PartyEditor_DecoConfirmed for Map;
	return PartyEditor_DecoConfirmed;
}

// ---------------------------------- //
/** Check if the editor is generating terrain
 *
 *	@return							True if the editor is generating terrain, False otherwise
 */
Boolean IsGeneratingTerrain() {
	return G_GeneratingTerrain;
}

// ---------------------------------- //
/** Save if the map has a custom terrain or not
 *
 *	@param	_Custom					True if the terrain is customized, False otherwise
 */
Void SetCustomTerrain(Boolean _Custom) {
	declare metadata Boolean PartyEditor_IsCustomTerrain for Map;
	PartyEditor_IsCustomTerrain = _Custom;
}

// ---------------------------------- //
/** Check if the terrain is customized
 *
 *	@return							True if the terrain is customized, False otherwise
 */
Boolean IsCustomTerrain() {
	declare metadata Boolean PartyEditor_IsCustomTerrain for Map;
	return PartyEditor_IsCustomTerrain;
}

// ---------------------------------- //
/** Check if the player is editing the terrain
 *
 *	@return							True if he's editing the terrain, False otherwise
 */
Boolean IsEditingTerrain() {
	return G_Mode == C_Modes_ConstructTerrain;
}

// ---------------------------------- //
/** Check if the player is placing a start
 *
 *	@return							True if he's placing a start, False otherwise
 */
Boolean IsPlacingStart() {
	return G_CurrentSequence == C_Sequence_PlaceStart || G_CurrentSequence == C_Sequence_Simple_PlaceStart;
}

// ---------------------------------- //
/** Check if the editor is generating decoration
 *
 *	@return							True if the editor is generating decoration, False otherwise
 */
Boolean IsGeneratingDecoration() {
	return G_GeneratingDecoration;
}

// ---------------------------------- //
/** Check if the player is editing the decoration
 *
 *	@return							True if the player is editing the decoration, False otherwise
 */
Boolean IsEditingDecoration() {
	return (G_Mode == C_Modes_ConstructDeco);
}

// ---------------------------------- //
/** Check if the editor is auto-finishing the track
 *
 *	@return							True if the editor is auto-finishing the track, False otherwise
 */
Boolean IsAutoFinishing() {
	return G_AutoFinishing;
}

// ---------------------------------- //
/** Check if the player is in free mode
 *
 *	@return							True if the player is in free mode, false otherwise
 */
Boolean IsFreeMode() {
	return (
		(!IsSimpleEditor() || (IsSimpleEditor() && G_MoveCursor)) && 
		!G_RandomMapGeneration && 
		G_Mode == C_Modes_ConstructTrack
	);
}

// ---------------------------------- //
/** Force a specific variant of block in free mode
 *
 *	@param	_Variant				Variant to force
 */
Void SetFreeModeVariant(Integer _Variant) {
	if (!Macroblock::VariantExists(_Variant)) return;
	
	G_FreeModeVariant = _Variant;
}

// ---------------------------------- //
/** Turn on or off the underground mode
 *	based on the selected macroblock model
 *
 *	@param	_MacroblockModel		The macroblock model
 */
Void SetUndergroundMode(CMacroblockModel _MacroblockModel) {
	declare Variant <=> Macroblock::GetBlockModelVariant(_MacroblockModel);
	if (Variant != Null) {
		UndergroundMode = Variant.IsAllUnderground;
	} else {
		UndergroundMode = False;
	}
}

// ---------------------------------- //
/** Can place a macroblock on the map
 *
 *	@param	_MacroblockModel		The macroblock model to place
 *	@param	_Coord					The coordinate of the macroblock
 *	@param	_Dir					The direction of the macroblock
 *	@param	_AllowTransition		Allow to use a transition if needed?
 */
Boolean CustomCanPlaceMacroblock(CMacroblockModel _MacroblockModel, Int3 _Coord, CEditorPlugin::CardinalDirections _Dir, Boolean _AllowTransition) {
	declare CanPlace = False;
	
	// Can we place macroblock directly ?
	CanPlace = CanPlaceMacroblock_NoTerrain(_MacroblockModel, _Coord, _Dir);
	// If not, check if we can place macroblock with a transition
	if (!CanPlace && _AllowTransition) CanPlace = Transitions::SearchTransitions(_MacroblockModel, _Coord, _Dir);
	// Allow terrain for some macroblocks
	if (!G_RandomMapGeneration && !IsAutoFinishing() && !CanPlace && ThemePack::CanPlaceTerrain(_MacroblockModel)) {
		CanPlace = CanPlaceMacroblock(_MacroblockModel, _Coord, _Dir);
	}
	
	// Random generator
	if ((G_RandomMapGeneration || IsGeneratingDecoration()) && CanPlace) {
		// If we can place the block normally, check if there's no collision with an existing custom collision block
		if (MapContent::HasCollisions()) {
			declare MacroblockUnitCoords = Macroblock::GetCoords(_MacroblockModel, _Coord, _Dir);
			declare CollisionsCoords = MapContent::GetCollisions();
			foreach (MacroblockUnitCoord in MacroblockUnitCoords) {
				if (CollisionsCoords.existskey(MacroblockUnitCoord)) {
					CanPlace = False;
					break;
				}
			}
		}
		// If the block we're trying to place has custom collision blocks, check that it doesn't collide with another block
		if (CanPlace && Macroblock::HasCollision(_MacroblockModel)) {
			declare MacroblockCollisionsCoords = Macroblock::GetCollisionsCoords(_MacroblockModel, _Coord, _Dir);
			declare TrackUnitCoords = MapContent::GetAllMacroblocksUnitsCoords();
			foreach (MacroblockCollisionCoord in MacroblockCollisionsCoords) {
				if (TrackUnitCoords.existskey(MacroblockCollisionCoord)) {
					CanPlace = False;
					break;
				}
			}
		}
	}
	
	return CanPlace;
}

// ---------------------------------- //
/** Get a new instance of the given macroblock instead of a possible reference
 *
 *	@param	_MacroblockModel		The macroblock model to get
 *
 *	@return							The new instance of macroblock model
 */
CMacroblockModel GetSafeMacroblockModel(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return Null;
	if (MacroblockModels.existskey(_MacroblockModel.Id)) return MacroblockModels[_MacroblockModel.Id];
	return Null;
}

// ---------------------------------- //
/** Set the cursor macroblock model
 *
 *	@param	_NewMacroblockModel		The new macroblock model
 *	@param	_TargetMacroblockModel	The macroblock model to restore when possible
 */
Void SetCursorMacroblockModel(CMacroblockModel _NewMacroblockModel, CMacroblockModel _TargetMacroblockModel) {
	CursorMacroblockModel = _NewMacroblockModel;
	G_CursorMacroblockModel = GetSafeMacroblockModel(_TargetMacroblockModel);
}
Void SetCursorMacroblockModel(CMacroblockModel _NewMacroblockModel) {
	CursorMacroblockModel = _NewMacroblockModel;
	G_CursorMacroblockModel = GetSafeMacroblockModel(_NewMacroblockModel);
}

// ---------------------------------- //
/// Check if we can give an advice to the player
Void CheckAdvices() {
	if (!IsSimpleEditor() || G_RebuildMap) return; //< No advices during map rebuild
	
	if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
		declare LastCheckpointDistance = MapContent::GetDistanceTo(MapContent::Block_Checkpoint());
		declare LastStopEngineDistance = MapContent::GetDistanceTo(MapContent::Block_StopEngine());
		
		if (G_MacroblocksCount <= 0) {
			//L16N [MapEditor] The family of blocks currently selected does not contain any block that can be connected to the previous one.
			UI_Header::SetTitle(_("Can't place any block from this family, try another one"), True, UI_Header::Status_Error());
		} else if (LastStopEngineDistance < LastCheckpointDistance) {
			//L16N [MapEditor] Warning displayed when the player place a special block in the track that stop the engine of the car until the it crosses a checkpoint.
			UI_Header::SetTitle(_("You can't accelerate until the next checkpoint"), True, UI_Header::Status_Alert());
		} else if (G_AvailableCheckpoint != NullId && LastCheckpointDistance > C_CheckpointGap) {
			//L16N [MapEditor] Warning displayed to encourage the player to place checkpoint blocks regularly in his map
			UI_Header::SetTitle(_("Try to place checkpoints regularly"), True, UI_Header::Status_Alert());
		} else {
			//L16N [MapEditor] Description of the action the player has to do
			UI_Header::SetTitle(_("Build your track"), True);
		}
	}
}

// ---------------------------------- //
/// Check the current progression of the player in the map creation process
Void CheckProgression() {
	if (IsEditor(C_Editor_Advanced) && !IsTerraformed()) {
		UI_Progression::SetStep(UI_Progression::Step_Landscape());
	} else if (!MapContent::HasStart()) {
		UI_Progression::SetStep(UI_Progression::Step_Start());
	} else if (
		(!MapContent::HasFinish() && !MapContent::HasMultilap()) || 
		(MapContent::HasMultilap() && !MapContent::HasCheckpoint())
	) {
		UI_Progression::SetStep(UI_Progression::Step_Track());
	} else if(IsEditor(C_Editor_Advanced) && !DecoConfirmed()) {
		UI_Progression::SetStep(UI_Progression::Step_Deco());
	} else if (ValidationStatus != CEditorPlugin::ValidationStatus::Validated) {
		UI_Progression::SetStep(UI_Progression::Step_Validation());
	} else if (Utils::GetSaveStatus() != Utils::SaveStatus_Saved()) {
		UI_Progression::SetStep(UI_Progression::Step_Save());
	} else {
		UI_Progression::SetStep(UI_Progression::Step_Complete());
	}
}

// ---------------------------------- //
/// Check which help to display in the helper
Void CheckHelper() {
	switch (G_CurrentSequence) {
		case C_Sequence_FreeMode: {
			declare BlockHelp = [
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: removing a block in the track.
				Buttons2::Editor_RemoveBlock() => _("Remove"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: launching a test race on the track.
				Buttons2::Editor_OpenTest() => _("Test"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: raising the block we are going to place.
				Buttons2::Editor_RaiseBlock() => _("Raise"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: lowering the block we are going to place.
				Buttons2::Editor_LowerBlock() => _("Lower"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: redoing the last undone action.
				Buttons2::Editor_Redo() => _("Redo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: undoing the last done action.
				Buttons2::Editor_Undo() => _("Undo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: navigating in the macroblock selection UI.
				Buttons2::Editor_BrowseBlocks() => _("Browse"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
				Buttons2::Editor_CameraMove() => _("Camera"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: changing the zoom level of the camera.
				Buttons2::Editor_CameraZoom() => _("Zoom")
			];
			if (G_IsEditing || G_IsSkinning) {
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: copying a block from the track and selecting it in the block selection UI.
				BlockHelp[Buttons2::Editor_CopyBlock()] = _("Copy");
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: connecting the currently selected block to the previous one.
				BlockHelp[Buttons2::Editor_AutoConnect()] = _("Connect");
			} else {
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the currently selected block.
				BlockHelp[Buttons2::Editor_TurnBlock()] = _("Rotate");
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: placing a block in the track.
				BlockHelp[Buttons2::Editor_PlaceBlock()] = _("Place");
			}
			UI_BlockHelp::SetOptions(BlockHelp);
		}
		case C_Sequence_EditDecoration: {
			declare BlockHelp = [
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: placing a block in the track.
				Buttons2::Editor_PlaceBlock() => _("Place"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: removing a block in the track.
				Buttons2::Editor_RemoveBlock() => _("Remove"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: raising the block we are going to place.
				Buttons2::Editor_RaiseBlock() => _("Raise"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: lowering the block we are going to place.
				Buttons2::Editor_LowerBlock() => _("Lower"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: redoing the last undone action.
				Buttons2::Editor_Redo() => _("Redo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: undoing the last done action.
				Buttons2::Editor_Undo() => _("Undo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: navigating in the macroblock selection UI.
				Buttons2::Editor_BrowseBlocks() => _("Browse"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
				Buttons2::Editor_CameraMove() => _("Camera"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: changing the zoom level of the camera.
				Buttons2::Editor_CameraZoom() => _("Zoom")
			];
			if (G_IsEditing || G_IsSkinning) {
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: copying a block from the track and selecting it in the block selection UI.
				BlockHelp[Buttons2::Editor_CopyBlock()] = _("Copy");
			} else {
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the currently selected block.
				BlockHelp[Buttons2::Editor_TurnBlock()] = _("Rotate");
			}
			//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: launching a test race on the track.
			if (MapContent::HasStart()) BlockHelp[Buttons2::Editor_OpenTest()] = _("Test");
			UI_BlockHelp::SetOptions(BlockHelp);
		}
	}
}

// ---------------------------------- //
/** Automatically select the right position for the UIs
 *
 *	@param	_Sequence				The started sequence
 */
Void CheckUIPosition(Integer _Sequence) {
	// Simple choice
	if (_Sequence == C_Sequence_Simple_Terraforming) {
		UI_SimpleChoice::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 1.>, Styles::CircleSize_Bottom()).Y);
	} else if (_Sequence == C_Sequence_Simple_Deco) {
		UI_SimpleChoice::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 1.>, Styles::CircleSize_Bottom()).Y);
	} else if (_Sequence == C_Sequence_RerollMap) {
		if (ManiaPlanet.HMD_IsActive) {
			UI_SimpleChoice::SetPositionY(Styles::Margin_Top() - Styles::GetSize2(<0., 10.>, Styles::CircleSize_Bottom()).Y);
		} else {
			UI_SimpleChoice::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 1.>, Styles::CircleSize_Bottom()).Y);
		}
	}
	
	// Spawn selection
	if (_Sequence == C_Sequence_TestMode) {
		UI_SpawnSelection::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 5.>, Styles::CircleSize_Bottom()).Y);
	} else if (_Sequence == C_Sequence_Simple_Test) {
		UI_SpawnSelection::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 5.>, Styles::CircleSize_Bottom()).Y);
	}
	
	// Style selection
	if (_Sequence == C_Sequence_Simple_Terraforming) {
		UI_StyleSelection::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 2.>, Styles::CircleSize_Bottom()).Y);
	} else {
		UI_StyleSelection::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 6.>, Styles::CircleSize_Bottom()).Y);
	}
	
	// Progression
	if (_Sequence == C_Sequence_Simple_Outro) {
		declare FullHeaderSizeX = Styles::GetHeaderSize2() + 4.;
		declare PosX = (FullHeaderSizeX - 36.) - (FullHeaderSizeX * 0.5) + (36. * 0.5);
		UI_Progression::SetPosition(<0., Styles::Margin_Bottom()> + Styles::GetSize2(<PosX, 8.>, Styles::CircleSize_Bottom()));
	} else if (IsEditor(C_Editor_Expert)) {
		UI_Progression::SetPosition(Styles::GetSize2(<0., -2.>, Styles::CircleSize_Bottom()));
	} else {
		UI_Progression::SetPosition(Styles::GetSize2(<0., 0.>, Styles::CircleSize_Bottom()));
	}
	
	// Header
	if (IsEditor(C_Editor_Beginner)) {
		if (_Sequence == C_Sequence_Simple_Outro) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 9.>, Styles::CircleSize_Bottom()).Y);
		} else {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 5.>, Styles::CircleSize_Bottom()).Y);
		}
	} else if (IsEditor(C_Editor_Advanced)) {
		if (_Sequence == C_Sequence_Simple_Test) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 4.>, Styles::CircleSize_Bottom()).Y);
		} else if (_Sequence == C_Sequence_Simple_Terraforming) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 3.>, Styles::CircleSize_Bottom()).Y);
		} else if (_Sequence == C_Sequence_Simple_Deco) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 4.>, Styles::CircleSize_Bottom()).Y);
		} else if (_Sequence == C_Sequence_Simple_Outro) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 9.>, Styles::CircleSize_Bottom()).Y);
		} else {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 7.>, Styles::CircleSize_Bottom()).Y);
		}
	} else {
		if (_Sequence == C_Sequence_RerollMap) {
			if (ManiaPlanet.HMD_IsActive) {
				UI_Header::SetPositionY(Styles::Margin_Top());
			} else {
				UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 2.>, Styles::CircleSize_Bottom()).Y);
			}
		} else if (_Sequence == C_Sequence_TestMode) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 7.>, Styles::CircleSize_Bottom()).Y);
		} else if (G_IsSkinning && _Sequence != C_Sequence_EditTerrain) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 6.>, Styles::CircleSize_Bottom()).Y);
		} else {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 2.>, Styles::CircleSize_Bottom()).Y);
		}
	}
}

// ---------------------------------- //
/** Get the coordinates of the edited block units
 *
 *	@param	_Coord					The coordinates to check
 */
Int3[] GetEditedBlockUnits(Int3 _Coord) {
	declare CMacroblockModel SkinMacroblockModel;
	declare Int3 SkinMacroblockCoord;
	declare CEditorPlugin::CardinalDirections SkinMacroblockDir;
	declare SkinMacroblockMode = -1;
	declare MacroblockFound = False;
	declare SkinMacroblockKey = MapContent::GetMacroblockKey(G_CursorMacroblockModel, CursorCoord, CursorDir);
	if (SkinMacroblockKey >= 0) {
		SkinMacroblockModel <=> MapContent::GetMacroblockModel(SkinMacroblockKey);
		SkinMacroblockCoord = MapContent::GetMacroblockCoord(SkinMacroblockKey);
		SkinMacroblockDir = MapContent::GetMacroblockDir(SkinMacroblockKey);
		SkinMacroblockMode = MapContent::GetMacroblockType(SkinMacroblockKey);
		MacroblockFound = True;
	} else if (MapContent::Exists(_Coord)) {
		SkinMacroblockModel <=> MapContent::GetMacroblockModel(_Coord);
		SkinMacroblockCoord = MapContent::GetMacroblockCoord(_Coord);
		SkinMacroblockDir = MapContent::GetMacroblockDir(_Coord);
		SkinMacroblockMode = MapContent::GetMacroblockType(_Coord);
		MacroblockFound = True;
	}
	
	if (MacroblockFound && (SkinMacroblockMode == C_Modes_ConstructTrack || SkinMacroblockMode == C_Modes_ConstructDeco)) {
		// When the macroblock in the cursor is in the same direction that the macroblock we're trying to edit
		// then colliding is not enough to edit, both must also be in the same position to avoid confusion
		if (
			(
				SkinMacroblockModel == G_CursorMacroblockModel && SkinMacroblockCoord == CursorCoord && SkinMacroblockDir == CursorDir
			) || (
				Macroblock::Collide(
					SkinMacroblockModel, SkinMacroblockCoord, SkinMacroblockDir,
					G_CursorMacroblockModel, CursorCoord, CursorDir
				) && (
					SkinMacroblockModel != G_CursorMacroblockModel || SkinMacroblockDir != CursorDir
				)
			)
		) {
			if (SkinMacroblockModel != Null) {
				declare PartyEditor_TutoEditCopy for This = False;
				PartyEditor_TutoEditCopy = !SkinMacroblockModel.HasStart && !SkinMacroblockModel.HasMultilap;
			}
			
			return Macroblock::GetCoords(SkinMacroblockModel, SkinMacroblockCoord, SkinMacroblockDir);
		}
	}
	
	return Int3[];
}

// ---------------------------------- //
/** Hide or show the skin selection UI for a given coordinate
 *
 *	@param	_Coord					The coordinates to use
 */
Void DisplaySkinSelection(Int3 _Coord) {
	G_IsSkinning = False;
		
	if (IsSimpleEditor()) return;
	if (
		G_CurrentSequence != C_Sequence_FreeMode &&
		G_CurrentSequence != C_Sequence_PlaceStart &&
		G_CurrentSequence != C_Sequence_EditDecoration
	) return;
	
	UI_SkinSelection::CancelPreview();
	
	declare IsSkinnable = False;
	declare Int3 SkinBlockUnitCoord;
	declare Int3[] BlockUnitsCoords = GetEditedBlockUnits(_Coord);
	foreach (Coord in BlockUnitsCoords) {
		declare Block <=> GetBlock(Coord);
		if (UI_SkinSelection::IsSkinnable(Block)) {
			SkinBlockUnitCoord = Coord;
			IsSkinnable = True;
			break;
		}
	}
	
	if (IsSkinnable) {
		G_IsSkinning = True;
		UI_SkinSelection::SetBlockCoord(SkinBlockUnitCoord);
		if (!UI_SkinSelection::IsVisible()) {
			UI_SkinSelection::Show();
			UI_MacroblockSelection::Hide();
			SetCursorMacroblockModel(Null, G_CursorMacroblockModel);
		}
		CustomSelectionCoords.clear();
		foreach (BlockCoord in BlockUnitsCoords) {
			CustomSelectionCoords.add(BlockCoord);
		}
		CustomSelectionRGB = <0.1, 0.1, 0.1>;
	} else {
		G_IsSkinning = False;
		if (UI_SkinSelection::IsVisible()) {
			UI_SkinSelection::Hide();
			UI_MacroblockSelection::Show();
			SetCursorMacroblockModel(G_CursorMacroblockModel);
		}
	}
	
	CheckUIPosition(G_CurrentSequence);
}

// ---------------------------------- //
/// Set the style of the cursor
Void SetCursorStyle() {
	G_IsEditing = False;
	
	if (G_IsSkinning) {
		CursorBrightnessFactor = 1.;
		return;
	}
	
	declare CanPlaceTerrain = False;
	
	if (G_CurrentSequence == C_Sequence_EditDecoration || G_CurrentSequence == C_Sequence_FreeMode) {
		CustomSelectionCoords.clear();
		
		declare BlockUnitsCoords = GetEditedBlockUnits(CursorCoord);
		if (BlockUnitsCoords.count > 0) {
			foreach (BlockUnitCoord in BlockUnitsCoords) {
				CustomSelectionCoords.add(BlockUnitCoord);
			}
			CustomSelectionRGB = <0.1, 0.1, 0.1>;
			G_IsEditing = True;
			SetCursorMacroblockModel(Null, G_CursorMacroblockModel);
		}
		
		if (!G_IsEditing) {
			if (!CustomCanPlaceMacroblock(CursorMacroblockModel, CursorCoord, CursorDir, True)) {
				declare BlockUnitCoords = Macroblock::GetCoords(CursorMacroblockModel, CursorCoord, CursorDir);
				foreach (BlockUnitCoord in BlockUnitCoords) {
					CustomSelectionCoords.add(BlockUnitCoord);
				}
				CustomSelectionRGB = <0.7, 0., 0.>;
			} else {
				SetCursorMacroblockModel(G_CursorMacroblockModel);
				CanPlaceTerrain = ThemePack::CanPlaceTerrain(CursorMacroblockModel);
			}
		}
	} else if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
		CustomSelectionCoords.clear();
		
		// At least one macroblock can be connected
		if (G_MacroblocksCount > 0) {
			// There are several clips available, display them
			if (G_AvailableConnectors.count > 1) {
				CustomSelectionRGB = <0.3, 0.3, 0.3>;
				declare PrevMacroblock <=> MapContent::GetMacroblockModel(G_FilteringCoord);
				declare PrevMacroblockCoord = MapContent::GetMacroblockCoord(G_FilteringCoord);
				declare PrevMacroblockDir = MapContent::GetMacroblockDir(G_FilteringCoord);
				foreach (Connector in G_AvailableConnectors) {
					if (Connector == G_CursorConnectedTo) continue;
					
					declare Coord = Macroblock::GetClipCoord(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir, Connector);
					if (Coord != Utils::NullCoord()) CustomSelectionCoords.add(Coord);
				}
			}
		} 
		// No macroblock can be connected
		else {
			// Display the clips that can't be connected
			CustomSelectionRGB = <0.7, 0., 0.>;
			declare PrevMacroblock <=> MapContent::GetMacroblockModel(G_FilteringCoord);
			declare PrevMacroblockCoord = MapContent::GetMacroblockCoord(G_FilteringCoord);
			declare PrevMacroblockDir = MapContent::GetMacroblockDir(G_FilteringCoord);
			declare PrevClipsDisconnected = MapContent::GetDisconnectedClips(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir);
			
			if (PrevClipsDisconnected.count > 0) {
				declare PrevClipCoords = Macroblock::GetClipCoords(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir);
				
				declare Count = 0;
				declare Total = <0, 0, 0>;
				foreach (PrevClipId in PrevClipsDisconnected) {
					if (!PrevClipCoords.existskey(PrevClipId)) continue;
					CustomSelectionCoords.add(PrevClipCoords[PrevClipId]);
					Count += 1;
					Total += PrevClipCoords[PrevClipId];
				}
				
				Camera::MoveTo(<Total.X / Count, Total.Y / Count, Total.Z / Count>);
			}
			
			SetUndergroundMode(PrevMacroblock);
		}
	} 
	// Can't place start block
	else if (
		G_CurrentSequence == C_Sequence_PlaceStart ||
		G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor
	) {
		CustomSelectionCoords.clear();
		
		if (!CustomCanPlaceMacroblock(CursorMacroblockModel, CursorCoord, CursorDir, True)) {
			declare BlockUnitCoords = Macroblock::GetCoords(CursorMacroblockModel, CursorCoord, CursorDir);
			foreach (BlockUnitCoord in BlockUnitCoords) {
				CustomSelectionCoords.add(BlockUnitCoord);
			}
			CustomSelectionRGB = <0.7, 0., 0.>;
		}
	} 
	// Special case for lagoon water
	else if (
		G_CurrentSequence == C_Sequence_EditTerrain &&
		!Selection::IsSelecting() &&
		Terrain::IsUndergroundTerrain(CursorTerrainBlockModel)
	) {
		CustomSelectionCoords.clear();
		CustomSelectionCoords.add(CursorCoord);
		CustomSelectionRGB = <0., 0.1, 0.>;
	} else {
		CustomSelectionCoords.clear();
	}
	
	// Enable box helper when creating terrain in advance mode
	if (G_CurrentSequence == C_Sequence_EditTerrain) {
		CursorBrightnessFactor = 1.;
	} else if (G_IsEditing) {
		CursorBrightnessFactor = 1.;
	} else if (CanPlaceTerrain) {
		CursorBrightnessFactor = 1.;
	} else {
		CursorBrightnessFactor = C_CursorVisibility;
	}
}

// ---------------------------------- //
/** Sanitize the cursor coord
 *
 *	@param	_Coord					The coord to sanitize
 *
 *	@return							The sanitized coord
 */
Int3 SanitizeCursorCoord(Int3 _Coord) {
	declare NewCursorCoord = _Coord;
	if (NewCursorCoord.X < 0) NewCursorCoord.X = 0;
	if (NewCursorCoord.X > Map.Size.X-1) NewCursorCoord.X = Map.Size.X-1;
	if (NewCursorCoord.Y < 0) NewCursorCoord.Y = 0;
	if (NewCursorCoord.Y > Map.Size.Y-1) NewCursorCoord.Y = Map.Size.Y-1;
	if (NewCursorCoord.Z < 0) NewCursorCoord.Z = 0;
	if (NewCursorCoord.Z > Map.Size.Z-1) NewCursorCoord.Z = Map.Size.Z-1;
	
	return NewCursorCoord;
}

// ---------------------------------- //
/** Set the cursor coord
 *
 *	@param	_NewCoord				The new cursor coord
 *	@param	_TargetCursorCoord		The coord to restore when possible
 */
Void SetCursorCoord(Int3 _NewCoord, Int3 _TargetCursorCoord) {
	CursorCoord = SanitizeCursorCoord(_NewCoord);
	G_CursorCoord = SanitizeCursorCoord(_TargetCursorCoord);
	G_ForcedCursorCoord = CursorCoord;
	DisplaySkinSelection(CursorCoord);
	SetCursorStyle();
	CheckTuto();
	CheckHelper();
}
Void SetCursorCoord(Int3 _NewCoord) {
	CursorCoord = SanitizeCursorCoord(_NewCoord);
	G_CursorCoord = CursorCoord;
	G_ForcedCursorCoord = CursorCoord;
	DisplaySkinSelection(CursorCoord);
	SetCursorStyle();
	CheckTuto();
	CheckHelper();
}

// ---------------------------------- //
/** Set the cursor dir
 *
 *	@param	_NewDir					The new cursor dir
 *	@param	_TargetDir				The dir to restore when possible
 */
Void SetCursorDir(CEditorPlugin::CardinalDirections _NewDir, CEditorPlugin::CardinalDirections _TargetDir) {
	CursorDir = _NewDir;
	G_CursorDir = _TargetDir;
	SetCursorStyle();
}
Void SetCursorDir(CEditorPlugin::CardinalDirections _NewDir) {
	CursorDir = _NewDir;
	G_CursorDir = CursorDir;
	SetCursorStyle();
}

// ---------------------------------- //
/** Get the list of the available decoration macroblocks sorted by type
 *
 *	@param	_Random					True if we should only allow macroblocks for random generation
 *
 *	@return							An array with the decoration macroblocks and their type
 */
CMacroblockModel[][Text] GetDecorationMacroblocks(Boolean _Random) {
	declare CMacroblockModel[][Text] DecorationMacroblocks;
	
	foreach (MacroblockModel in MacroblockModels) {
		if (!Macroblock::GetValidity(MacroblockModel)) continue;
		if (_Random && ThemePack::IsRandomDisabled(MacroblockModel)) continue;
		
		if (!Macroblock::IsSimpleDeco(MacroblockModel)) continue;
		
		declare Type = "|Decoration|"^Macroblock::GetType(MacroblockModel);
		if (!DecorationMacroblocks.existskey(Type)) {
			DecorationMacroblocks[Type] = CMacroblockModel[];
		}
		if (!DecorationMacroblocks[Type].exists(MacroblockModel)) {
			DecorationMacroblocks[Type].add(MacroblockModel);
		}
	}
	
	return DecorationMacroblocks;
}

// ---------------------------------- //
/** Get the recently used macroblocks
 *
 *	@return							An array containing the recentrly used maroblocks if any
 */
Text[] GetRecentMacroblocks() {
	return G_RecentMacroblocks;
}

// ---------------------------------- //
/** Get the favorite macroblocks for the current collection
 *
 *	@return							An array containing the favorite maroblocks if any
 */
Text[] GetFavoriteMacroblocks() {
	declare persistent Text[][Text] PartyEditor_FavoriteMacroblocks2 for LocalUser;
	if (!PartyEditor_FavoriteMacroblocks2.existskey(Map.CollectionName)) return Text[];
	
	return PartyEditor_FavoriteMacroblocks2[Map.CollectionName];
}

// ---------------------------------- //
/** Send the blocks list to the UI
 *
 *	@param	_BlocksList				The blocks list
 */
Void SendMacroblockList(CMacroblockModel[][Text] _BlocksList) {
	declare Ident[][Text] MacroblockModelsIds;
	declare Integer[][Text] Placements;
	declare Boolean[][Text] Availabilities;

	foreach (Family => Macroblocks in _BlocksList) {
		// Optim : don't MacroblockModelFamilies[Family].add(value), it cost more
		// Instead first create an array with the values, then MacroblockModelFamilies[Family] = [Values];
		declare MacroblocksIds = Ident[];
		declare MacroblocksPlacements = Integer[];
		declare MacroblocksAvailabilities = Boolean[];
		foreach (MacroblockModel in Macroblocks) {
			if (IsSimpleEditor() && !IsPlacingStart()) {
				if (IsFreeMode()) {
					MacroblocksIds.add(MacroblockModel.Id);
					MacroblocksPlacements.add(-1);
					MacroblocksAvailabilities.add(True);
				} else {
					declare Integer[] FoundConnectedBy;
					declare BlockConnectedTo = Placement::GetConnectedToClips(MacroblockModel);
					foreach (Placement => BlockConnectedTo in BlockConnectedTo) {
						if (G_CursorConnectedTo != -1 && BlockConnectedTo != G_CursorConnectedTo) continue;
						
						declare BlockConnectedBy = Placement::GetConnectedByClip(MacroblockModel, Placement);
						if (FoundConnectedBy.exists(BlockConnectedBy)) continue;
						FoundConnectedBy.add(BlockConnectedBy);
						
						MacroblocksIds.add(MacroblockModel.Id);
						MacroblocksPlacements.add(Placement);
						MacroblocksAvailabilities.add(True);
					}
					if (BlockConnectedTo.count <= 0) {
						MacroblocksIds.add(MacroblockModel.Id);
						MacroblocksPlacements.add(-1);
						MacroblocksAvailabilities.add(False);
					}
				}
			} else {
				declare BlockConnectedTo = Placement::GetConnectedToClips(MacroblockModel);
				MacroblocksIds.add(MacroblockModel.Id);
				MacroblocksPlacements.add(-1);
				MacroblocksAvailabilities.add(BlockConnectedTo.exists(0));
			}
		}
		
		MacroblockModelsIds[Family] = MacroblocksIds;
		Placements[Family] = MacroblocksPlacements;
		Availabilities[Family] = MacroblocksAvailabilities;
	}
	
	UI_MacroblockSelection::SetFamiliesAndMacroblocks(MacroblockModelsIds, Placements, Availabilities);
}

// ---------------------------------- //
/** Get a list of macroblocks sorted by categories
 *
 *	@param	_MacroblockModels		The macroblocks to sort
 *	@param	_Terrain				Sort terrains or normal building macroblock
 *
 *	@return							An array of macroblocks sorted by categories
 */
CMacroblockModel[][Text] SortMacroblocks(CMacroblockModel[] _MacroblockModels, Boolean _Terrain) {
	declare AvailableMacroblocks = _MacroblockModels;
	declare CMacroblockModel[][Text] SortedMacroblocks;
	
	// Add all categories
	if (!_Terrain) {
		declare Categories = ThemePack::GetAllCategories();
		foreach (Category in Categories) {
			SortedMacroblocks[Category] = CMacroblockModel[];
		}
	}
	
	// Sort the macroblocks in the same order as the theme pack file
	declare CMacroblockModel[] OrderedMacroblocks;
	declare Integer[Integer] OrderedIndexes;
	foreach (Index => MacroblockModel in AvailableMacroblocks) {
		OrderedIndexes[Index] = ThemePack::GetOrder(MacroblockModel);
	}
	OrderedIndexes = OrderedIndexes.sort();
	foreach (Index => Order in OrderedIndexes) {
		OrderedMacroblocks.add(AvailableMacroblocks[Index]);
	}
	AvailableMacroblocks = OrderedMacroblocks;
	
	// Clean unavailable macroblocks
	foreach (MacroblockModel in AvailableMacroblocks) {
		declare FullName = Macroblock::GetFullName(MacroblockModel);
		while (G_DiscardedMacroblocks.exists(FullName)) {
			declare Removed = G_DiscardedMacroblocks.remove(FullName);
		}
	}
	
	foreach (MacroblockModel => MacroblockFullName in G_DiscardedMacroblocks) {
		AvailableMacroblocks.add(MacroblockModel);
	}

	foreach (MacroblockModel in AvailableMacroblocks) {
		declare Category = "";
		if (_Terrain) {
			//L16N [MapEditor] Name of a blocks category that contains terrain blocks (hill, cliff, canyon, river, ...)
			Category = _("Terrain");
		} else {
			Category = ThemePack::GetCategory(MacroblockModel);
		}
		if (!SortedMacroblocks.existskey(Category)) SortedMacroblocks[Category] = CMacroblockModel[];
		SortedMacroblocks[Category].add(MacroblockModel);
	}
	
	return SortedMacroblocks;
}

// ---------------------------------- //
/** Get a list of macroblocks filtered by different params
 *
 *	@param	_ForceConnectedMode		Force the algorithm to use the connected mode
 */
CMacroblockModel[] FilterMacroblocks2(Boolean _ForceConnectedMode) {
	declare CMacroblockModel[] Result;
	Transitions::ClearAllTransitions();
	declare NextTick = C_Tick_FilterMacroblock;
	
	// ---------------------------------- //
	// Editing and building
	// Add all macroblocks
	if (!_ForceConnectedMode && (IsFreeMode() || IsPlacingStart() || IsEditingDecoration())) {
		// Save filtering coordinates
		G_FilteringCoord = CursorCoord;
		
		// Update cursor connected to 
		G_CursorConnectedTo = -1;
		
		declare IsPlacingStart = IsPlacingStart();
		declare IsEditingDecoration = IsEditingDecoration();
		
		declare CMacroblockModel[] AvailableMacroblockModels;
		if (G_RandomMapGeneration) {
			AvailableMacroblockModels = G_RandomMacroblocks;
		} else {
			AvailableMacroblockModels = ThemePack::GetMacroblockModels();
		}
		foreach (MacroblockModel in AvailableMacroblockModels) {
		//foreach (MacroblockModel in MacroblockModels) {
			// Skip not valid macroblock
			if (IsPlacingStart && !MacroblockModel.HasStart && !MacroblockModel.HasMultilap) continue;
			else if (!IsPlacingStart && (MacroblockModel.HasStart || MacroblockModel.HasMultilap)) continue;
			if (!Macroblock::GetValidity(MacroblockModel)) continue;
			if (Macroblock::IsTerrain(MacroblockModel)) continue;
			if (!IsEditingDecoration && Macroblock::IsDeco(MacroblockModel)) continue;
			if (!ThemePack::IsListed(MacroblockModel)) continue;
			if (!G_RandomMapGeneration && !ThemePack::IsAvailable(MacroblockModel)) continue;
			
			// Reduce script load
			NextTick -= 1;
			if (NextTick <= 0) {
				NextTick = C_Tick_FilterMacroblock;
				Yield();
			}
			
			// Force a mode variant
			if (G_FreeModeVariant != Macroblock::VariantNull() && Macroblock::VariantExists(G_FreeModeVariant)) {
				if (
					Macroblock::HasVariant(MacroblockModel, G_FreeModeVariant) && 
					Macroblock::GetVariant(MacroblockModel) != G_FreeModeVariant
				) continue;
			}
			
			// Add all macroblocks
			declare ValidPlacement = -1;
			Placement::Clear(MacroblockModel);
			for (Dir, 0, 3) {
				// Always allow start placement
				if (IsPlacingStart || CustomCanPlaceMacroblock(MacroblockModel, CursorCoord, Utils::IntToDir(Dir), False)) { ///< Don't check for transition here, we will do it in Move() and PreviewMacroblock() anyway
					ValidPlacement = Placement::Count(MacroblockModel)-1;
					Placement::Add(MacroblockModel, CursorCoord, Utils::IntToDir(Dir), 0, 0);
				} else {
					Placement::Add(MacroblockModel, CursorCoord, Utils::IntToDir(Dir), -1, -1);
				}
			}
			
			// Select default placement
			if (Placement::Count(MacroblockModel) > 0) {
				declare BlockDirs = Placement::GetDirs(MacroblockModel);
				if (ValidPlacement >= 0) {
					Placement::Select(MacroblockModel, ValidPlacement);
				} else if (BlockDirs.exists(CursorDir)) Placement::Select(MacroblockModel, BlockDirs.keyof(CursorDir));
				else Placement::Select(MacroblockModel, 0);
				
				Result.add(MacroblockModel);
			}
		}
	}
	// ---------------------------------- //
	// Filter macroblocks
	else {
		// ---------------------------------- //
		// Building
		// Check that the next macroblock can be connected to the previous one
		// Save filtering coord
		G_FilteringCoord = G_CursorCoord;
		G_DiscardedMacroblocks.clear();
		
		// Get the macroblock at the current cursor coordinates
		declare MacroblocksDirties = True;
		declare PrevMacroblock <=> MapContent::GetMacroblockModel(G_CursorCoord);
		declare PrevMacroblockCoord = MapContent::GetMacroblockCoord(G_CursorCoord);
		declare PrevMacroblockDir = MapContent::GetMacroblockDir(G_CursorCoord);
		declare PrevClipsDisconnected = MapContent::GetDisconnectedClips(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir);
		
		LogRandomMap("FilterMacroblocks2() > MB : "^PrevMacroblock^" | Coord : "^PrevMacroblockCoord^" | Dir : "^PrevMacroblockDir);
		
		// Find clip used to connect the previous macroblock to the one before
		declare PrevConnectionToPrevious = MapContent::GetConnectionToPrevious(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir);
		declare PrevConnection = PrevConnectionToPrevious[1];
		declare PrevConnectionDir = CEditorPlugin::CardinalDirections::North;
		if (PrevConnection >= 0) {
			PrevConnectionDir = MU::AddDirs(PrevMacroblockDir, Macroblock::GetClipDir(PrevMacroblock, PrevConnection));
		}
		
		// Update connectors
		G_CursorConnectedTo = -1;
		G_AvailableConnectors.clear();
		G_AvailableCheckpoint = NullId;
		
		declare CMacroblockModel[] AvailableMacroblockModels;
		if (G_RandomMapGeneration) {
			AvailableMacroblockModels = G_RandomMacroblocks;
		} else {
			AvailableMacroblockModels = ThemePack::GetMacroblockModels();
		}
		
		if (PrevClipsDisconnected.count > 0) {
			// Valid data for the next macroblock
			declare PrevClipCoords = Macroblock::GetClipCoords(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir);
			declare PrevClipNames = Macroblock::GetClipNames(PrevMacroblock);
			declare PrevClipDirs = Macroblock::GetClipDirs(PrevMacroblock, PrevMacroblockDir);
			
			foreach (PrevClipId in PrevClipsDisconnected) {
				if (
					!PrevClipCoords.existskey(PrevClipId) || 
					!PrevClipNames.existskey(PrevClipId) || 
					!PrevClipDirs.existskey(PrevClipId)
				) continue;
				declare ValidClipDir = MU::GetOpposedDir(PrevClipDirs[PrevClipId]);
				declare ValidClipCoord = MU::GetNeighbourCoord(PrevClipCoords[PrevClipId], ValidClipDir);
				declare ValidClipNames = Macroblock::GetConnectableClips(PrevClipNames[PrevClipId]);
				
				foreach (NextMacroblockModel in AvailableMacroblockModels) {
				//foreach (NextMacroblockModel in MacroblockModels) {
					// Initialize macroblock placements properties
					if (MacroblocksDirties) {
						Placement::Clear(NextMacroblockModel);
					}
					// Skip not valid macroblock
					if (!ThemePack::IsListed(NextMacroblockModel)) continue;
					if (NextMacroblockModel.HasStart || NextMacroblockModel.HasMultilap) continue;
					if (!Macroblock::GetValidity(NextMacroblockModel)) continue;
					if (Macroblock::IsDeco(NextMacroblockModel) || Macroblock::IsTerrain(NextMacroblockModel)) continue;
					if (!G_RandomMapGeneration && !ThemePack::IsAvailable(NextMacroblockModel)) continue;
					// Reduce script load
					NextTick -= 1;
					if (NextTick <= 0) {
						NextTick = C_Tick_FilterMacroblock;
						Yield();
					}
					
					// Get variant
					declare NextVariant <=> Macroblock::GetBlockModelVariant(NextMacroblockModel);
					if (NextVariant == Null) continue;
					
					// Data of the next macroblock
					declare NextClipNames = Macroblock::GetClipNames(NextMacroblockModel);
					declare NextClipOffsets = Macroblock::GetClipOffsets(NextMacroblockModel);
					declare NextClipDirs = Macroblock::GetClipDirs(NextMacroblockModel);
					
					// Save the new placements
					declare NewPlacements = Integer[];
					
					foreach (NextClipId => NextClipName in NextClipNames) {
						// Skip -out clip, we can't use them to connect the next macroblock
						if (Macroblock::IsOutClip(NextClipName)) continue;
						
						// Skip clips that can't be connected
						if (!ValidClipNames.exists(NextClipName)) continue;
						
						// Determine next block coord and dir
						if (!NextClipOffsets.existskey(NextClipId) || !NextClipDirs.existskey(NextClipId)) continue;
						declare NextBlockDir = MU::SubDirs(ValidClipDir, NextClipDirs[NextClipId]);
						declare NextBlockCoord = ValidClipCoord - MU::GetRotatedOffsetPositive(NextClipOffsets[NextClipId], NextBlockDir, NextVariant.Size);
						
						// Skip macroblock that can't be placed and have no transition
						if (!CustomCanPlaceMacroblock(NextMacroblockModel, NextBlockCoord, NextBlockDir, True)) {
							declare NextFullName = Macroblock::GetFullName(NextMacroblockModel);
							if (!G_DiscardedMacroblocks.exists(NextFullName)) {
								G_DiscardedMacroblocks[NextMacroblockModel] = NextFullName;
							}
							continue;
						}
						
						// Add them to the possible placements for the next macroblock
						Placement::Add(NextMacroblockModel, NextBlockCoord, NextBlockDir, NextClipId, PrevClipId);
						
						// Save the new placements
						NewPlacements.add(Placement::Count(NextMacroblockModel) - 1);
					}
					
					// Select default placement and add macroblock to the result
					if (Placement::Count(NextMacroblockModel) > 0) {
						declare PlacementSelected = False;
						
						// Try to orient special macroblock (checkpoint, turbo) in the right direction
						if (
							(Macroblock::IsOriented(NextMacroblockModel) && !ThemePack::NoRespawn(NextMacroblockModel)) ||
							ThemePack::IsOriented(NextMacroblockModel)
						) {
							declare TargetDir = MU::GetOpposedDir(ValidClipDir);
							declare Oriented = False;
							declare BlockDirs = Placement::GetDirs(NextMacroblockModel);
							foreach (Placement => Dir in BlockDirs) {
								if (Dir == TargetDir) {
									Placement::Select(NextMacroblockModel, Placement);
									PlacementSelected = True;
									Oriented = True;
									break;
								}
							}
							
							// Remove oriented blocks that can't be placed
							// in the right direction
							if (!Oriented) {
								declare Shift = 0;
								foreach (Placement in NewPlacements) {
									Placement::Remove(NextMacroblockModel, Placement - Shift);
									Shift += 1;
								}
							}
							// Remove incorrect orientation on blocks that can be placed
							// in the right direction
							else {
								declare Shift = 0;
								foreach (Placement in NewPlacements) {
									if (Placement::GetPlacement(NextMacroblockModel) == Placement - Shift) continue;
									Placement::Remove(NextMacroblockModel, Placement - Shift);
									Shift += 1;
								}
							}
						} 
						// Try to keep the same orientation than the previous block
						else if (ThemePack::IsSymmetrical(NextMacroblockModel)) {
							declare AlreadyConnectedTo = Integer[];
							declare ConnectedTo = Placement::GetConnectedToClips(NextMacroblockModel);
							declare Shift = 0;
							foreach (Placement => ClipId in ConnectedTo) {
								if (AlreadyConnectedTo.exists(ClipId)) {
									Placement::Remove(NextMacroblockModel, Placement - Shift);
									Shift += 1;
								} else {
									AlreadyConnectedTo.add(ClipId);
								}
							}
						}
						// Repeat the orientation of the previous block if it's the same
						else if (PrevMacroblock != Null && NextMacroblockModel.Id == PrevMacroblock.Id) {
							declare BlockDirs = Placement::GetDirs(NextMacroblockModel);
							declare MinAngle = -1.;
							foreach (Placement => Dir in BlockDirs) {
								declare Angle = ML::Abs(ML::Angle(Utils::DirToVec3(PrevMacroblockDir), Utils::DirToVec3(Dir)));
								if (MinAngle == -1. || Angle < MinAngle) {
									Placement::Select(NextMacroblockModel, Placement);
									PlacementSelected = True;
									MinAngle = Angle;
								}
							}
						}
						
						// Try to keep the same track orientation
						if (!PlacementSelected) {
							// Default orientation
							Placement::Select(NextMacroblockModel, 0);
							
							if (PrevConnection >= 0) {
								declare NextPlacementConnectedByClips = Placement::GetConnectedByClips(NextMacroblockModel);
								declare NextPlacementConnectedToClips = Placement::GetConnectedToClips(NextMacroblockModel);
								declare NextPlacementDirs = Placement::GetDirs(NextMacroblockModel);
								foreach (Placement => ClipId in NextPlacementConnectedByClips) {
									declare PlacementClipDir = MU::AddDirs(Macroblock::GetClipDir(NextMacroblockModel, ClipId), NextPlacementDirs[Placement]);
									if (PlacementClipDir == PrevConnectionDir) {
										Placement::Select(NextMacroblockModel, Placement);
										G_CursorConnectedTo = NextPlacementConnectedToClips[Placement];
										break;
									}
								}
							}
						}
						
						if (Placement::Count(NextMacroblockModel) > 0 && !Result.exists(NextMacroblockModel)) {
							Result.add(NextMacroblockModel);
							if (NextMacroblockModel.HasCheckpoint) G_AvailableCheckpoint = NextMacroblockModel.Id;
						}
						
						// Update connectors
						if (Placement::GetConnectedToClips(NextMacroblockModel).exists(PrevClipId)) {
							if (!G_AvailableConnectors.exists(PrevClipId)) G_AvailableConnectors.add(PrevClipId);
							if (G_CursorConnectedTo < 0) G_CursorConnectedTo = PrevClipId;
						}
					}
				}
				
				MacroblocksDirties = False;
			}
		}
	}
	
	G_MacroblocksCount = Result.count;
	
	return Result;
}

// ---------------------------------- //
/// Find and display a list of blocks connectable to the previous one
Void BrowseMacroblocks2() {
	G_AvailableMacroblocks = SortMacroblocks(FilterMacroblocks2(False), False);
	// Send the block list to the UI
	SendMacroblockList(G_AvailableMacroblocks);
	if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
		declare BlockHelp = Text[Text];
		//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: placing a block in the track.
		BlockHelp[Buttons2::Editor_PlaceBlock()] = _("Place");
		if (!CutPasteIsAllowed()) {
			//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: removing a block in the track.
			BlockHelp[Buttons2::Editor_RemoveBlock()] = _("Remove");
		} else {
			//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: cutting a block in the track.
			BlockHelp[Buttons2::Editor_CutBlock()] = _("Cut");
		}
		if (G_AvailableConnectors.count > 1) {
			//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: switching between several available block connectors.
			BlockHelp[Buttons2::Editor_SelectConnector()] = _("Switch");
		}
		//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: launching a test race on the track.
		BlockHelp[Buttons2::Editor_OpenTest()] = _("Test");
		//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
		BlockHelp[Buttons2::Editor_CameraMove()] = _("Camera");
		//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: disconnecting the current block from the previous block.
		if (IsEditor(C_Editor_Advanced)) BlockHelp[Buttons2::Editor_Disconnect()] = _("Disconnect");
		//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: changing the zoom level of the camera.
		BlockHelp[Buttons2::Editor_CameraZoom()] = _("Zoom");
		
		UI_BlockHelp::SetOptions(BlockHelp);
	}
}

// ---------------------------------- //
/// Get a list of terrain macroblocks
CMacroblockModel[] FilterTerrainMacroblocks() {
	declare CMacroblockModel[] Result;
	foreach (MacroblockModel in MacroblockModels) {
		if (!Macroblock::IsTerrain(MacroblockModel)) continue;
		if (!Macroblock::GetValidity(MacroblockModel)) continue;
		
		// Terrain edition
		if (IsEditingTerrain() && Macroblock::GetType(MacroblockModel) == "Types") {
			Result.add(MacroblockModel);
		} 
		// Terrain selection
		else if (!IsEditingTerrain() && Macroblock::GetType(MacroblockModel) == "Terrains") {
			Placement::Clear(MacroblockModel);
			
			// Find right height
			for (PosY, 0, Map.Size.Y - 1) {
				declare CanBePlaced = CanPlaceMacroblock(MacroblockModel, <0, PosY, 0>, CEditorPlugin::CardinalDirections::North);
				if (CanBePlaced) {
					Placement::Add(MacroblockModel, <0, PosY, 0>, CEditorPlugin::CardinalDirections::North, -1, -1);
					
					// Test east, south and west directions
					declare Coords = [1 => <Map.Size.X - 1, PosY, 0>, 2 => <Map.Size.X - 1, PosY, Map.Size.Z - 1>, 3 => <0, PosY, Map.Size.Z - 1>];
					for (IntDir, 1, 3) {
						declare Coord = Coords[IntDir];
						declare Dir = Utils::IntToDir(IntDir);
						if (CanPlaceMacroblock(MacroblockModel, Coord, Dir)) {
							Placement::Add(MacroblockModel, Coord, Dir, -1, -1);
						}
					}
				}
			}
			
			if (Placement::Count(MacroblockModel) > 0) {
				Result.add(MacroblockModel);
			}
		}
	}
	
	G_MacroblocksCount = Result.count;
	
	return Result;
}

// ---------------------------------- //
/// Find and display a list of terrain blocks
Void BrowseTerrainMacroblocks() {
	// Get a list of terrain macroblocks
	G_AvailableMacroblocks = SortMacroblocks(FilterTerrainMacroblocks(), True);
	
	// Send the block list to the UI
	SendMacroblockList(G_AvailableMacroblocks);
}

// ---------------------------------- //
/** Get a list of terrain macroblocks ids
 *
 *	@return							The ids of the terrain macroblock
 */
Ident[] GetTerrainsIds() {
	declare Ident[] Result;
	
	declare Terrains = FilterTerrainMacroblocks();
	foreach (Terrain in Terrains) {
		Result.add(Terrain.Id);
	}
	
	return Result;
}

// ---------------------------------- //
/** Set the PlaceMode and EditMode of the editor
 *
 *	@param	_PlaceMode				The place mode
 *	@param	_EditMode				The edit mode
 */
Void SetPlaceAndEditModes(CEditorPlugin::PlaceMode _PlaceMode, CEditorPlugin::EditMode _EditMode) {
	if (PlaceMode != _PlaceMode) PlaceMode = _PlaceMode;
	G_PlaceMode = _PlaceMode;
	if (EditMode != _EditMode) EditMode = _EditMode;
	G_EditMode = _EditMode;
}

// ---------------------------------- //
/** Center camera on the connecting clip and not the whole macroblock
 *
 *	@param	_Coord					The fallback coordinates
 */
Void MoveCameraToClip(Int3 _Coord) {
	if (G_CursorConnectedTo != -1) {
		Camera::MoveTo(Macroblock::GetClipCoord(
			MapContent::GetMacroblockModel(G_FilteringCoord),
			MapContent::GetMacroblockCoord(G_FilteringCoord),
			MapContent::GetMacroblockDir(G_FilteringCoord),
			G_CursorConnectedTo
		));
	} else {
		Camera::MoveTo(_Coord);
	}
}

// ---------------------------------- //
/** Rotate the current macroblock
 *
 *	@param	_Direction				Negative rotate to the left, positive rotate to the right
 */
Void RotateMacroblock(Integer _Direction) {
	declare Angle = CEditorPlugin::CardinalDirections::North;
	switch (ML::Abs(_Direction) % 4) {
		case 1: Angle = CEditorPlugin::CardinalDirections::East;
		case 2: Angle = CEditorPlugin::CardinalDirections::South;
		case 3: Angle = CEditorPlugin::CardinalDirections::West;
	}
	
	declare TargetCursorDir = G_CursorDir;
	declare NewCursorDir = TargetCursorDir;
	if (_Direction < 0) {
		TargetCursorDir = MU::SubDirs(TargetCursorDir, Angle);
		NewCursorDir = TargetCursorDir;
	} else if (_Direction > 0) {
		TargetCursorDir = MU::AddDirs(TargetCursorDir, Angle);
		NewCursorDir = TargetCursorDir;
	}
	
	if (!G_RandomMapGeneration) Sound::Play("EditorBlockRotate");
	
	SetCursorDir(NewCursorDir, TargetCursorDir);
	//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : rotating the currently selected block.
	if (CanNotify()) UI_BlockHelp::Notify(_("Rotate"));
}

// ---------------------------------- //
/** Move in a direction
 *
 *	@param	_Direction				The direction of the move
 *	@param	_RelativeToCamera		Direction is relative to the camera angle
 *
 *	@return							The coordinate after the move
 */
Int3 Move(Int3 _Direction, Boolean _RelativeToCamera) {
	declare RotatedDirection = _Direction;
	
	// Convert direction to match camera angle
	if (_RelativeToCamera) {
		declare Angle = CameraHAngle;
		if (Angle < 0.) {
			Angle = (2 * ML::PI()) + CameraHAngle;
		}
		declare UnitAngle = ML::PI() / 4.;
		
		// North must always be top or top-right in the current camera angle
		// North is North -> Y 1
		if (Angle <= UnitAngle || Angle > 7 * UnitAngle) {
			
		} 
		// North is East -> X -1
		else if (Angle > UnitAngle && Angle <= 3 * UnitAngle) {
			RotatedDirection = MU::GetRotatedOffset(_Direction, CEditorPlugin::CardinalDirections::West);
		} 
		// North is South -> Y -1
		else if (Angle > 3 * UnitAngle && Angle <= 5 * UnitAngle) {
			RotatedDirection = MU::GetRotatedOffset(_Direction, CEditorPlugin::CardinalDirections::South);
		} 
		// North is West -> X 1
		else if (Angle > 5 * UnitAngle && Angle <= 7 * UnitAngle) {
			RotatedDirection = MU::GetRotatedOffset(_Direction, CEditorPlugin::CardinalDirections::East);
		}
	}
	
	declare TargetCursorCoord = G_CursorCoord + RotatedDirection;
	if (RotatedDirection.X != 0) TargetCursorCoord.X = CursorCoord.X + RotatedDirection.X;
	if (RotatedDirection.Y != 0) TargetCursorCoord.Y = CursorCoord.Y + RotatedDirection.Y;
	if (RotatedDirection.Z != 0) TargetCursorCoord.Z = CursorCoord.Z + RotatedDirection.Z;
	
	return TargetCursorCoord;
}

// ---------------------------------- //
/** Play a sound when moving a macroblock
 *
 *	@param	_Direction				The direction of the move
 *	@param	_OldCoord				The old coordinates
 *	@param	_NewCoord				The new coordinates
 *	@param	_YSound					Play a sound for Y variation
 */
Void PlayMoveSound(Int3 _Direction, Int3 _OldCoord, Int3 _NewCoord, Boolean _YSound) {
	if (_YSound && _Direction.Y > 0) {
		if (_OldCoord.Y < _NewCoord.Y) Sound::Play("EditorBlockMoveUp");
		else Sound::Play("EditorWrongAction");
	} else if (_YSound && _Direction.Y < 0) {
		if (_OldCoord.Y > _NewCoord.Y) Sound::Play("EditorBlockMoveDown");
		else Sound::Play("EditorWrongAction");
	} else if (_Direction.X != 0 || _Direction.Z != 0) {
		if (_OldCoord.X != _NewCoord.X || _OldCoord.Z != _NewCoord.Z) Sound::Play("EditorBlockMove");
		else Sound::Play("EditorWrongAction");
	}
}

// ---------------------------------- //
/** Move the terrain
 *
 *	@param	_Direction				The direction of the move
 *	@param	_RelativeToCamera		Direction is relative to the camera angle
 *	@param	_MoveCamera				Move the camera to the new location
 */
Void MoveTerrain(Int3 _Direction, Boolean _RelativeToCamera, Boolean _MoveCamera) {
	declare TargetCursorCoord = SanitizeCursorCoord(Move(_Direction, _RelativeToCamera));
	TargetCursorCoord.Y = GetGroundHeight(TargetCursorCoord.X, TargetCursorCoord.Z);
	declare OldCursorCoord = CursorCoord;
	
	SetCursorCoord(TargetCursorCoord);
	if (_MoveCamera) Camera::MoveTo(CursorCoord);
	
	PlayMoveSound(_Direction, OldCursorCoord, CursorCoord, False);
	
	if (Selection::IsSelecting()) {
		if (IsEditingTerrain() && CursorTerrainBlockModel != Null) {
			Selection::Update(CursorCoord);
			
			/* CanPlaceTerrainBlocks_NoDestruction can't be done
			if (EditorInputIsDown_CursorPlace && !EditorInputIsDown_CursorDelete) {
				if (CanPlaceTerrainBlocks(CursorTerrainBlockModel, Selection::GetStart(), Selection::GetEnd())) {
					Selection::SetColor(<0., 0.3, 0.>);
				} else {
					Selection::SetColor(<0.3, 0., 0.>);
				}
			}*/
		} else {
			Selection::Update(CursorCoord);
		}
	}
}

// ---------------------------------- //
/// Move camera overload
Void MoveTerrain(Int3 _Direction, Boolean _RelativeToCamera) {
	MoveTerrain(_Direction, _RelativeToCamera, True);
}

// ---------------------------------- //
/** Move the terrain
 *
 *	@param	_Input					Input from the gamepad
 */
Void MoveTerrain(CEditorPluginEvent::EInput _Input) {
	switch (_Input) {
		case CEditorPluginEvent::EInput::IconUp		: MoveTerrain(<0, 0, 1>, True);
		case CEditorPluginEvent::EInput::IconRight	: MoveTerrain(<-1, 0, 0>, True);
		case CEditorPluginEvent::EInput::IconDown	: MoveTerrain(<0, 0, -1>, True);
		case CEditorPluginEvent::EInput::IconLeft	: MoveTerrain(<1, 0, 0>, True);
		case CEditorPluginEvent::EInput::CursorUp	: MoveTerrain(<0, 0, 1>, True);
		case CEditorPluginEvent::EInput::CursorRight: MoveTerrain(<-1, 0, 0>, True);
		case CEditorPluginEvent::EInput::CursorDown	: MoveTerrain(<0, 0, -1>, True);
		case CEditorPluginEvent::EInput::CursorLeft	: MoveTerrain(<1, 0, 0>, True);
	}
}

// ---------------------------------- //
/** Move the macroblock
 *
 *	@param	_Direction				The direction of the move
 *	@param	_RelativeToCamera		Direction is relative to the camera angle
 */
Void MoveMacroblock(Int3 _Direction, Boolean _RelativeToCamera) {
	declare TargetCursorCoord = SanitizeCursorCoord(Move(_Direction, _RelativeToCamera));
	SetFreeModeVariant(Macroblock::VariantNull());
	declare NewCursorCoord = TargetCursorCoord;
	declare OldCursorCoord = CursorCoord;
	declare CMacroblockModel SelectedMacroblockModel;
	
	if (G_CursorMacroblockModel != Null) {
		declare GroundHeight = GetGroundHeight(TargetCursorCoord.X, TargetCursorCoord.Z);
		declare GroundVariant = BlockVariant::GetVariant(<TargetCursorCoord.X, GroundHeight, TargetCursorCoord.Z>);
		//declare TargetBlock <=> GetBlock(TargetCursorCoord);
		
		// Find what kind of variant we want
		declare WantUnderground = False;
		declare WantGround = False;
		declare WantAir = False;
		/*if (TargetBlock != Null && TargetBlock.BlockModel.IsTerrain) WantGround = True;
		else*/ if (TargetCursorCoord.Y < GroundHeight) WantUnderground = True;
		else if (TargetCursorCoord.Y == GroundHeight) WantGround = True;
		else WantAir = True;
		
		// Find the variant closest to the wanted one
		declare Variants = Macroblock::GetVariants(G_CursorMacroblockModel);
		foreach (VariantId => VariantModelId in Variants) {
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(VariantModelId);
			declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
			
			if (WantUnderground) {
				if (Variant.IsAllUnderground) {
					SelectedMacroblockModel <=> MacroblockModel;
					SetFreeModeVariant(VariantId);
					break;
				}
			} else if (WantGround) {
				if (MacroblockModel.IsGround || Variant.IsPartUnderground) {
					SelectedMacroblockModel <=> MacroblockModel;
					SetFreeModeVariant(VariantId);
					if (GroundVariant == Macroblock::GetVariant(MacroblockModel)) break;
				}
			} else if (WantAir) {
				if (!MacroblockModel.IsGround && !Variant.IsPartUnderground && !Variant.IsAllUnderground) {
					SelectedMacroblockModel <=> MacroblockModel;
					SetFreeModeVariant(VariantId);
					break;
				}
			}
		}
		
		// The macroblock does not have a variant matching the exact targeted coordinates
		// Find a variant that can be placed at any height of the targeted coordinates instead
		if (SelectedMacroblockModel == Null) {
			declare VariantFound = False;
			foreach (VariantId => VariantModelId in Variants) {
				declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(VariantModelId);
				declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
				
				// Underground
				if (Variant.IsAllUnderground) {
					declare MaxHeight = GroundHeight - Variant.Size.Y;
					for (PosY, 0, MaxHeight) {
						if (CustomCanPlaceMacroblock(MacroblockModel, <TargetCursorCoord.X, PosY, TargetCursorCoord.Z>, CursorDir, True)) {
							SelectedMacroblockModel <=> MacroblockModel;
							SetFreeModeVariant(VariantId);
							VariantFound = True;
							break;
						}
					}
				} 
				// Ground
				else if (MacroblockModel.IsGround || Variant.IsPartUnderground) {
					for (PosY, GroundHeight-Variant.Size.Y, GroundHeight) {
						if (CustomCanPlaceMacroblock(MacroblockModel, <TargetCursorCoord.X, PosY, TargetCursorCoord.Z>, CursorDir, True)) {
							SelectedMacroblockModel <=> MacroblockModel;
							SetFreeModeVariant(VariantId);
							VariantFound = True;
							break;
						}
					}
				} 
				// Air
				else if (!MacroblockModel.IsGround && !Variant.IsPartUnderground && !Variant.IsAllUnderground) {
					declare MinHeight = GroundHeight + 1;
					for (PosY, MinHeight, Map.Size.Y-1) {
						if (CustomCanPlaceMacroblock(MacroblockModel, <TargetCursorCoord.X, PosY, TargetCursorCoord.Z>, CursorDir, True)) {
							SelectedMacroblockModel <=> MacroblockModel;
							SetFreeModeVariant(VariantId);
							VariantFound = True;
							break;
						}
					}
				}
				
				// Select any existing variant by default
				if (SelectedMacroblockModel == Null) {
					SelectedMacroblockModel <=> MacroblockModel;
					SetFreeModeVariant(VariantId);
				}
				
				if (VariantFound) break;
			}
		}
		
		if (SelectedMacroblockModel == Null) SelectedMacroblockModel = G_CursorMacroblockModel;
		
		// Adjuste the variant height
		declare Variant <=> Macroblock::GetBlockModelVariant(SelectedMacroblockModel);
		// Underground
		if (Variant.IsAllUnderground) {
			// Force coordinates under ground
			declare MaxHeight = GroundHeight - Variant.Size.Y;
			if (TargetCursorCoord.Y > MaxHeight) NewCursorCoord.Y = MaxHeight;
		} 
		// Ground
		else if (SelectedMacroblockModel.IsGround || Variant.IsPartUnderground) {
			// Find right height
			if (!CustomCanPlaceMacroblock(SelectedMacroblockModel, TargetCursorCoord, CursorDir, True)) {
				NewCursorCoord.Y = GroundHeight - Macroblock::GetGroundOffset(SelectedMacroblockModel);
				for (PosY, GroundHeight-Variant.Size.Y, GroundHeight) {
					if (CustomCanPlaceMacroblock(G_CursorMacroblockModel, <TargetCursorCoord.X, PosY, TargetCursorCoord.Z>, CursorDir, True)) {
						NewCursorCoord.Y = PosY;
						break;
					}
				}
			}
		} 
		// Air
		else if (!SelectedMacroblockModel.IsGround && !Variant.IsPartUnderground && !Variant.IsAllUnderground) {
			// Force coordinates over ground
			declare MinHeight = GroundHeight + 1;
			if (TargetCursorCoord.Y < MinHeight) NewCursorCoord.Y = MinHeight;
		}
	}
	
	SetCursorCoord(NewCursorCoord, TargetCursorCoord);
	PlayMoveSound(_Direction, OldCursorCoord, CursorCoord, True);
	BrowseMacroblocks2();
	if (SelectedMacroblockModel != Null) {
		UI_MacroblockSelection::FindMacroblock(SelectedMacroblockModel.Id);
	}
	
	if (!G_RandomMapGeneration) MoveCameraToClip(CursorCoord);
	
	if (CanNotify()) {
		
		if (_Direction == <0, 1, 0>) {
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : raising the block we are going to place.
			if (OldCursorCoord.Y != CursorCoord.Y) UI_BlockHelp::Notify(_("Raise"));
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : raising the block we are going to place.
			else UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Raise")));
		
		} else if (_Direction == <0, -1, 0>) {
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : lowering the block we are going to place.
			if (OldCursorCoord.Y != CursorCoord.Y) UI_BlockHelp::Notify(_("Lower"));
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : lowering the block we are going to place.
			else UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Lower")));
		}
	}
}

// ---------------------------------- //
/** Move the block
 *
 *	@param	_Input					Input from the gamepad
 */
Void MoveMacroblock(CEditorPluginEvent::EInput _Input) {
	switch (_Input) {
		case CEditorPluginEvent::EInput::CursorRaise	: MoveMacroblock(<0, 1, 0>, True);
		case CEditorPluginEvent::EInput::CursorLower	: MoveMacroblock(<0, -1, 0>, True);
		case CEditorPluginEvent::EInput::IconUp			: MoveMacroblock(<0, 0, 1>, True);
		case CEditorPluginEvent::EInput::IconRight		: MoveMacroblock(<-1, 0, 0>, True);
		case CEditorPluginEvent::EInput::IconDown		: MoveMacroblock(<0, 0, -1>, True);
		case CEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(<1, 0, 0>, True);
		case CEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(<0, 0, 1>, True);
		case CEditorPluginEvent::EInput::CursorRight	: MoveMacroblock(<-1, 0, 0>, True);
		case CEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(<0, 0, -1>, True);
		case CEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(<1, 0, 0>, True);
	}
	
	if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabled(UI_Tuto::Tuto_MoveBlock())) {
		UI_Tuto::Validate(UI_Tuto::Tuto_MoveBlock());
		CheckTuto();
	}
}

// ---------------------------------- //
/** Move the block
 *
 *	@param	_Dir					Direction of the move
 */
Void MoveMacroblock(CEditorPlugin::CardinalDirections _Dir) {
	switch (_Dir) {
		case CEditorPlugin::CardinalDirections::North	: MoveMacroblock(<0, 0, 1>, False);
		case CEditorPlugin::CardinalDirections::West	: MoveMacroblock(<-1, 0, 0>, False);
		case CEditorPlugin::CardinalDirections::South	: MoveMacroblock(<0, 0, -1>, False);
		case CEditorPlugin::CardinalDirections::East	: MoveMacroblock(<1, 0, 0>, False);
	}
}

// ---------------------------------- //
/** Select a random macroblock model in the available one
 *
 *	@return							A macroblock model if found, Null otherwise
 */
CMacroblockModel GetRandomMacroblock() {
	declare AvailableMacroblocksIds = UI_MacroblockSelection::GetAllMacroblocksIds();
	if (AvailableMacroblocksIds.count <= 0) return Null;
	
	declare RandomMacroblockId = AvailableMacroblocksIds[Random::Rand(0, AvailableMacroblocksIds.count - 1)];
	if (MacroblockModels.existskey(RandomMacroblockId)) return MacroblockModels[RandomMacroblockId];
	
	return Null;
}

// ---------------------------------- //
/** Preview the selected macroblock
 *
 *	@param	_MacroblockModelId		The Id of the macroblock to preview
 *	@param	_MacroblockPlacement	The macroblock placement to use
 *	@param	_ForceDir				Use the same dir than the previous selected block
 */
Void PreviewMacroblock(Ident _MacroblockModelId, Integer _MacroblockPlacement, Boolean _ForceDir) {
	// Get the macroblock model to use
	declare CMacroblockModel MacroblockModel;
	if (_MacroblockModelId == NullId) {
		MacroblockModel <=> GetRandomMacroblock();
		if (MacroblockModel != Null) UI_MacroblockSelection::FindMacroblock(MacroblockModel.Id);
	} else {
		MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	}
	
	if (MacroblockModel != Null) {
		// Don't preview a macroblock if we're skinning it
		if (G_IsSkinning || G_IsEditing) SetCursorMacroblockModel(Null, MacroblockModel);
		else SetCursorMacroblockModel(MacroblockModel);
		
		if (IsFreeMode() || IsPlacingStart() || IsEditingDecoration()) {
			if (C_Expert_AutoDir && !CustomCanPlaceMacroblock(MacroblockModel, CursorCoord, CursorDir, False)) {
				declare Coord = Placement::GetCoord(MacroblockModel);
				declare Dir = Placement::GetDir(MacroblockModel);
				if (CustomCanPlaceMacroblock(MacroblockModel, Coord, Dir, False)) {
					SetCursorDir(Placement::GetDir(MacroblockModel));
				}
			}
		} else {
			// Keep block dir
			if (_ForceDir && Placement::Exists(MacroblockModel, CursorDir)) {
				declare BlockDirs = Placement::GetDirs(MacroblockModel);
				Placement::Select(MacroblockModel, BlockDirs.keyof(CursorDir));
			}
			// Use forced macroblock placement
			else if (_MacroblockPlacement >= 0) {
				Placement::Select(MacroblockModel, _MacroblockPlacement);
			}
			
			if (Placement::Exists(MacroblockModel)) {
				declare MacroblockCoord = Placement::GetCoord(MacroblockModel);
				declare MacroblockDir = Placement::GetDir(MacroblockModel);
				declare BlockUnitsCoords = Macroblock::GetCoords(MacroblockModel, MacroblockCoord, MacroblockDir);
				declare BlockUnitCoord = MacroblockCoord;
				if (BlockUnitsCoords.count > 0) BlockUnitCoord = BlockUnitsCoords[0];
				SetCursorCoord(MacroblockCoord, BlockUnitCoord);
				SetCursorDir(MacroblockDir);
			}
		}
		
		SetUndergroundMode(G_CursorMacroblockModel);
		if (!IsPlacingStart()) {
			MoveCameraToClip(CursorCoord);
		}
	} else {
		SetCursorMacroblockModel(Null);
	}
	
	SetCursorStyle();
}

// ---------------------------------- //
/// Overload of PreviewMacroblock
Void PreviewMacroblock(Ident _MacroblockModelId, Boolean _ForceDir) {
	PreviewMacroblock(_MacroblockModelId, -1, _ForceDir);
}

// ---------------------------------- //
/// Overload of PreviewMacroblock
Void PreviewMacroblock(Ident _MacroblockModelId) {
	PreviewMacroblock(_MacroblockModelId, False);
}

// ---------------------------------- //
/** Initialize the start block position
 *
 *	@param	_Position				The start block position to try
 *	@param	_GetDefault				Return any existing macroblock model if none is valid at the given position
 *
 *	@return							The selected start macroblocks
 */
CMacroblockModel InitStartMacroblocks(Int3 _Position, Boolean _GetDefault) {
	SetCursorCoord(_Position);
	declare CMacroblockModel DefaultStartMacroblockModel;
	
	for (Y, 0, Map.Size.Y-1) {
		declare PosY = (_Position.Y + Y) % Map.Size.Y;
		foreach (MacroblockModel in MacroblockModels) {
			if (!MacroblockModel.HasStart && !MacroblockModel.HasMultilap) continue;
			if (!Macroblock::GetValidity(MacroblockModel)) continue;
			if (Macroblock::IsTerrain(MacroblockModel)) continue;
			if (Macroblock::IsDeco(MacroblockModel)) continue;
			if (!ThemePack::IsListed(MacroblockModel)) continue;
			
			DefaultStartMacroblockModel <=> MacroblockModel;
			
			if (!G_RandomMapGeneration && ThemePack::IsRandomOnly(MacroblockModel)) continue;
			
			for (I, 0, 3) {
				if (CustomCanPlaceMacroblock(MacroblockModel, <CursorCoord.X, PosY, CursorCoord.Z>, Utils::IntToDir(I), False)) {
					SetCursorMacroblockModel(MacroblockModel);
					SetCursorCoord(<_Position.X, PosY, _Position.Z>);
					MoveMacroblock(<0, 0, 0>, False);
					return MacroblockModel;
				}
			}
		}
	}
	
	if (_GetDefault) {
		return DefaultStartMacroblockModel;
	}
	
	return Null;
}

// ---------------------------------- //
/**he coordinates of a sapwn point from a spawn block
 *
 *	@param	_Block					The block to check
 *
 *	@return							The coordinates of the spawn point
 */
Int3 GetSpawnCoord(CBlock _Block) {
	foreach (BlockUnit in _Block.BlockUnits) {
		return _Block.Coord + BlockUnit.Offset;
	}
	
	return _Block.Coord;
}

// ---------------------------------- //
/// Generate the list of available spawns in the map
Void FindSpawns2() {
	declare Integer[Integer] ToSort;
	foreach (BlockKey => Block in Blocks) {
		if (Block == Null) continue;
		if (
			Block.BlockModel.WaypointType != CBlockModel::EWayPointType::Start &&
			Block.BlockModel.WaypointType != CBlockModel::EWayPointType::StartFinish &&
			Block.BlockModel.WaypointType != CBlockModel::EWayPointType::Checkpoint
		) continue;
		// Skip not respawnable checkpoints
		if (
			Block.BlockModel.WaypointType == CBlockModel::EWayPointType::Checkpoint &&
			Block.BlockModel.NoRespawn
		) continue;
		
		ToSort[BlockKey] = MapContent::GetMacroblockOrder(Block.Coord);
	}
	
	ToSort = ToSort.sort();
	declare Integer[] Spawns;
	foreach (Block => Order in ToSort) {
		Spawns.add(Block);
	}
	
	UI_SpawnSelection::SetSpawns(Spawns);
}

// ---------------------------------- //
/** Select the spawn to use for the test
 *
 *	@param	_Shift 					Select next (1) or previous (-1) spawn
 */
Void SelectSpawn(Integer _Shift) {
	if (_Shift > 0) UI_SpawnSelection::NextSpawn();
	else if (_Shift < 0) UI_SpawnSelection::PrevSpawn();
	
	declare Spawn = UI_SpawnSelection::GetSpawn();
	//declare CBlock Spawn;
	// /!\ The blocks array can contains several blocks with the same id /!\
	// Any block placed at the same coordinates share the same id
	// Eg: a very large turn and a small road placed at the same position in the empty part of the turn
	// This doesn't work => if (Blocks.existskey(SpawnId)) Spawn <=> Blocks[SpawnId];
	
	if (Spawn != Null) {
		declare SpawnCoord = GetSpawnCoord(Spawn);
		declare SpawnMocroblockModel <=> MapContent::GetMacroblockModel(SpawnCoord);
		SetUndergroundMode(SpawnMocroblockModel);
		SetCursorCoord(SpawnCoord);
		SetCursorDir(Utils::DirToDir(Spawn.Direction));
	}
	
	Camera::MoveTo(CursorCoord);
}

// ---------------------------------- //
/** Select the spawn to use for the test
 *
 *	@param	_Key 					The key of the spawn to use
 */
Void GoToSpawn(Integer _Key) {
	UI_SpawnSelection::SelectSpawn(_Key, True);
	SelectSpawn(0);
}

// ---------------------------------- //
/** Show or hide the skinnable block helper
 *
 *	@param	_Display				True to show, False to hide
 */
Void DisplaySkinnableBlocks(Boolean _Display) {
	if (_Display) {
		CustomSelectionRGB = <0., 0.1, 0.>;
		foreach (Block in Blocks) {
			if (Block != Null && GetNbBlockModelSkins(Block.BlockModel) > 1 && !CustomSelectionCoords.exists(Block.Coord)) {
				foreach (BlockUnit in Block.BlockUnits) {
					declare Coord = Block.Coord + BlockUnit.Offset;
					if (!CustomSelectionCoords.exists(Coord)) {
						CustomSelectionCoords.add(Coord);
					}
				}
			}
		}
	} else {
		CustomSelectionCoords.clear();
	}
}

// ---------------------------------- //
/// Update the landscape simple choice UI buttons
Void UpdateLandscapeSimpleChoice() {
	declare metadata Text PartyEditor_TerrainId for Map;
	if (PartyEditor_TerrainId == "" || Macroblock::GetId(ThemePack::GetTerrain()) != PartyEditor_TerrainId) {
		UI_SimpleChoice::SetOptions([
			//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: selecting a landscape.
			Buttons2::Editor_Valid() => _("Select landscape"),
			"" => ""
		], [
			C_SimpleChoice_SelectLandscape
		]);
	} else {
		UI_SimpleChoice::SetOptions([
			//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: selecting a landscape.
			Buttons2::Editor_Valid() => _("Start track"),
			//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
			Buttons2::Editor_CameraMove() => _("Camera")
		], [
			C_SimpleChoice_StartTrack,
			UI_SimpleChoice::Option_NotClickable()
		]);
	}
}

// ---------------------------------- //
/** Select the simplest macroblock among the given ones
 *
 *	@param	_MacroblockModels		The macroblock models to check
 *
 *	@return							The simplest macroblock found
 */
CMacroblockModel SelectSimplestMacroblock(CMacroblockModel[] _MacroblockModels) {
	declare CMacroblockModel ThemePackSimpleMacroblock;
	declare CMacroblockModel SimplestMacroblock;
	declare CMacroblockModel ReallySimpleMacroblock;
	declare CMacroblockModel SimpleMacroblock;
	
	foreach (MacroblockModel in _MacroblockModels) {
		if (MacroblockModel.HasFinish || MacroblockModel.HasStart || MacroblockModel.HasMultilap || MacroblockModel.HasCheckpoint) continue;
		declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
		
		if (ThemePack::IsSimple(MacroblockModel)) {
			ThemePackSimpleMacroblock = MacroblockModel;
			break;
		} else if (
			!Variant.IsPartUnderground &&
			!Variant.IsAllUnderground &&
			(!Macroblock::IsShifting(MacroblockModel) &&
			!Macroblock::IsTurning(MacroblockModel) &&
			!Macroblock::IsRising(MacroblockModel) &&
			Macroblock::GetName(MacroblockModel) == "Straight") ||
			Macroblock::GetFullName(MacroblockModel) == "Arena\\Bases\\Simple"
		) {
			SimplestMacroblock = MacroblockModel;
		} else if (
			!Macroblock::IsShifting(MacroblockModel) &&
			!Macroblock::IsTurning(MacroblockModel) &&
			!Macroblock::IsRising(MacroblockModel)
		) {
			ReallySimpleMacroblock = MacroblockModel;
		} else if (
			!Macroblock::IsTurning(MacroblockModel) &&
			!Macroblock::IsTransfert(MacroblockModel)
		) {
			SimpleMacroblock = MacroblockModel;
		} else if (SimpleMacroblock == Null) {
			SimpleMacroblock = MacroblockModel;
		}
	}
	
	if (ThemePackSimpleMacroblock != Null) return ThemePackSimpleMacroblock;
	else if (SimplestMacroblock != Null) return SimplestMacroblock;
	else if (ReallySimpleMacroblock != Null) return ReallySimpleMacroblock;
	return SimpleMacroblock;
}

// ---------------------------------- //
/// Select the simplest macroblock among the available ones
Void SelectSimplestMacroblock() {
	declare CMacroblockModel[] AvailableMacroblockModels;
	declare AvailableMacroblocksIds = UI_MacroblockSelection::GetAllMacroblocksIds();
	foreach (MacroblockId in AvailableMacroblocksIds) {
		if (!MacroblockModels.existskey(MacroblockId)) continue;
		declare MacroblockModel <=> MacroblockModels[MacroblockId];
		AvailableMacroblockModels.add(MacroblockModel);
	}
	declare SimplestMacroblockModel = SelectSimplestMacroblock(AvailableMacroblockModels);
	if (SimplestMacroblockModel != Null) UI_MacroblockSelection::FindMacroblock(SimplestMacroblockModel.Id);
}

// ---------------------------------- //
/// Automatically select the right style based on the current clip
Void AutoSelectStyle() {
	// Find one open clip
	declare PrevMacroblock <=> MapContent::GetMacroblockModel(G_CursorCoord);
	declare PrevMacroblockCoord = MapContent::GetMacroblockCoord(G_CursorCoord);
	declare PrevMacroblockDir = MapContent::GetMacroblockDir(G_CursorCoord);
	declare PrevClipsDisconnected = MapContent::GetDisconnectedClips(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir);
	
	if (PrevClipsDisconnected.count > 0) {
		// Find the track style associated with this clip
		declare ClipName = Macroblock::GetClipName(PrevMacroblock, PrevClipsDisconnected[0]);
		declare TrackStyleId = ThemePack::GetClipTrackStyle(ClipName);
		
		if (TrackStyleId >= 0 && TrackStyleId != ThemePack::GetTrackStyle()) {
			declare TrackStyleName = ThemePack::GetTrackStyleNameFromId(TrackStyleId);
						
			ThemePack::Select(TrackStyleId, ThemePack::GetLandStyle());
			UI_StyleSelection::SelectStyle(TrackStyleName);
			UI_MacroblockSelection::SetStyle(TrackStyleName, ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
		}
	}
}

// ---------------------------------- //
/** Check if we must hide or show the block helpers
 *
 *	@param	_Sequence				The current sequence
 */
Void CheckBlockHelpers(Integer _Sequence) {
	HideBlockHelpers = !(
		_Sequence == C_Sequence_PlaceStart ||
		_Sequence == C_Sequence_ConnectMode ||
		_Sequence == C_Sequence_FreeMode ||
		_Sequence == C_Sequence_TestMode ||
		_Sequence == C_Sequence_Simple_PlaceStart ||
		_Sequence == C_Sequence_Simple_BuildTrack ||
		_Sequence == C_Sequence_Simple_MoveCursor ||
		_Sequence == C_Sequence_Simple_Test
	);
}

// ---------------------------------- //
/** Check which mouse mode to use in the mouse control UI
 *
 *	@param	_Sequence				The current sequence
 */
Void CheckMouseMode(Integer _Sequence) {
	if (_Sequence == C_Sequence_EditTerrain) {
		UI_MouseControl::SetMouseMode(UI_MouseControl::MouseMode_Selection());
	} else if (
		_Sequence == C_Sequence_PlaceStart ||
		_Sequence == C_Sequence_FreeMode ||
		_Sequence == C_Sequence_EditDecoration
	) {
		UI_MouseControl::SetMouseMode(UI_MouseControl::MouseMode_Move());
	}else {
		UI_MouseControl::SetMouseMode(UI_MouseControl::MouseMode_Click());
	}
}

// ---------------------------------- //
/** Select a style containing the given macroblock model
 *
 *	@param	_MacroblockModelId		Id of the macroblock model to find
 */
Void SelectMacroblockStyle(Ident _MacroblockModelId) {
	if (_MacroblockModelId == NullId) return;
	
	declare MacroblockModel <=> MacroblockModels[_MacroblockModelId];
	declare MacroblockTrackStyles = ThemePack::GetStyles(MacroblockModel);
	if (MacroblockTrackStyles.count > 0 && !MacroblockTrackStyles.exists(ThemePack::GetTrackStyle())) {
		declare MacroblockTrackStylesNames = ThemePack::GetStylesNames(MacroblockModel);
		
		ThemePack::Select(MacroblockTrackStyles[0], ThemePack::GetLandStyle());
		UI_StyleSelection::SelectStyle(MacroblockTrackStylesNames[0]);
		UI_MacroblockSelection::SetStyle(MacroblockTrackStylesNames[0], ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
		BrowseMacroblocks2();
	}
}

// ---------------------------------- //
/** Event : triggered when a sequence is started
 *
 *	@param	_Sequence				The started sequence
 */
Void OnSequenceStart(Integer _Sequence) {
	CheckUIPosition(_Sequence);
	CheckBlockHelpers(_Sequence);
	CheckMouseMode(_Sequence);
	
	switch (_Sequence) {
		case C_Sequence_Classic_Build: {
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
		}
		case C_Sequence_RandomMap: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::FreeLook);
		}
		case C_Sequence_AutoFinish: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::FreeLook);
		}
		case C_Sequence_RerollMap: {
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			
			//L16N [MapEditor] Question displayed after a random track generation, asking the player if he wants to play on the generated track or to generate another track.
			if (S_RandomMap_Validate) UI_Header::SetTitle(_("What do you want to do?"), True);
			//L16N [MapEditor] Question displayed after a random track generation, asking the player if he wants to play on the generated track or to generate another track.
			else UI_Header::SetTitle(_("Do you want to generate another track or play this one?"), True);
			UI_Header::SetModes(Text[]);
			
			if (ManiaPlanet.HMD_IsActive) {
				if (MapContent::HasFinish()) {
					UI_SimpleChoice::SetOptions([
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: playing on the track.
						Buttons2::Editor_RandomPlay() => _("Play"),
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: generating a new random track.
						Buttons2::Editor_RandomGenerate() => _("Generate")
					], [
						C_SimpleChoice_RandomPlay,
						C_SimpleChoice_RandomGenerate
					]);
				} else {
					UI_SimpleChoice::SetOptions([
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: generating a new random track.
						Buttons2::Editor_RandomGenerate() => _("Generate")
					], [
						C_SimpleChoice_RandomGenerate
					]);
				}
				UI_SimpleChoice::SetStyle(UI_SimpleChoice::Style_Compact());
				UI_SimpleChoice::Show();
				UI_Header::Hide();
				UI_BlockHelp::CanBeVisible(False);
			} else if (S_RandomMap_Validate) {
				if (MapContent::HasFinish()) {
					UI_SimpleChoice::SetOptions([
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: validating the track.
						Buttons2::Editor_RandomValidate() => _("Validate this track"),
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: generating a new random track.
						Buttons2::Editor_RandomGenerate() => _("Generate another track"),
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: saving the track.
						Buttons2::Editor_RandomSave() => _("Save this track")
					], [
						C_SimpleChoice_RandomPlay,
						C_SimpleChoice_RandomGenerate,
						C_SimpleChoice_RandomSave
					]);
				} else {
					UI_SimpleChoice::SetOptions([
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: generating a new random track.
						Buttons2::Editor_RandomGenerate() => _("Generate a track")
					], [
						C_SimpleChoice_RandomGenerate
					]);
				}
				UI_SimpleChoice::SetStyle(UI_SimpleChoice::Style_Default());
				UI_SimpleChoice::Show();
				UI_Header::Show();
				UI_BlockHelp::CanBeVisible(False);
			} else {
				if (MapContent::HasFinish()) {
					UI_SimpleChoice::SetOptions([
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: playing on the track.
						Buttons2::Editor_RandomPlay() => _("Play this track"),
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: generating a new random track.
						Buttons2::Editor_RandomGenerate() => _("Generate another track")
					], [
						C_SimpleChoice_RandomPlay,
						C_SimpleChoice_RandomGenerate
					]);
				} else {
					UI_SimpleChoice::SetOptions([
						//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: generating a new random track.
						Buttons2::Editor_RandomGenerate() => _("Generate a track")
					], [
						C_SimpleChoice_RandomGenerate
					]);
				}
				UI_SimpleChoice::SetStyle(UI_SimpleChoice::Style_Default());
				UI_SimpleChoice::Show();
				UI_Header::Show();
				UI_BlockHelp::CanBeVisible(False);
			}
			
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			SetCursorStyle();
			
			if (!ManiaPlanet.HMD_IsActive && MapContent::Count() > 0) {
				Camera::CenterOnMap(C_Modes_ConstructTrack, C_CameraZoom_Reroll);
				if (G_PrevSequence != C_Sequence_PopUp) Camera::RotateTo(CEditorPlugin::CardinalDirections::North);
			} else if (MapContent::Count() <= 0) {
				Camera::Init();
			}
		}
		case C_Sequence_MainMenu: {
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			
			CheckProgression();
			UI_Progression::Show();
			
			if (IsSimpleEditor()) {
				UI_Menu::Hide();
				UI_SimpleMenu::Show();
			} else {
				UI_Menu::Show();
				UI_SimpleMenu::Hide();
			}
			Sound::Play("EditorPopUp");
			
			UI_MapStyleSelection::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
		}
		case C_Sequence_MapStyle: {
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			
			CheckProgression();
			UI_Progression::Hide();
			UI_Menu::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			UI_MapStyleSelection::Show();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
		}
		case C_Sequence_PopUp: {
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
		}
		case C_Sequence_SelectTerrain: {
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			
			UI_BlockHelp::SetOptions([
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: validating a choice.
				Buttons2::Editor_Valid() => _("Select"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
				Buttons2::Editor_CameraMove() => _("Camera")
			]);
			UI_BlockHelp::CanBeVisible(True);
			//L16N [MapEditor] Edit mode where the player modify the landscape
			UI_Header::SetTitle(_("Landscape edition"));
			UI_Header::SetModes([C_Modes[C_Modes_LandscapeRandom], C_Modes[C_Modes_LandscapePostcards]]);
			UI_Header::SelectMode(C_Modes[C_Modes_LandscapePostcards]);
			UI_Header::Show();
			
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
			Transitions::ClearAllTransitions();
			SetCustomTerrain(False);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			G_StartingNewMap = True;
			
			if (
				G_PrevSequence == C_Sequence_RandomTerrain || 
				G_PrevSequence == C_Sequence_EditTerrain || 
				G_PrevSequence == C_Sequence_AutoTerrain||
				G_PrevSequence == C_Sequence_MainMenu ||
				G_PrevSequence == C_Sequence_PopUp
			) {
				Camera::MoveTo(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>);
			} else {
				Camera::Init();
			}
			Camera::Zoom(2);
		}
		case C_Sequence_RandomTerrain: {
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			
			UI_BlockHelp::SetOptions([
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: validating a choice.
				Buttons2::Editor_Valid() => _("Select"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: generating a random landscape.
				Buttons2::Editor_RandomLandscape() => _("Random"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
				Buttons2::Editor_CameraMove() => _("Camera")
			]);
			UI_BlockHelp::CanBeVisible(True);
			//L16N [MapEditor] Edit mode where the player modify the landscape
			UI_Header::SetTitle(_("Landscape edition"));
			UI_Header::SetModes([C_Modes[C_Modes_LandscapeRandom], C_Modes[C_Modes_LandscapePostcards]]);
			UI_Header::SelectMode(C_Modes[C_Modes_LandscapeRandom]);
			UI_Header::Show();
			
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
			Transitions::ClearAllTransitions();
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			G_StartingNewMap = True;
			
			if (
				G_PrevSequence == C_Sequence_SelectTerrain || 
				G_PrevSequence == C_Sequence_EditTerrain || 
				G_PrevSequence == C_Sequence_AutoTerrain ||
				G_PrevSequence == C_Sequence_MainMenu ||
				G_PrevSequence == C_Sequence_PopUp
			) {
				Camera::MoveTo(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>);
			} else {
				Camera::Init();
			}
			Camera::Zoom(2);
		}
		case C_Sequence_AutoTerrain: {
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
		}
		case C_Sequence_PlaceStart: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			
			UI_BlockHelp::SetOptions([
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: placing a block in the track.
				Buttons2::Editor_PlaceBlock() => _("Place"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the currently selected block.
				Buttons2::Editor_TurnBlock() => _("Rotate"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: raising the block we are going to place.
				Buttons2::Editor_RaiseBlock() => _("Raise"),
				//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : lowering the block we are going to place.
				Buttons2::Editor_LowerBlock() => _("Lower"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: redoing the last undone action.
				Buttons2::Editor_Redo() => _("Redo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: undoing the last done action.
				Buttons2::Editor_Undo() => _("Undo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: navigating in the macroblock selection UI.
				Buttons2::Editor_BrowseBlocks() => _("Browse"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
				Buttons2::Editor_CameraMove() => _("Camera"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: changing the zoom level of the camera.
				Buttons2::Editor_CameraZoom() => _("Zoom")
			]);
			UI_BlockHelp::CanBeVisible(True);
			//L16N [MapEditor] Description of the action the player has to do
			UI_Header::SetTitle(_("Select the location of the starting line"));
			UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			UI_Header::SelectMode(C_Modes[C_Modes_ConstructTrack]);
			UI_Header::Show();
			
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			
			UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetStartStylePage(), ThemePack::GetStartStylesCount());
			UI_MacroblockSelection::SetMode(UI_MacroblockSelection::Mode_Track());
			UI_MacroblockSelection::Show();
			
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::DisableAll();
			UI_Tuto::Show();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			SetCursorMacroblockModel(Null);
			
			declare StartingCursorCoord = G_CursorCoord;
			if (G_StartingNewMap) {
				StartingCursorCoord = <Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>;
				Camera::Zoom(1);
			}
			
			declare StartMacroblockModel = InitStartMacroblocks(StartingCursorCoord, False);
			if (!G_StartingNewMap && StartMacroblockModel == Null) {
				StartMacroblockModel = InitStartMacroblocks(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>, True);
			}
			if (StartMacroblockModel != Null) {
				SelectMacroblockStyle(StartMacroblockModel.Id);
				PreviewMacroblock(StartMacroblockModel.Id);
				MoveMacroblock(<0, 0, 0>, False);
				// Do it a second time if the start style changed
				UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetStartStylePage(), ThemePack::GetStartStylesCount());
			} else {
				PreviewMacroblock(NullId);
			}
			
			G_StartingNewMap = False;
			CheckTuto();
		}
		case C_Sequence_ConnectMode: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			
			UI_BlockHelp::SetOptions([
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: placing a block in the track.
				Buttons2::Editor_PlaceBlock() => _("Place"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: removing a block in the track.
				Buttons2::Editor_RemoveBlock() => _("Remove"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the currently selected block.
				Buttons2::Editor_TurnBlock() => _("Rotate"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: redoing the last undone action.
				Buttons2::Editor_Redo() => _("Redo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: undoing the last done action.
				Buttons2::Editor_Undo() => _("Undo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
				Buttons2::Editor_CameraMove() => _("Camera"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: changing the zoom level of the camera.
				Buttons2::Editor_CameraZoom() => _("Zoom")
			]);
			UI_BlockHelp::CanBeVisible(True);
			//L16N [MapEditor] Edit mode where the player modify the track
			UI_Header::SetTitle(_("Track edition"));
			UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			UI_Header::SelectMode(C_Modes[C_Modes_ConstructTrack]);
			UI_Header::Show();
			
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Show();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			
			if (!MapContent::Exists(G_CursorCoord)) {
				declare Coord = MapContent::GetNearestMacroblockUnitCoord(G_CursorCoord, C_Modes_ConstructTrack, True);
				if (Coord == Utils::NullCoord()) Coord = MapContent::GetNearestMacroblockUnitCoord(G_CursorCoord, C_Modes_ConstructTrack, False);
				SetCursorCoord(Coord);
			}
			
			BrowseMacroblocks2();
			PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId());
		}
		case C_Sequence_FreeMode: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			CheckHelper();
			UI_BlockHelp::CanBeVisible(True);
			//L16N [MapEditor] Edit mode where the player modify the track
			UI_Header::SetTitle(_("Track edition"));
			UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			UI_Header::SelectMode(C_Modes[C_Modes_ConstructTrack]);
			UI_Header::Show();
			
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			
			UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
			UI_MacroblockSelection::SetMode(UI_MacroblockSelection::Mode_Track());
			UI_MacroblockSelection::Show();
			
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::DisableAll();
			UI_Tuto::Show();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
			BrowseMacroblocks2();
			
			declare PartyEditor_NeedSimpleBlock for Map = False;
			if (PartyEditor_NeedSimpleBlock) SelectSimplestMacroblock();
			PartyEditor_NeedSimpleBlock = False;
			
			Yield();
			PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
			MoveMacroblock(<0,0,0>, False);
		}
		case C_Sequence_TestMode: {
			UI_BlockHelp::SetOptions([
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: launching a test race on the track.
				Buttons2::Editor_StartTest() => _("Test"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: going back to the previous edit mode.
				Buttons2::Editor_CancelTest() => _("Back")
			]);
			UI_BlockHelp::CanBeVisible(True);
			//L16N [MapEditor] Edit mode where the player select a starting point to test the track
			UI_Header::SetTitle(_("Test track"));
			UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			//UI_Header::SelectMode(C_Modes[C_Modes_ConstructTrack]);
			UI_Header::Show();
			
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Show();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
			
			SetCursorMacroblockModel(Null);
			FindSpawns2();
			SelectSpawn(0);
		}
		case C_Sequence_EditTerrain: {
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			
			declare BlockHelp = [
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: adding a terrain block in the landscape.
				Buttons2::Editor_AddTerrain() => _("Add"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: removing a block in the track.
				Buttons2::Editor_RemoveTerrain() => _("Remove"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: redoing the last undone action.
				Buttons2::Editor_Redo() => _("Redo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: undoing the last done action.
				Buttons2::Editor_Undo() => _("Undo"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: navigating in the macroblock selection UI.
				Buttons2::Editor_BrowseBlocks() => _("Browse"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
				Buttons2::Editor_CameraMove() => _("Camera"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: changing the zoom level of the camera.
				Buttons2::Editor_CameraZoom() => _("Zoom")
			];
			//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: launching a test race on the track.
			if (MapContent::HasStart()) BlockHelp[Buttons2::Editor_OpenTest()] = _("Test");
			UI_BlockHelp::SetOptions(BlockHelp);
			UI_BlockHelp::CanBeVisible(True);
			//L16N [MapEditor] Edit mode where the player modify the landscape
			UI_Header::SetTitle(_("Landscape edition"));
			UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			UI_Header::SelectMode(C_Modes[C_Modes_ConstructTerrain]);
			UI_Header::Show();
			
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			
			UI_MacroblockSelection::SetStyle("terrain", 1, 1);
			UI_MacroblockSelection::SetMode(UI_MacroblockSelection::Mode_Terrain());
			UI_MacroblockSelection::Show();
			
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::DisableAll();
			UI_Tuto::Show();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Terraform, CEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			if (G_SavedCursorCoord.existskey(C_Sequence_EditTerrain)) {
				SetCursorCoord(G_SavedCursorCoord[C_Sequence_EditTerrain]);
			} else {
				SetCursorCoord(<Map.Size.X/2, GetGroundHeight(Map.Size.X/2, Map.Size.Z/2), Map.Size.Z/2>);
			}
			MoveTerrain(<0, 0, 0>, True); ///< Move camera to the right position
			BrowseTerrainMacroblocks();
			
			CheckTuto();
		}
		case C_Sequence_AutoDecoration: {
			ThemePack::SetMode(ThemePack::Mode_Decoration());
			
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
		}
		case C_Sequence_EditDecoration: {
			ThemePack::SetMode(ThemePack::Mode_Decoration());
			CheckHelper();
			UI_BlockHelp::CanBeVisible(True);
			//L16N [MapEditor] Edit mode where the player modify the decoration
			UI_Header::SetTitle(_("Decoration edition"));
			UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			UI_Header::SelectMode(C_Modes[C_Modes_ConstructDeco]);
			UI_Header::Show();
			
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			
			UI_MacroblockSelection::SetStyle("decoration", 1, 1);
			UI_MacroblockSelection::SetMode(UI_MacroblockSelection::Mode_Decoration());
			UI_MacroblockSelection::Show();
			
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::DisableAll();
			UI_Tuto::Show();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			if (G_SavedCursorCoord.existskey(C_Sequence_EditDecoration)) {
				SetCursorCoord(G_SavedCursorCoord[C_Sequence_EditDecoration]);
			} else {
				SetCursorCoord(<Map.Size.X/2, GetGroundHeight(Map.Size.X/2, Map.Size.Z/2), Map.Size.Z/2>);
			}
			DisplaySkinSelection(CursorCoord);
			BrowseMacroblocks2();
			
			CheckTuto();
		}
		case C_Sequence_Simple_Terraforming: {
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			//L16N [MapEditor] Edit mode where the player modify the landscape
			UI_Header::SetTitle(_("Landscape edition"), True);
			UI_Header::SetModes(Text[]);
			UI_Header::Show();
			
			if (IsEditor(C_Editor_Beginner)) {
				UI_StyleSelection::Hide();
				UI_Tuto::Hide();
			} else {
				declare LandStylesNames = ThemePack::GetLandStylesNames();
				UI_StyleSelection::SetStyles(LandStylesNames);
				UI_StyleSelection::SelectStyle(ThemePack::GetLandStyleName());
				foreach (LandStylesName in LandStylesNames) {
					UI_StyleSelection::Enable(LandStylesName);
				}
				UI_StyleSelection::Show();
				
				declare metadata Text PartyEditor_TerrainId for Map;
				G_PreviewTerrainId = PartyEditor_TerrainId;
				
				if (!C_RandomLandscape) {
					declare Terrain <=> ThemePack::GetTerrain();
					declare TerrainName = Macroblock::GetName(Terrain);
					if (G_PreviewTerrainId == Macroblock::GetId(Terrain)) TerrainName = ""; ///< Don't display screenshot if the terrain is already placed
					UI_TerrainPreview::SetTerrains("", TerrainName, 0);
				}
				
				UI_Tuto::DisableAll();
				UI_Tuto::Show();
				if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Landscape())) {
					UI_Tuto::Enable(UI_Tuto::Tuto_Landscape());
				}
			}
			
			if (C_RandomLandscape) UI_TerrainPreview::Hide();
			else UI_TerrainPreview::Show();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			
			UpdateLandscapeSimpleChoice();
			UI_SimpleChoice::SetStyle(UI_SimpleChoice::Style_Default());
			UI_SimpleChoice::Show();
			
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_SimpleMenu::DisplayAutoFinish(False);
			
			G_Category = C_Categories_Landscape;
			G_Mode = C_Modes_LandscapePostcards;
			G_StartingNewMap = True;
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			Camera::FixRotation();
			Camera::MoveTo(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>);
			Camera::ZoomTo(C_CameraZoom_Terraforming[Map.CollectionName]);
		}
		case C_Sequence_Simple_AutoTerrain: {
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
			
			G_Category = C_Categories_Landscape;
			G_Mode = C_Modes_LandscapePostcards;
			G_StartingNewMap = True;
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			Camera::FixRotation();
			Camera::MoveTo(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>);
			Camera::ZoomTo(C_CameraZoom_Terraforming[Map.CollectionName]);
		}
		case C_Sequence_Simple_PlaceStart: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			//L16N [MapEditor] Description of the action the player has to do
			UI_Header::SetTitle(_("Select the location of the starting line"), True);
			UI_Header::SetModes(Text[]);
			UI_Header::Show();
			
			if (IsEditor(C_Editor_Beginner)) {
				UI_StyleSelection::Hide();
			} else {
				declare TrackStyles = ThemePack::GetTrackStyles();
				declare StartStyles = ThemePack::GetStartStyles();
				// Select an existing start style
				declare NeedSelectStyle = (StartStyles.count > 0 && !StartStyles.existskey(ThemePack::GetTrackStyle()));
				UI_StyleSelection::SetStyles(ThemePack::GetTrackStylesNames());
				foreach (TrackStyleId => TrackStyleName in TrackStyles) {
					if (StartStyles.existskey(TrackStyleId)) {
						UI_StyleSelection::Enable(TrackStyleName);
						if (NeedSelectStyle) {
							ThemePack::Select(TrackStyleId, ThemePack::GetLandStyle());
							NeedSelectStyle = False;
						}
					} else {
						UI_StyleSelection::Disable(TrackStyleName);
					}
				}
				UI_StyleSelection::SelectStyle(ThemePack::GetTrackStyleName());
				UI_StyleSelection::Show();
				
				if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Landscape())) {
					UI_Tuto::Validate(UI_Tuto::Tuto_Landscape());
				}
			}
			
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Show();
			UI_MacroblockSelection::SetFamilyVisibility(IsEditor(C_Editor_Advanced));
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			
			
			UI_BlockHelp::SetOptions([
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: placing a block in the track.
				Buttons2::Editor_PlaceBlock() => _("Place"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the currently selected block.
				Buttons2::Editor_TurnBlock() => _("Rotate"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: raising the block we are going to place.
				Buttons2::Editor_RaiseStart() => _("Raise"),
				//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : lowering the block we are going to place.
				Buttons2::Editor_LowerStart() => _("Lower"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: moving the currently selected block.
				Buttons2::Editor_MoveBlock() => _("Move"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
				Buttons2::Editor_CameraMove() => _("Camera"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: changing the zoom level of the camera.
				Buttons2::Editor_CameraZoom() => _("Zoom")
			]);
			
			UI_BlockHelp::CanBeVisible(True);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_SimpleMenu::DisplayAutoFinish(False);
			UI_Tuto::DisableAll();
			UI_Tuto::Show();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
			SetCursorMacroblockModel(Null);
			
			declare StartingCursorCoord = CursorCoord;
			if (G_StartingNewMap) {
				declare metadata Text PartyEditor_TerrainId for Map;
				declare metadata Integer PartyEditor_TerrainDir for Map;
				declare TerrainName = Macroblock::GetName(Macroblock::GetMacroblockModelFromId(PartyEditor_TerrainId));
				StartingCursorCoord = Terrain::GetTerrainSpawn(TerrainName, Utils::IntToDir(PartyEditor_TerrainDir));
				if (StartingCursorCoord == Utils::NullCoord()) StartingCursorCoord = <Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>;
			}
			
			declare StartMacroblockModel = InitStartMacroblocks(StartingCursorCoord, False);
			if (!G_StartingNewMap && StartMacroblockModel == Null) StartMacroblockModel = InitStartMacroblocks(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>, False);
			if (StartMacroblockModel != Null) PreviewMacroblock(StartMacroblockModel.Id);
			else PreviewMacroblock(NullId);
			
			G_Category = C_Categories_Construct;
			G_Mode = C_Modes_ConstructTrack;
			G_StartingNewMap = False;
			
			Camera::DefaultZoomMinMax();
			Camera::MouseNeedInit(False);
			Camera::RotateTo(CursorDir);
			Camera::Zoom(1);
			
			declare PartyEditor_NeedSimpleBlock for Map = False;
			PartyEditor_NeedSimpleBlock = True;
			
			CheckTuto();
		}
		case C_Sequence_Simple_BuildTrack: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			
			UI_Header::SetModes(Text[]);
			UI_Header::Show();
			
			if (IsEditor(C_Editor_Beginner)) {
				UI_StyleSelection::Hide();
				if (CutPasteIsAllowed()) CutPaste::Show();
				else CutPaste::Hide();
			} else {
				declare TrackStylesNames = ThemePack::GetTrackStylesNames();
				UI_StyleSelection::SetStyles(TrackStylesNames);
				UI_StyleSelection::SelectStyle(ThemePack::GetTrackStyleName());
				foreach (TrackStyleName in TrackStylesNames) {
					UI_StyleSelection::Enable(TrackStyleName);
				}
				UI_StyleSelection::Show();
				
				CutPaste::Show();
			}
			
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Show();
			UI_MacroblockSelection::SetFamilyVisibility(IsEditor(C_Editor_Advanced));
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(True);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_SimpleMenu::DisplayAutoFinish(True);
			UI_Tuto::DisableAll();
			UI_Tuto::Show();
			
			G_Category = C_Categories_Construct;
			G_Mode = C_Modes_ConstructTrack;
			G_AskForDeco = True;
			G_AskForValidation = True;
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			SetCursorCoord(MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, False));
			AutoSelectStyle();
			BrowseMacroblocks2();
			
			declare PartyEditor_NeedSimpleBlock for Map = False;
			if (PartyEditor_NeedSimpleBlock) {
				SelectSimplestMacroblock();
			}
			// Check that we selected an available macroblock when switching from disconnected to connected mode
			else if (IsEditor(C_Editor_Advanced)) {
				if (UI_MacroblockSelection::IsAvailable(UI_MacroblockSelection::GetMacroblockId())) {
					UI_MacroblockSelection::FindMacroblock(UI_MacroblockSelection::GetMacroblockId());
				} else {
					SelectSimplestMacroblock();
				}
			}
			
			Camera::DefaultZoomMinMax();
			Camera::MouseNeedInit(False);
			
			PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
			PartyEditor_NeedSimpleBlock = False;
			
			CheckAdvices();
			CheckTuto();
		}
		case C_Sequence_Simple_MoveCursor: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			
			//L16N [MapEditor] Description of the action the player has to do
			UI_Header::SetTitle(_("Move the block to a new location"), True);
			UI_Header::SetModes(Text[]);
			UI_Header::Show();
			
			declare TrackStylesNames = ThemePack::GetTrackStylesNames();
			UI_StyleSelection::SetStyles(TrackStylesNames);
			UI_StyleSelection::SelectStyle(ThemePack::GetTrackStyleName());
			foreach (TrackStyleName in TrackStylesNames) {
				UI_StyleSelection::Enable(TrackStyleName);
			}
			UI_StyleSelection::Show();
			
			CutPaste::Hide();
			
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Show();
			UI_MacroblockSelection::SetFamilyVisibility(IsEditor(C_Editor_Advanced));
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			
			UI_BlockHelp::SetOptions([
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: placing a block in the track.
				Buttons2::Editor_PlaceBlock() => _("Place"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: cutting a block in the track.
				Buttons2::Editor_CutBlock() => _("Cut"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the currently selected block.
				Buttons2::Editor_TurnBlock() => _("Rotate"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: launching a test race on the track.
				Buttons2::Editor_OpenTest() => _("Test"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: connecting the current block to the previous block.
				Buttons2::Editor_Disconnect() => _("Connect"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: raising the block we are going to place.
				Buttons2::Editor_RaiseStart() => _("Raise"),
				//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : lowering the block we are going to place.
				Buttons2::Editor_LowerStart() => _("Lower"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: moving the currently selected block.
				Buttons2::Editor_MoveBlock() => _("Move"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: rotating the camera.
				Buttons2::Editor_CameraMove() => _("Camera"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: changing the zoom level of the camera.
				Buttons2::Editor_CameraZoom() => _("Zoom")
			]);
			UI_BlockHelp::CanBeVisible(True);
			
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_SimpleMenu::DisplayAutoFinish(True);
			UI_Tuto::DisableAll();
			UI_Tuto::Show();
			
			G_Category = C_Categories_Construct;
			G_Mode = C_Modes_ConstructTrack;
			G_AskForDeco = True;
			G_AskForValidation = True;
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Macroblock, CEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			AutoSelectStyle();
			BrowseMacroblocks2();
			
			if (G_CursorMacroblockModel != Null && UI_MacroblockSelection::IsAvailable(G_CursorMacroblockModel.Id)) {
				UI_MacroblockSelection::FindMacroblock(G_CursorMacroblockModel.Id);
			} else {
				SelectSimplestMacroblock();
			}
			
			Camera::DefaultZoomMinMax();
			Camera::MouseNeedInit(False);
			
			PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
			
			CheckTuto();
		}
		case C_Sequence_Simple_Test: {
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Show();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			
			UI_BlockHelp::SetOptions([
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: launching a test race on the track.
				Buttons2::Editor_StartTest() => _("Test"),
				//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: going back to the previous edit mode.
				Buttons2::Editor_CancelTest() => _("Back")
			]);
			UI_BlockHelp::CanBeVisible(True);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_SimpleMenu::DisplayAutoFinish(False);
			UI_Tuto::Hide();
			
			Camera::DefaultZoomMinMax();
			Camera::MouseNeedInit(False);
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			FindSpawns2();
			SelectSpawn(0);
		}
		case C_Sequence_Simple_Deco: {
			ThemePack::SetMode(ThemePack::Mode_Decoration());
			//L16N [MapEditor] Edit mode where the player modify the decoration
			UI_Header::SetTitle(_("Decoration edition"), True);
			UI_Header::SetModes(Text[]);
			UI_Header::Show();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			
			if (IsEditor(C_Editor_Beginner)) {
				UI_DecoSelection::Hide();
				UI_Tuto::Hide();
			} else {
				UI_DecoSelection::Show();
				
				UI_Tuto::DisableAll();
				UI_Tuto::Show();
				if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Decoration())) {
					UI_Tuto::Enable(UI_Tuto::Tuto_Decoration());
				}
			}
			
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			
			if (IsDecorated()) {
				UI_SimpleChoice::SetOptions([
					//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: generating a new random decoration for the track
					Buttons2::Editor_DecoGenerate() => _("Generate decoration"),
					//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: validating the track
					Buttons2::Editor_DecoValid() => _("Validate track"),
					//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: going back to track edition
					Buttons2::Editor_DecoCancel() => _("Edit track"),
					//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: using the default settings
					Buttons2::Editor_DecoDefault() => _("Default settings")
				], [
					C_SimpleChoice_DecoGenerate,
					C_SimpleChoise_DecoValid,
					C_SimpleChoice_DecoCancel,
					C_SimpleChoice_DecoDefault
				]);
			} else {
				UI_SimpleChoice::SetOptions([
					//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: generating a new random decoration for the track
					Buttons2::Editor_DecoGenerate() => _("Generate decoration"),
					//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: going back to track edition
					Buttons2::Editor_DecoCancel() => _("Edit track"),
					//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: using the default settings
					Buttons2::Editor_DecoDefault() => _("Default settings")
				], [
					C_SimpleChoice_DecoGenerate,
					C_SimpleChoice_DecoCancel,
					C_SimpleChoice_DecoDefault
				]);
			}
			UI_SimpleChoice::SetStyle(UI_SimpleChoice::Style_Default());
			UI_SimpleChoice::Show();
			
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_SimpleMenu::DisplayAutoFinish(False);
			
			G_Category = C_Categories_Construct;
			G_Mode = C_Modes_ConstructDeco;
			G_AskForValidation = True;
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			SetCursorStyle();
			Camera::Zoom(2);
			Camera::CenterOnMap(C_Modes_ConstructTrack, C_CameraZoom_Terraforming[Map.CollectionName]);
		}
		case C_Sequence_Simple_Outro: {
			if (ValidationStatus == CEditorPlugin::ValidationStatus::Validated) {
				UI_Header::SetTitle(
					TL::Compose(
						"%1: %2 | %3: %4", 
						"Trackmaster", 
						TL::TimeToText(Map.TMObjective_AuthorTime, True), 
						//L16N [MapEditor] The track style (fullspeed, tech, mini, lol, ...)
						_("Track style"), 
						UI_MapStyleSelection::GetStyleName()
					), 
					True, UI_Header::Status_Message()
				);
			} else {
				//L16N [MapEditor] Message displayed at the end of the track creation warning the player that his track is not validated and can't be played outside the editor
				UI_Header::SetTitle(_("Track not validated"), True, UI_Header::Status_Message());
			}
			
			UI_Header::SetModes(Text[]);
			UI_Header::Show();
			
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Show();
			
			CheckProgression();
			UI_Progression::Show();
			
			UI_SimpleMenu::Hide();
			UI_SimpleMenu::DisplayAutoFinish(False);
			UI_Tuto::Hide();
			
			SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			Camera::CenterOnMap(C_Modes_ConstructTrack, C_CameraZoom_Terraforming[Map.CollectionName]);
		}
		case C_Sequence_None: {
			UI_Header::Hide();
			UI_StyleSelection::Hide();
			UI_TerrainPreview::Hide();
			UI_MacroblockSelection::Hide();
			CutPaste::Hide();
			UI_SkinSelection::Hide();
			UI_SpawnSelection::Hide();
			UI_DecoSelection::Hide();
			UI_Menu::Hide();
			UI_MapStyleSelection::Hide();
			UI_SimpleChoice::Hide();
			UI_BlockHelp::CanBeVisible(False);
			UI_MenuOutro::Hide();
			UI_Progression::Hide();
			UI_SimpleMenu::Hide();
			UI_Tuto::Hide();
		}
	}
}

// ---------------------------------- //
/** Event : triggered when a sequence is stopped
 *
 *	@param	_Sequence				The stopped sequence
 */
Void OnSequenceStop(Integer _Sequence) {
	/*switch (_Sequence) {
		case C_Sequence_ConnectMode: {
			G_SavedCursorCoord[C_Sequence_ConnectMode] = G_CursorCoord;
		}
		case C_Sequence_EditTerrain: {
			G_SavedCursorCoord[C_Sequence_EditTerrain] = G_CursorCoord;
		}
		case C_Sequence_EditDecoration: {
			G_SavedCursorCoord[C_Sequence_EditDecoration] = G_CursorCoord;
		}
	}*/
	G_SavedCursorCoord = [
		C_Sequence_ConnectMode => G_CursorCoord,
		C_Sequence_EditTerrain => G_CursorCoord,
		C_Sequence_EditDecoration => G_CursorCoord
	];
}

// ---------------------------------- //
/// Select the current building sequence
Void SelectSequence() {
	// Confirm pop up
	if (UI_PopUp::IsOpen() || UI_ShadowMenu::IsVisible()) {
		if (G_CurrentSequence != C_Sequence_PopUp) {
			G_CurrentSequence = C_Sequence_PopUp;
		}
	}
	// Random map generation
	else if (G_RandomMapGeneration) {
		if (G_WaitingRerollAnswer) {
			if (G_CurrentSequence != C_Sequence_RerollMap) {
				G_CurrentSequence = C_Sequence_RerollMap;
			}
		} else {
			if (G_CurrentSequence != C_Sequence_RandomMap) {
				G_CurrentSequence = C_Sequence_RandomMap;
			}
		}
	}
	// Map style menu
	else if (G_MapStyleSelection) {
		if (G_CurrentSequence != C_Sequence_MapStyle) {
			G_CurrentSequence = C_Sequence_MapStyle;
		}
	}
	// Main menu
	else if (G_MainMenu) {
		if (G_CurrentSequence != C_Sequence_MainMenu) {
			G_CurrentSequence = C_Sequence_MainMenu;
		}
	}
	// Auto-decoration
	else if (IsGeneratingDecoration()) {
		if (G_CurrentSequence != C_Sequence_AutoDecoration) {
			G_CurrentSequence = C_Sequence_AutoDecoration;
		}
	} 
	// Auto-terrain
	else if (IsGeneratingTerrain()) {
		if (G_CurrentSequence != C_Sequence_AutoTerrain) {
			G_CurrentSequence = C_Sequence_AutoTerrain;
		}
	}
	// Auto-finish
	else if (IsAutoFinishing()) {
		if (G_CurrentSequence != C_Sequence_AutoFinish) {
			G_CurrentSequence = C_Sequence_AutoFinish;
		}
	}
	// Classic mode
	else if (G_Setting_EditorLevel == C_Editor_Classic) {
		if (G_CurrentSequence != C_Sequence_Classic_Build) {
			G_CurrentSequence = C_Sequence_Classic_Build;
		}
	}
	// Simple mode
	else if (IsSimpleEditor()) {
		// Landscape modes
		if (!IsTerraformed()) {
			if (IsEditor(C_Editor_Advanced)) {
				if (G_CurrentSequence != C_Sequence_Simple_Terraforming) {
					G_CurrentSequence = C_Sequence_Simple_Terraforming;
				}
			} else {
				if (G_CurrentSequence != C_Sequence_Simple_AutoTerrain) {
					G_CurrentSequence = C_Sequence_Simple_AutoTerrain;
				}
			}
		}
		// Place start
		else if (!MapContent::HasStart()) {
			if (G_CurrentSequence != C_Sequence_Simple_PlaceStart) {
				G_CurrentSequence = C_Sequence_Simple_PlaceStart;
			}
		}
		// Test track
		else if (G_TestMode) {
			if (G_CurrentSequence != C_Sequence_Simple_Test) {
				G_CurrentSequence = C_Sequence_Simple_Test;
			}
		}
		else if (!MapContent::HasFinish()) {
			// Move cursor
			if (G_MoveCursor) {
				if (G_CurrentSequence != C_Sequence_Simple_MoveCursor) {
					G_CurrentSequence = C_Sequence_Simple_MoveCursor;
				}
			}
			// Build Track
			else {
				if (G_CurrentSequence != C_Sequence_Simple_BuildTrack) {
					G_CurrentSequence = C_Sequence_Simple_BuildTrack;
				}
			}
		}
		// Deco map
		else if (IsEditor(C_Editor_Advanced) && !DecoConfirmed()) {
			if (G_CurrentSequence != C_Sequence_Simple_Deco) {
				G_CurrentSequence = C_Sequence_Simple_Deco;
			}
		}
		// Outro
		else {
			if (G_CurrentSequence != C_Sequence_Simple_Outro) {
				G_CurrentSequence = C_Sequence_Simple_Outro;
			}
		}
	}
	// Advanced mode
	else {
		// Landscape modes
		if (!IsTerraformed()) {
			// Random terrain
			if (G_Mode == C_Modes_LandscapeRandom) {
				if (G_CurrentSequence != C_Sequence_RandomTerrain) {
					G_CurrentSequence = C_Sequence_RandomTerrain;
				}
			} 
			// Select terrain
			else if (G_Mode == C_Modes_LandscapePostcards) {
				if (G_CurrentSequence != C_Sequence_SelectTerrain) {
					G_CurrentSequence = C_Sequence_SelectTerrain;
				}
			}
		}
		// Construct modes
		else {
			// Test mode
			if (G_TestMode) {
				if (G_CurrentSequence != C_Sequence_TestMode) {
					G_CurrentSequence = C_Sequence_TestMode;
				}
			}
			// Terrain
			else if (G_Mode == C_Modes_ConstructTerrain) {
				if (G_CurrentSequence != C_Sequence_EditTerrain) {
					G_CurrentSequence = C_Sequence_EditTerrain;
				}
			}
			// Track
			else if (G_Mode == C_Modes_ConstructTrack) {
				// Place start
				if (!MapContent::HasStart()) {
					if (G_CurrentSequence != C_Sequence_PlaceStart) {
						G_CurrentSequence = C_Sequence_PlaceStart;
					}
				}
				// Free
				else if (IsFreeMode()) {
					if (G_CurrentSequence != C_Sequence_FreeMode) {
						G_CurrentSequence = C_Sequence_FreeMode;
					}
				}
				// Connect
				else {
					if (G_CurrentSequence != C_Sequence_ConnectMode) {
						G_CurrentSequence = C_Sequence_ConnectMode;
					}
				}
			}
			// Decoration
			else if (G_Mode == C_Modes_ConstructDeco) {
				if (G_CurrentSequence != C_Sequence_EditDecoration) {
					G_CurrentSequence = C_Sequence_EditDecoration;
				}
			}
		}
	}
	
	if (G_CurrentSequence != G_PrevSequence) {
		OnSequenceStop(G_PrevSequence);
		OnSequenceStart(G_CurrentSequence);
		G_PrevSequence = G_CurrentSequence;
	}
}

// ---------------------------------- //
/** Open a confirm pop up with a question and the choice to accept or refuse
 *
 *	@param	_Title					The title of the pop up
 *	@param	_Question				The question to ask
 *	@param	_Yes					The "valid" answer
 *	@param	_No						The "cancel" answer
 *	@param	_PlaySound				Play a sound when displaying the pop up
 *
 *	@return							The answer to the question
 */
Boolean Confirm(Text _Title, Text _Question, Text _Yes, Text _No, Boolean _PlaySound) {
	if (_Title == "" && _Yes == "" && _No == "") UI_PopUp::Confirm(_Question);
	else UI_PopUp::Confirm(_Title, _Question, _Yes, _No);
	
	if (_PlaySound) Sound::Play("EditorPopUp");
	SelectSequence();
	
	while (UI_PopUp::Wait()) Yield();
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	SelectSequence();
	return UI_PopUp::Answer();
}

// ---------------------------------- //
/** Open a confirm pop up with a question and the choice to accept or refuse
 *
 *	@param	_Title					The title of the pop up
 *	@param	_Question				The question to ask
 *	@param	_Yes					The "valid" answer
 *	@param	_No						The "cancel" answer
 *
 *	@return							The answer to the question
 */
Boolean Confirm(Text _Title, Text _Question, Text _Yes, Text _No) {
	return Confirm(_Title, _Question, _Yes, _No, True);
}

// ---------------------------------- //
/** Open a confirm pop up with a question and the choice to accept or refuse
 *
 *	@param	_Question				The question to ask
 *
 *	@return							The answer to the question
 */
Boolean Confirm(Text _Question) {
	return Confirm("", _Question, "", "", True);
}

// ---------------------------------- //
/** Open an alert pop up with a message
 *
 *	@param	_Title				The title of the pop-up
 *	@param	_Message			The message to display
 *	@param	_Answer				The answer to display
 *	@param	_PlaySound			Play a sound when displaying the pop up
 */
Void Alert(Text _Title, Text _Message, Text _Answer, Boolean _PlaySound) {
	if (_Title == "" && _Answer == "") UI_PopUp::Alert(_Message);
	else UI_PopUp::Alert(_Title, _Message, _Answer);
	
	if (_PlaySound) Sound::Play("EditorPopUp");
	SelectSequence();
	
	while (UI_PopUp::Wait()) Yield();
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	SelectSequence();
}

// ---------------------------------- //
/** Open an alert pop up with a message
 *
 *	@param	_Title				The title of the pop-up
 *	@param	_Message			The message to display
 *	@param	_Answer				The answer to display
 */
Void Alert(Text _Title, Text _Message, Text _Answer) {
	Alert(_Title, _Message, _Answer, True);
}

// ---------------------------------- //
/** Open an alert pop up with a message
 *
 *	@param	_Message			The message to display
 */
Void Alert(Text _Message) {
	Alert("", _Message, "");
}

// ---------------------------------- //
/** Display or hide the loading screen
 *
 *	@param	_IsLoading				True to display the loading screen, False to hide it
 *	@param	_Message				The message to display on the loading screen
 *	@param	_SequencePopUp			Use the pop-up sequence
 */
Void Loading(Boolean _IsLoading, Text _Message, Boolean _SequencePopUp) {
	UI_PopUp::Loading(_IsLoading, _Message, _SequencePopUp);
	SelectSequence();
	Sleep(300);
}

// ---------------------------------- //
/** Display or hide the loading screen
 *
 *	@param	_IsLoading				True to display the loading screen, False to hide it
 */
Void Loading(Boolean _IsLoading) {
	//L16N [MapEditor] Message displayed during a loading
	Loading(_IsLoading, _("Loading"), True);
}

// ---------------------------------- //
/** Place a macroblock on the map
 *
 *	@param	_MacroblockModel		The macroblock model to place
 *	@param	_Coord					The coordinate of the macroblock
 *	@param	_Dir					The direction of the macroblock
 */
Boolean CustomPlaceMacroblock(CMacroblockModel _MacroblockModel, Int3 _Coord, CEditorPlugin::CardinalDirections _Dir) {
	// Disable some macroblocks in the trial version, but not during random decoration generation
	if (
		Utils::IsTrialVersion()
		&& G_CurrentSequence != C_Sequence_AutoDecoration
		&& !ThemePack::AvailableInTrial(_MacroblockModel)
	) return False;
	
	declare Placed = False;
	if (!G_RandomMapGeneration && ThemePack::CanPlaceTerrain(_MacroblockModel)) Placed = PlaceMacroblock(_MacroblockModel, _Coord, _Dir);
	else Placed = PlaceMacroblock_NoTerrain(_MacroblockModel, _Coord, _Dir);
	
	// Yield to place blocks
	if (Placed) Yield();
	
	return Placed;
}

// ---------------------------------- //
/** Find and select a macroblock in the currently available ones
 *
 *	@param	_MacroblockModelId		The id of the macroblock model to select
 *	@param	_MacroblockCoord		The coordinates of the macroblock to find
 *	@param	_MacroblockDir			The direction of the macroblock to find
 */
Void SelectMacroblock(Ident _MacroblockModelId, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir) {
	// Search in the other family too
	if ((IsEditor(C_Editor_Advanced) || IsEditor(C_Editor_Expert))) {
		SelectMacroblockStyle(_MacroblockModelId);
	}
	
	if (IsSimpleEditor()) {
		foreach (Family => Macroblocks in G_AvailableMacroblocks) {
			foreach (MacroblockModel in Macroblocks) {
				if (MacroblockModel.Id != _MacroblockModelId) continue;
				
				declare MacroblockCoords = Placement::GetCoords(MacroblockModel);
				declare MacroblockDirs = Placement::GetDirs(MacroblockModel);
				foreach (Placement => MacroblockCoord in MacroblockCoords) {
					if (MacroblockCoord == _MacroblockCoord && MacroblockDirs[Placement] == _MacroblockDir) {
						declare ConnectedTo = Placement::GetConnectedToClip(MacroblockModel, Placement);
						if (G_AvailableConnectors.exists(ConnectedTo)) {
							G_CursorConnectedTo = ConnectedTo;
							SendMacroblockList(G_AvailableMacroblocks);
						}
						UI_MacroblockSelection::FindMacroblock(_MacroblockModelId, Placement);
						return;
					}
				}
			}
		}
	} else {
		if (MacroblockModels.existskey(_MacroblockModelId)) {
			declare MacroblockModelName = Macroblock::GetFullName(MacroblockModels[_MacroblockModelId]);
			
			foreach (Family => Macroblocks in G_AvailableMacroblocks) {
				foreach (MacroblockModel in Macroblocks) {
					if (Macroblock::GetFullName(MacroblockModel) != MacroblockModelName) continue;
					
					UI_MacroblockSelection::FindMacroblock(MacroblockModel.Id);
					return;
				}
			}
		}
	}
}

// ---------------------------------- //
/** Select a style
 *
 *	@param	_StyleIndex				New style index
 *	@param	_StyleName				New style name
 *	@param	_Shift					Animation direction in the UI for terrains
 */
Void SelectStyle(Integer _StyleIndex, Text _StyleName, Integer _Shift) {
	UI_StyleSelection::SelectStyle(_StyleName);
	
	if (!C_RandomLandscape && G_CurrentSequence == C_Sequence_Simple_Terraforming) {
		declare OldTerrain <=> ThemePack::GetTerrain();
		declare OldTerrainName = Macroblock::GetName(OldTerrain);
		if (G_PreviewTerrainId == Macroblock::GetId(OldTerrain)) OldTerrainName = "";
		
		ThemePack::Select(ThemePack::GetTrackStyle(), _StyleIndex);
		
		declare NewTerrain <=> ThemePack::GetTerrain();
		declare NewTerrainName = Macroblock::GetName(NewTerrain);
		if (G_PreviewTerrainId == Macroblock::GetId(NewTerrain)) NewTerrainName = "";
		
		UI_TerrainPreview::SetTerrains(OldTerrainName, NewTerrainName, _Shift);
	} else if (G_CurrentSequence == C_Sequence_Simple_Terraforming || G_CurrentSequence == C_Sequence_Simple_Deco) {
		ThemePack::Select(ThemePack::GetTrackStyle(), _StyleIndex);
	} else if (
		G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
		G_CurrentSequence == C_Sequence_PlaceStart ||
		G_CurrentSequence == C_Sequence_FreeMode
	) {
		ThemePack::Select(_StyleIndex, ThemePack::GetLandStyle());
		BrowseMacroblocks2();
		Yield();
		PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
		MoveMacroblock(<0, 0, 0>, False);
		
		if (G_CurrentSequence == C_Sequence_PlaceStart) {
			UI_MacroblockSelection::SetStyle(_StyleName, ThemePack::GetStartStylePage(), ThemePack::GetStartStylesCount());
		} else {
			UI_MacroblockSelection::SetStyle(_StyleName, ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
		}
	} else if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
		ThemePack::Select(_StyleIndex, ThemePack::GetLandStyle());
		SetCursorCoord(MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, False));
		BrowseMacroblocks2();
		CheckAdvices();
	}
	
	SetCursorStyle();
}

// ---------------------------------- //
/// Select a style in the theme pack
Void SelectStyle(Text _StyleName) {
	if (UI_StyleSelection::IsDisabled(_StyleName)) return;
	
	declare Styles = Text[Integer];
	declare Style = 0;
	if (G_CurrentSequence == C_Sequence_Simple_Terraforming || G_CurrentSequence == C_Sequence_Simple_Deco) {
		Styles = ThemePack::GetLandStyles();
		Style = ThemePack::GetLandStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
		G_CurrentSequence == C_Sequence_FreeMode
	) {
		Styles = ThemePack::GetTrackStyles();
		Style = ThemePack::GetTrackStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
		G_CurrentSequence == C_Sequence_PlaceStart
	) {
		Styles = ThemePack::GetStartStyles();
		Style = ThemePack::GetTrackStyle();
	}
	
	if (Styles.count == 0) return;
	
	declare NewStyleIndex = -1;
	declare NewStyleName = "";
	declare Shift = -1;
	foreach (StyleIndex => StyleName in Styles) {
		if (UI_StyleSelection::IsDisabled(StyleName)) continue;
		
		if (StyleIndex == Style) {
			Shift = 0;
		} else if (Shift == 0) {
			Shift = 1;
		}
		
		if (StyleName == _StyleName) {
			if (StyleIndex != Style) {
				NewStyleIndex = StyleIndex;
				NewStyleName = StyleName;
			}
			break;
		}
	}
	
	// Don't select the style that is already selected
	if (NewStyleIndex < 0) return;
	
	SelectStyle(NewStyleIndex, NewStyleName, Shift);
	Sound::Play("EditorSimpleSelectMacroblock");
}

// ---------------------------------- //
/// Select the next style in the theme pack
Void NextStyle() {
	declare Styles = Text[Integer];
	declare Style = 0;
	if (G_CurrentSequence == C_Sequence_Simple_Terraforming || G_CurrentSequence == C_Sequence_Simple_Deco) {
		Styles = ThemePack::GetLandStyles();
		Style = ThemePack::GetLandStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
		G_CurrentSequence == C_Sequence_FreeMode
	) {
		Styles = ThemePack::GetTrackStyles();
		Style = ThemePack::GetTrackStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
		G_CurrentSequence == C_Sequence_PlaceStart
	) {
		Styles = ThemePack::GetStartStyles();
		Style = ThemePack::GetTrackStyle();
	}
	
	if (Styles.count == 0) return;
	
	declare NewStyleIndex = -1;
	declare NewStyleName = "";
	declare IsNext = False;
	foreach (StyleIndex => StyleName in Styles) {
		if (UI_StyleSelection::IsDisabled(StyleName)) continue;
		
		if (IsNext) {
			NewStyleIndex = StyleIndex;
			NewStyleName = StyleName;
			break;
		}
		if (NewStyleIndex < 0) {
			NewStyleIndex = StyleIndex;
			NewStyleName = StyleName;
		}
		if (StyleIndex == Style) {
			IsNext = True;
		}
	}
	
	SelectStyle(NewStyleIndex, NewStyleName, 1);
	Sound::Play("EditorSimpleSelectMacroblock");
}

// ---------------------------------- //
/// Select the previous style in the theme pack
Void PrevStyle() {
	declare Styles = Text[Integer];
	declare Style = 0;
	if (G_CurrentSequence == C_Sequence_Simple_Terraforming || G_CurrentSequence == C_Sequence_Simple_Deco) {
		Styles = ThemePack::GetLandStyles();
		Style = ThemePack::GetLandStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
		G_CurrentSequence == C_Sequence_FreeMode
	) {
		Styles = ThemePack::GetTrackStyles();
		Style = ThemePack::GetTrackStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_PlaceStart || 
		G_CurrentSequence == C_Sequence_PlaceStart
	) {
		Styles = ThemePack::GetStartStyles();
		Style = ThemePack::GetTrackStyle();
	}
	
	if (Styles.count == 0) return;
	
	declare NewStyleIndex = -1;
	declare NewStyleName = "";
	foreach (StyleIndex => StyleName in Styles) {
		if (UI_StyleSelection::IsDisabled(StyleName)) continue;
		
		if (StyleIndex == Style && NewStyleIndex >= 0) {
			break;
		}
		NewStyleIndex = StyleIndex;
		NewStyleName = StyleName;
	}
	
	SelectStyle(NewStyleIndex, NewStyleName, -1);
	Sound::Play("EditorSimpleSelectMacroblock");
}

// ---------------------------------- //
/** Select a mode
 *
 *	@param	_Category				The category to select
 *	@param	_Mode					The mode to select
 *	@param	_PlaySound				Play a sound
 */
Void SelectMode(Integer _Category, Integer _Mode, Boolean _PlaySound) {
	// Switch to postcard mode after creating a random terrain
	declare Change = True;
	if (_Mode == C_Modes_LandscapePostcards && G_Mode == C_Modes_LandscapeRandom && IsCustomTerrain() && !IsSimpleEditor()) {
		Change = Confirm(ComposeMultilines([
			//L16N [MapEditor] Pop-up warning the player that he will loose his modifications if he validate
			_("Any modification done on this terrain will be lost."),
			//L16N [MapEditor] Pop-up warning the player that he will loose his modifications if he validate
			_("Are you sure you want to select another terrain?")
		]));
	}
	if (!Change) return;
	
	G_Category = _Category;
	G_Mode = _Mode;
	
	if (_PlaySound) Sound::Play("EditorSimpleSelectMacroblock");
}

// ---------------------------------- //
/** Select a mode
 *
 *	@param	_Mode					The mode to select
 */
Void SelectMode(Text _Mode) {
	declare Mode = C_Modes_ConstructTrack;
	if (_Mode == C_Modes[C_Modes_ConstructTerrain]) Mode = C_Modes_ConstructTerrain;
	else if (_Mode == C_Modes[C_Modes_ConstructTrack]) Mode = C_Modes_ConstructTrack;
	else if (_Mode == C_Modes[C_Modes_ConstructDeco]) Mode = C_Modes_ConstructDeco;
	SelectMode(C_Categories_Construct, Mode, True);
}

// ---------------------------------- //
/// Overload SelectMode()
Void SelectMode(Integer _Category, Integer _Mode) {
	SelectMode(_Category, _Mode, False);
}

// ---------------------------------- //
/** Switch between the modes of a category
 *
 *	@param	_Category				The category of the modes to switch
 */
Void SwitchMode(Integer _Category) {
	if (_Category == C_Categories_Landscape) {
		switch (G_Mode) {
			case C_Modes_LandscapeRandom	: SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
			case C_Modes_LandscapePostcards	: SelectMode(C_Categories_Landscape, C_Modes_LandscapeRandom);
			default							: SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
		}
	} else if (_Category == C_Categories_Construct) {
		switch (G_Mode) {
			case C_Modes_ConstructTerrain	: SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
			case C_Modes_ConstructTrack		: SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
			case C_Modes_ConstructDeco		: SelectMode(C_Categories_Construct, C_Modes_ConstructTerrain);
			default							: SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
		}
		Sound::Play("EditorSimpleSelectMacroblock");
	}
	
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_ChangeMode())) {
		UI_Tuto::Validate(UI_Tuto::Tuto_ChangeMode());
		CheckTuto();
	}
}

// ---------------------------------- //
/** Add a new macroblock in the recent list
 *
 *	@param	_MacroblockModel		The block to add
 */
Void UpdateRecentMacroblocks(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return;
	
	declare MacroblockModelFullName = Macroblock::GetFullName(_MacroblockModel);
	
	if (!G_RecentMacroblocks.exists(MacroblockModelFullName)) G_RecentMacroblocks.add(MacroblockModelFullName);
	while (G_RecentMacroblocks.count > C_MaxRecentMacroblocks) {
		declare Removed = G_RecentMacroblocks.removekey(0);
	}
}

// ---------------------------------- //
/** Add or remove a macroblock from the player's favaorites
 *
 *	@param	_MacroblockModelId		The if of the block to add or remove
 */
Void UpdateFavoriteMacroblocks(Ident _MacroblockModelId) {
	if (_MacroblockModelId == NullId) return;
	declare MacroblockModel = Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	if (MacroblockModel == Null) return;
	declare MacroblockModelFullName = Macroblock::GetFullName(MacroblockModel);
	
	declare persistent Text[][Text] PartyEditor_FavoriteMacroblocks2 for LocalUser;
	if (!PartyEditor_FavoriteMacroblocks2.existskey(Map.CollectionName)) {
		PartyEditor_FavoriteMacroblocks2[Map.CollectionName] = Text[];
	}
	
	if (PartyEditor_FavoriteMacroblocks2[Map.CollectionName].exists(MacroblockModelFullName)) {
		declare Removed = PartyEditor_FavoriteMacroblocks2[Map.CollectionName].remove(MacroblockModelFullName);
	} else {
		PartyEditor_FavoriteMacroblocks2[Map.CollectionName].add(MacroblockModelFullName);
	}
	
	BrowseMacroblocks2();
}

// ---------------------------------- //
/** Apply a skin on a block
 *
 *	@param	_Block					The block to skin
 *	@param	_Skin					The index of the skin to apply
 */
Void CustomSetBlockSkinIndex(CBlock _Block, Integer _Skin) {
	if (_Block == Null) return;
	if (_Skin == GetBlockSkinIndex(_Block)) return;
	
	G_CacheBlocksSkins[_Block.BlockModel.Id] = _Skin;
	SetBlockSkinIndex(_Block, _Skin);
	MapModified();
}

// ---------------------------------- //
/** Set a skin on a block
 *
 *	@param	_Index					The index of the skin to set
 */
Void SetSkin(Integer _Index) {
	declare SkinBlock <=> GetBlock(UI_SkinSelection::GetBlockCoord());
	if (SkinBlock == Null) return;
	
	CustomSetBlockSkinIndex(SkinBlock, _Index);
}

// ---------------------------------- //
/** Copy or apply the previously selected skin of this macroblock model
 *
 *	@param	_OnlyCopy				Only copy the skin but don't apply them
 *	@param	_MacroblockModel		The macroblock model to skin
 *	@param	_MacroblockCoord		The coordinates of the macroblock
 *	@param	_MacroblockDir			The direction of the macroblock
 */
Void RestoreOrCopySkin(Boolean _OnlyCopy,CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir) {
	if (_MacroblockModel == Null) return;
	
	if (!RandomStyles::CanSkin(_MacroblockModel) || !ThemePack::CanSkin(_MacroblockModel)) return;
	
	declare Coords = Macroblock::GetCoords(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
	if (Coords.count <= 0) return;
	
	declare Int3[] Skinned;
	declare AlreadySkinnedInflatable = False;
	foreach (Coord in Coords) {
		if (Skinned.exists(Coord)) continue;
		
		declare Block <=> GetBlock(Coord);
		if (Block == Null) continue;
		
		declare SkinNb = GetNbBlockModelSkins(Block.BlockModel);
		if (SkinNb <= 1) continue;
		
		// Not perfect, but this is the only solution to avoid reskinning several time the same inflatable
		declare IsInflatable = Collection::IsInflatable(Block.BlockModel.Name);
		if (AlreadySkinnedInflatable && IsInflatable) continue;
		
		
		if (_OnlyCopy) {
			G_CacheBlocksSkins[Block.BlockModel.Id] = GetBlockSkinIndex(Block);
		} else {
			declare SkinIndex = -1;
			
			if (G_CacheBlocksSkins.existskey(Block.BlockModel.Id)) {
				SkinIndex = G_CacheBlocksSkins[Block.BlockModel.Id];
			}
			
			CustomSetBlockSkinIndex(Block, SkinIndex);
		}
		
		if (IsInflatable && !AlreadySkinnedInflatable) AlreadySkinnedInflatable = True;
		if (Block.BlockUnits.count > 1) {
			foreach (BlockUnit in Block.BlockUnits) {
				Skinned.add(Block.Coord + BlockUnit.Offset);
			}
		}
	}
}

// ---------------------------------- //
/** Copy a skin from a macroblock
 *
 *	@param	_MacroblockModel		The macroblock model with the skin to copy
 *	@param	_MacroblockCoord		The coordinates of the macroblock
 *	@param	_MacroblockDir			The direction of the macroblock
 */
Void CopySkin(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir) {
	RestoreOrCopySkin(True, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
}

// ---------------------------------- //
/** Apply the previously selected skin for this macroblock model
 *
 *	@param	_MacroblockModel		The macroblock model to skin
 *	@param	_MacroblockCoord		The coordinates of the macroblock
 *	@param	_MacroblockDir			The direction of the macroblock
 */
Void RestoreSkin(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir) {
	RestoreOrCopySkin(False, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
}

// ---------------------------------- //
/** Apply a random skin to a block
 *
 *	@param	_MacroblockModel		The macroblock model to skin
 *	@param	_MacroblockCoord		The coordinates of the macroblock
 *	@param	_MacroblockDir			The direction of the macroblock
 */
Void RandomSkin(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir) {
	if (_MacroblockModel == Null) return;
	
	if (!RandomStyles::CanSkin(_MacroblockModel) || !ThemePack::CanSkin(_MacroblockModel)) return;
	
	declare Coords = Macroblock::GetCoords(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
	if (Coords.count <= 0) return;
	
	declare Int3[] Skinned;
	declare AlreadySkinnedInflatable = False;
	foreach (Coord in Coords) {
		if (Skinned.exists(Coord)) continue;
		
		declare Block <=> GetBlock(Coord);
		if (Block == Null) continue;
		
		declare SkinNb = GetNbBlockModelSkins(Block.BlockModel);
		if (SkinNb <= 1) continue;
		
		// Not perfect, but this is the only solution to avoid reskinning several time the same inflatable
		declare IsInflatable = Collection::IsInflatable(Block.BlockModel.Name);
		if (AlreadySkinnedInflatable && IsInflatable) continue;
		
		declare SkinIndex = 0;
		declare SkinName = "";
		declare Found = False;
		
		// Find a skin allowed on this macroblock model
		declare AllowedSkins = RandomStyles::GetSkins(_MacroblockModel);
		if (AllowedSkins.count <= 0) {
			if (Collection::GetSkinType(Block) == Collection::SkinType_Billboard()) {
				AllowedSkins = Collection::GetEnviroSkins(Map.CollectionName, True, False);
			} else if (Collection::GetSkinType(Block) == Collection::SkinType_RoadPaint()) {
				AllowedSkins = Collection::GetEnviroSkins(Map.CollectionName, False, True);
			}
		}
		if (AllowedSkins.count > 0) {
			SkinName = AllowedSkins[Random::Rand(0, AllowedSkins.count-1)];
			for (I, 0, SkinNb-1) {
				if (SkinName == GetBlockModelSkinName(Block.BlockModel, I)) {
					SkinIndex = I;
					Found = True;
					break;
				}
			}
		}
		// Find a skin not disabled
		else {
			declare Count = 0;
			while (Count < 20) {
				SkinIndex = Random::Rand(0, SkinNb-1);
				SkinName = GetBlockModelSkinName(Block.BlockModel, SkinIndex);
				Found = !Collection::RandomDisabled(SkinName);
				if (Found) break;
				Count += 1;
			}
		}
		
		if (Found) CustomSetBlockSkinIndex(Block, SkinIndex);
		else CustomSetBlockSkinIndex(Block, -1);
		
		if (IsInflatable && !AlreadySkinnedInflatable) AlreadySkinnedInflatable = True;
		if (Block.BlockUnits.count > 1) {
			foreach (BlockUnit in Block.BlockUnits) {
				Skinned.add(Block.Coord + BlockUnit.Offset);
			}
		}
	}
}

// ---------------------------------- //
/** Custom compute shadows function
 *
 *	@param	_ShadowQuality			The shadow quality to use
 */
Void CustomComputeShadows(CEditorPlugin::ShadowsQuality _ShadowQuality) {
	//if (ShadowsQualityToInt(_ShadowQuality) >= ShadowsQualityToInt(CurrentShadowsQuality)) return;
	
	WaitReady();
	if (C_Debug) {
		ComputeShadows(CEditorPlugin::ShadowsQuality::Fast);
	} else {
		ComputeShadows(_ShadowQuality);
	}
	WaitReady();
	
	MapModified();
}

// ---------------------------------- //
/// Ask the player to select shadows quality and compute
Void CustomComputeShadows() {
	// Forced shadow quality
	if (S_ShadowQuality == C_Shadow_Fast) {
		CustomComputeShadows(CEditorPlugin::ShadowsQuality::Fast);
		return;
	} else if (S_ShadowQuality == C_Shadow_Nice) {
		CustomComputeShadows(CEditorPlugin::ShadowsQuality::Default);
		return;
	}
	
	// If the shadows are already computed in default quality, skip question
	if (CurrentShadowsQuality == CEditorPlugin::ShadowsQuality::Default) return;
	
	// Select shadow quality
	declare Wait = True;
	declare Answer = UI_ShadowMenu::Selection_Null();
	
	UI_ShadowMenu::Show();
	Sound::Play("EditorPopUp");
	SelectSequence();
	
	while (Wait) {
		yield; ///< Yield before events to remove first menu button press
		
		foreach (Event in PendingEvents) {
			if (Event.Type == CEditorPluginEvent::Type::EditorInput) {
				switch (Event.Input) {
					case CEditorPluginEvent::EInput::CursorPlace	: {
						Answer = UI_ShadowMenu::Valid();
						Wait = False;
					}
					case CEditorPluginEvent::EInput::CursorUp		: UI_ShadowMenu::Prev();
					case CEditorPluginEvent::EInput::CursorDown		: UI_ShadowMenu::Next();
					case CEditorPluginEvent::EInput::IconUp			: UI_ShadowMenu::Prev();
					case CEditorPluginEvent::EInput::IconDown		: UI_ShadowMenu::Next();
				}
			} else if (Event.Type == CEditorPluginEvent::Type::LayerCustomEvent) {
				switch (Event.CustomEventType) {
					case UI_ShadowMenu::Event_Hover(): UI_ShadowMenu::Select(TL::ToInteger(Event.CustomEventData[0]), True);
					case UI_ShadowMenu::Event_Click(): {
						UI_ShadowMenu::Select(TL::ToInteger(Event.CustomEventData[0]));
						Answer = UI_ShadowMenu::Valid();
						Wait = False;
					}
					case UI_ShadowMenu::Event_Confirm(): {
						Answer = UI_ShadowMenu::Valid();
						Wait = False;
					}
				}
			}
		}
		
		// Check after the events, to avoid validating in the menu when closing the pad pop-up
		CheckPadConnection();
	}
	
	UI_ShadowMenu::Hide();
	SelectSequence();
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	switch (Answer) {
		case UI_ShadowMenu::Selection_Fast()			: CustomComputeShadows(CEditorPlugin::ShadowsQuality::Fast);
		case UI_ShadowMenu::Selection_Nice()			: CustomComputeShadows(CEditorPlugin::ShadowsQuality::Default);
		case UI_ShadowMenu::Selection_VeryFast()	: CustomComputeShadows(CEditorPlugin::ShadowsQuality::VeryFast);
		case UI_ShadowMenu::Selection_VeryNice()	: CustomComputeShadows(CEditorPlugin::ShadowsQuality::High);
		case UI_ShadowMenu::Selection_None()			: {/* Do not compute shadows */}
		default																		: CustomComputeShadows(CEditorPlugin::ShadowsQuality::Fast);
	}
}

// ---------------------------------- //
/** Preview a terrain block
 *
 *	@param	_TerrainBlockId			Id of the terrain block to preview
 */
Void PreviewTerrainBlock(Ident _TerrainBlockId) {
	if (_TerrainBlockId == NullId) return;
	declare TerrainMacroblock <=> Macroblock::GetMacroblockModelFromId(_TerrainBlockId);
	if (TerrainMacroblock == Null) return;
	
	declare TerrainName = Macroblock::GetName(TerrainMacroblock);
	declare TerrainBlock = GetTerrainBlockModelFromName(TerrainName);
	if (TerrainBlock == Null) return;
	
	CursorTerrainBlockModel = TerrainBlock;
}

// ---------------------------------- //
/** Generate a random terrain
 *
 *	@param	_RandomMap				True if we're generating a full map
 */
Void RandomTerrain(Boolean _RandomMap) {
	LogRandomMap("=================");
	LogRandomMap("Start random terrain");
	
	if (IsEditor(C_Editor_Advanced) && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Landscape())) {
		UI_Tuto::Validate(UI_Tuto::Tuto_Landscape());
		CheckTuto();
	}
	
	SelectMode(C_Categories_Landscape, C_Modes_LandscapeRandom);
	SelectSequence();
	SetCustomTerrain(True);
	
	// ---------------------------------- //
	// Update sequence
	declare Real DecorationProgress;
	declare Text DecorationMessage;
	G_GeneratingTerrain = True;
	SelectSequence();
	SetCursorCoord(<0, 0, 0>);
	
	Sleep(250);
	
	// Move camera
	declare PrevCameraZoom = CameraToTargetDistance;
	declare PrevCameraRotationY = Camera::GetRotation().Y;
	if (_RandomMap) {
		if (!C_DemoSony) Camera::GoTo(C_CameraCoord_Terraforming, C_CameraRot_Terraforming);
	} else {
		Camera::ZoomTo(C_CameraZoom_Terraforming[Map.CollectionName]);
	}
	
	Sound::Play("EditorRemoveBlock");
	
	Sleep(250);
	
	//L16N [MapEditor] Message displayed when generating a random landscape for the player
	DecorationMessage = _("Terraforming in progress");
	DecorationProgress = 0.;
	RemoveAllTerrain();
	
	declare PrevPlaceMode = PlaceMode;
	declare PrevEditMode = EditMode;
	if (C_DemoSony) SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Terraform, CEditorPlugin::EditMode::Place);
	
	declare Count = 0;
	
	if (IsSimpleEditor()) {
		declare LayersCount = ThemePack::GetLayersCount();
		for (Layer, 0, LayersCount-1) {
			Terrain::Random_Start(
				ThemePack::GetType(Layer), 
				ThemePack::GetFrequency(Layer), 
				ThemePack::GetOctaves(Layer), 
				ThemePack::GetTerrainsIntervals(Layer), 
				Layer
			);
			while (!Terrain::Random_Finished()) {
				DecorationProgress = Terrain::Random_Loop();
				Count += 1;
				if (Count % Map.Size.X == 0) {
					if (_RandomMap) Sound::Play("EditorPlaceBlockCommon");
					if (C_FastTerraforming) Yield();
				}
				if (!C_FastTerraforming) Yield();
			}
			Terrain::Random_End();
		}
	} else {
		// Run the generator two times on canyon and stadium
		if (Map.CollectionName == "Canyon" || Map.CollectionName == "Stadium") {
			if (C_RandomMusic) Music::SetTracks([Music::GetTrack("PlaceTerrain_01")]);
			Terrain::Random_Start();
			while (!Terrain::Random_Finished()) {
				DecorationProgress = Terrain::Random_Loop() * 0.5;
				Count += 1;
				if (Count % Map.Size.X == 0) {
					if (C_FastTerraforming) Yield();
				}
				if (!C_FastTerraforming) Yield();
			}
			Terrain::Random_End();
			
			if (C_RandomMusic) Music::SetTracks([Music::GetTrack("PlaceTerrain_01"), Music::GetTrack("PlaceTerrain_02")]);
			Terrain::Random_Start();
			while (!Terrain::Random_Finished()) {
				DecorationProgress = 0.5 + (Terrain::Random_Loop() * 0.5);
				Count += 1;
				if (Count % Map.Size.X == 0) {
					if (C_FastTerraforming) Yield();
				}
				if (!C_FastTerraforming) Yield();
			}
			Terrain::Random_End();
		} else if (Map.CollectionName == "Lagoon") {
			if (C_FastLagoon) {
				if (C_RandomMusic) Music::SetTracks([Music::GetTrack("PlaceTerrain_01"), Music::GetTrack("PlaceTerrain_02")]);
				Terrain::Random_Start(0.15, 2., 2);
				while (!Terrain::Random_Finished()) {
					DecorationProgress = Terrain::Random_Loop();
					Count += 1;
					if (Count % Map.Size.X == 0) {
						if (C_FastTerraforming) Yield();
					}
					if (!C_FastTerraforming) Yield();
				}
				Terrain::Random_End();
			} else {
				if (C_RandomMusic) Music::SetTracks([Music::GetTrack("PlaceTerrain_01")]);
				Terrain::Random_Start(0.15, 1., 1);
				while (!Terrain::Random_Finished()) {
					DecorationProgress = Terrain::Random_Loop() * 0.5;
					Count += 1;
					if (Count % Map.Size.X == 0) {
						if (C_FastTerraforming) Yield();
					}
					if (!C_FastTerraforming) Yield();
				}
				Terrain::Random_End();
				
				if (C_RandomMusic) Music::SetTracks([Music::GetTrack("PlaceTerrain_01"), Music::GetTrack("PlaceTerrain_02")]);
				Terrain::Random_Start();
				while (!Terrain::Random_Finished()) {
					DecorationProgress = 0.5 + (Terrain::Random_Loop() * 0.5);
					Count += 1;
					if (Count % Map.Size.X == 0) {
						if (C_FastTerraforming) Yield();
					}
					if (!C_FastTerraforming) Yield();
				}
				Terrain::Random_End();
			}
		} else {
			if (C_RandomMusic) Music::SetTracks([Music::GetTrack("PlaceTerrain_01"), Music::GetTrack("PlaceTerrain_02")]);
			Terrain::Random_Start();
			while (!Terrain::Random_Finished()) {
				DecorationProgress = Terrain::Random_Loop();
				Count += 1;
				if (Count % Map.Size.X == 0) {
					if (C_FastTerraforming) Yield();
				}
				if (!C_FastTerraforming) Yield();
			}
			Terrain::Random_End();
		}
	}
	
	if (C_DemoSony) SetPlaceAndEditModes(PrevPlaceMode, PrevEditMode);
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	Yield(); //< Wait for the block to be placed before computing shadows
	
	if (_RandomMap) {
	
	} else {
		Camera::ZoomTo(PrevCameraZoom);
		Camera::Rotate(<0., ML::ToReal(PrevCameraRotationY - Camera::GetRotation().Y)>);
	}
	
	DecorationProgress = 0.;
	DecorationMessage = "";
	
	Sleep(250);
	
	declare metadata Text PartyEditor_TerrainId for Map;
	declare metadata Integer PartyEditor_TerrainDir for Map;
	PartyEditor_TerrainId = C_RandomTerrainId;
	PartyEditor_TerrainDir = 0;
	G_PreviewTerrainId = C_RandomTerrainId;
	
	G_GeneratingTerrain = False;
	SelectSequence();
	MapModified();
	
	LogRandomMap("=================");
	LogRandomMap("Stop random terrain");
	LogRandomMap("#################");
}

// ---------------------------------- //
/// Use the current terrain as the base for the map
Void PlaceTerrain() {
	declare metadata Text PartyEditor_TerrainId for Map;
	declare metadata Integer PartyEditor_TerrainDir for Map;
	
	if (PartyEditor_TerrainId == "" && G_PreviewTerrainId == "") return;
	
	Sound::Play("EditorMenuValid");
	
	if (PartyEditor_TerrainId != G_PreviewTerrainId) {
		declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(G_PreviewTerrainId);
		if (!Macroblock::IsTerrain(MacroblockModel)) return;
		
		if (MacroblockModel != Null) {
			RemoveAllTerrain();
			
			// Don't place the custom terrain macroblock
			if (Macroblock::GetName(MacroblockModel) != "Empty") {
				// Get the macroblock data
				declare Int3 Coord;
				declare CEditorPlugin::CardinalDirections Dir;
				if (Placement::Exists(MacroblockModel)) {
					Coord = Placement::GetCoord(MacroblockModel);
					Dir = Placement::GetDir(MacroblockModel);
				}
				
				declare Placed = PlaceMacroblock(MacroblockModel, Coord, Dir);
				if (Placed) {
					PartyEditor_TerrainId = G_PreviewTerrainId;
					PartyEditor_TerrainDir = Utils::DirToInt(Dir);
				}
			}
			// ... but save it as the current terrain id
			else {
				PartyEditor_TerrainId = G_PreviewTerrainId;
				PartyEditor_TerrainDir = 0;
			}
			
			Yield(); //< Wait for the block to be placed before computing shadows
			//CustomComputeShadows(C_FastShadow);
		}
	} else {
		//CustomComputeShadows(C_FastShadow);
		Yield();
	}
	
	declare Valid = True;
	if (!IsSimpleEditor()) {
		Valid = Confirm(
			//L16N [MapEditor] Pop-up asking the player to confirm the use of the current landscape
			_("Confirm landscape"),
			ComposeMultilines([
				//L16N [MapEditor] Pop-up asking the player to confirm the use of the current landscape
				_("You won't be able to choose another landscape."),
				//L16N [MapEditor] Pop-up asking the player to confirm the use of the current landscape
				_("Do you confirm your choice?")
			]),
			//L16N [MapEditor] Validate an action
			_("|Infinitive|Confirm"), 
			//L16N [MapEditor] Cancel an action
			_("Cancel")
		);
	}
	if (!Valid) return;
	
	declare metadata Boolean PartyEditor_IsTerraformed for Map;
	PartyEditor_IsTerraformed = True;
	Camera::Zoom(1);
	
	AutoSave();
	
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	MapModified();
}

// ---------------------------------- //
/** Preview the selected terrain
 *
 *	@param	_MacroblockModelId		The Id of the terrain macroblock to place
 */
Void PreviewTerrain(Ident _MacroblockModelId) {
	declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	if (MacroblockModel == Null) return;
	if (!Macroblock::IsTerrain(MacroblockModel)) return;
	
	// Change terrain
	if (G_PreviewTerrainId != Macroblock::GetId(MacroblockModel)) {
		G_PreviewTerrainTime = Now + C_TerrainPreviewThreshold;
		G_PreviewTerrainId = Macroblock::GetId(MacroblockModel);
	}
	
	if (G_PreviewTerrainTime > 0 && Now >= G_PreviewTerrainTime) {
		declare metadata Text PartyEditor_TerrainId for Map;
		declare metadata Integer PartyEditor_TerrainDir for Map;
		
		G_PreviewTerrainTime = -1;
		
		if (PartyEditor_TerrainId != G_PreviewTerrainId) {
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(G_PreviewTerrainId);
			if (MacroblockModel != Null) {
				RemoveAllTerrain();
				
				// Don't place the custom terrain macroblock ...
				if (Macroblock::GetName(MacroblockModel) != "Empty") {
					// Get the macroblock data
					declare Int3 Coord;
					declare CEditorPlugin::CardinalDirections Dir;
					if (Placement::Exists(MacroblockModel)) {
						Coord = Placement::GetCoord(MacroblockModel);
						Dir = Placement::GetDir(MacroblockModel);
					}
					
					declare Placed = PlaceMacroblock(MacroblockModel, Coord, Dir);
					if (Placed) {
						PartyEditor_TerrainId = G_PreviewTerrainId;
						PartyEditor_TerrainDir = Utils::DirToInt(Dir);
					}
				} 
				// ... but save it as the current terrain id
				else {
					PartyEditor_TerrainId = G_PreviewTerrainId;
					PartyEditor_TerrainDir = 0;
				}
				
				Yield(); //< Wait for the block to be placed before computing shadows
				//CustomComputeShadows(C_FastShadow);
			}
		}
	}
}

// ---------------------------------- //
/// Custom RemoveAll() function that do its job progressively
Void CustomRemoveAll() {
	RemoveAllBlocks();
	
	declare UnitSize = 15;
	for (X, 0, Map.Size.X/UnitSize) {
		for (Y, 0, Map.Size.Y/UnitSize) {
			declare Position = <X*UnitSize, 0, Y*UnitSize>;
			declare Size = Position + <UnitSize, 0, UnitSize>;
			declare Removed = RemoveTerrainBlocks(Position, Size);
			Yield();
		}
	}
	
	RemoveAll();
}

// ---------------------------------- //
/** Preview the selected terrain
 *
 *	@param	_MacroblockModel		The terrain macroblock to place
 *	@param	_Dir					The direction of the terrain
 */
Void PreviewTerrain2(CMacroblockModel _MacroblockModel, CEditorPlugin::CardinalDirections _Dir) {
	if (_MacroblockModel == Null) return;
	if (!Macroblock::IsTerrain(_MacroblockModel)) return;
	
	declare metadata Text PartyEditor_TerrainId for Map;
	declare metadata Integer PartyEditor_TerrainDir for Map;
	G_PreviewTerrainId = Macroblock::GetId(_MacroblockModel);
		
	if (PartyEditor_TerrainId != G_PreviewTerrainId) {
		Sound::Play("EditorPlaceBlockCommon");
		UI_TerrainPreview::Loading(True);
		Sleep(500); //< Let the sound and the animation play
		
		CustomRemoveAll();
		
		declare TerrainName = Macroblock::GetName(_MacroblockModel);
		if (TerrainName != "Empty") {
			declare PartsCount = Terrain::GetPartsCount(TerrainName);
			for (Part, 0, PartsCount-1) {
				declare Placed = Terrain::PlacePart(TerrainName, Part, _Dir);
				Sleep(1000);
			}
			PartyEditor_TerrainId = G_PreviewTerrainId;
			PartyEditor_TerrainDir = Utils::DirToInt(_Dir);
		} else {
			PartyEditor_TerrainId = G_PreviewTerrainId;
			PartyEditor_TerrainDir = 0;
		}
		
		Yield(); //< Wait for the block to be placed before computing shadows
		//CustomComputeShadows(C_FastShadow);
		
		UI_TerrainPreview::SetTerrains(TerrainName, "", 0);
		UI_TerrainPreview::Loading(False);
		
		declare CameraProperties = Terrain::GetTerrainCamera(TerrainName);
		declare CameraPos = CameraProperties["pos"];
		declare CameraRot = <CameraProperties["rot"].X, CameraProperties["rot"].Y>;
		Camera::GoTo(CameraPos, CameraRot, 0);
		Camera::SetZoomMinMax(Camera::Default_ZoomMin(), C_CameraZoom_Terraforming[Map.CollectionName]);
		Camera::MouseNeedInit(True);
	}
	
	UpdateLandscapeSimpleChoice();
	MapModified();
}

// ---------------------------------- //
/// Place and confirm a terrain in the menu
Void SelectTerrain() {
	declare metadata Text PartyEditor_TerrainId for Map;
	if (PartyEditor_TerrainId == "" || Macroblock::GetId(ThemePack::GetTerrain()) != PartyEditor_TerrainId) {
		if (C_RandomLandscape) RandomTerrain(False); ///< Generate random terrain
		else PreviewTerrain2(ThemePack::GetTerrain(), CEditorPlugin::CardinalDirections::North);
	} else {
		PlaceTerrain();
		Camera::DefaultZoomMinMax();
		Camera::MouseNeedInit(False);
	}
}

// ---------------------------------- //
/// Check if we can skip the terraforming sequence
Void CanSkipTerrain() {
	// Disabled
	return;
	
	// Skip terraforming on stadium
	if (IsEditor(C_Editor_Advanced) && Map.CollectionName == "Stadium" && !IsTerraformed()) {
		declare metadata Boolean PartyEditor_IsTerraformed for Map;
		declare metadata Text PartyEditor_TerrainId for Map;
		declare metadata Integer PartyEditor_TerrainDir for Map;
		PartyEditor_IsTerraformed = True;
		PartyEditor_TerrainId = "GrassStadium";
		PartyEditor_TerrainDir = 0;
	}
}

// ---------------------------------- //
/// Remove the terrain base from the map
Void RemoveTerrain() {
	declare metadata Boolean PartyEditor_IsTerraformed for Map;
	declare metadata Text PartyEditor_TerrainId for Map;
	declare metadata Integer PartyEditor_TerrainDir for Map;
	PartyEditor_IsTerraformed = False;
	PartyEditor_TerrainId = "";
	PartyEditor_TerrainDir = 0;
	G_PreviewTerrainTime = -1;
	G_PreviewTerrainId = "";
	
	CanSkipTerrain();
}

// ---------------------------------- //
/** Automatically switch between connected/disconnected mode
 *
 *	@param	_Coord					The coordinates to check
 */
Void AutoConnectedMode(Int3 _Coord) {
	if (!IsEditor(C_Editor_Advanced)) {
		G_MoveCursor = False;
		return;
	}
	
	declare Coord = _Coord;
	if (!MapContent::Exists(Coord)) Coord = MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, False);
	
	// There is a previous macroblock but it doesn't have an open clip
	if (MapContent::Exists(Coord)) {
		declare MacroblockModel <=> MapContent::GetMacroblockModel(Coord);
		declare MacroblockCoord = MapContent::GetMacroblockCoord(Coord);
		declare MacroblockDir = MapContent::GetMacroblockDir(Coord);
		declare DisconnectedClips = MapContent::GetDisconnectedClips(MacroblockModel, MacroblockCoord, MacroblockDir);
		
		if (DisconnectedClips.count <= 0) G_MoveCursor = True;
		else G_MoveCursor = False;
	} 
	// There isn't a previous macroblock
	else {
		G_MoveCursor = True;
	}
}

// ---------------------------------- //
/** Place the cursor at the right position
 *	to continue with the connection of the following macroblock
 *	if no connection is available, switch to free mode
 *
 *	@param	_Add					Add or remove the macroblock
 *	@param	_MacroblockModel		The macroblock model
 *	@param	_MacroblockCoord		The macroblock coordinates
 *	@param	_MacroblockDir			The macroblock direction
 */
Void SetTrackCursorCoord(Boolean _Add, CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir) {
	// Select the macroblock coord as the default coord
	declare Coord = _MacroblockCoord;
	
	// Adding a macroblock
	if (_Add) {
		// We want to select any block unit of this macroblock
		declare Coords = Macroblock::GetCoords(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
		if (Coords.count > 0) Coord = Coords[0];
	} 
	// Removing a macroblock
	else {
		// We want to select any block unit of a macroblock placed chronogically before this macroblock
		declare ConnectedCoords = MapContent::GetConnectedMacroblockUnitCoords(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
		declare MaxOrder = -1;
		foreach (ConnectedCoord in ConnectedCoords) {
			declare Order = MapContent::GetMacroblockOrder(ConnectedCoord);
			if (MaxOrder < 0 || Order > MaxOrder) {
				MaxOrder = Order;
				Coord = ConnectedCoord;
			}
		}
	}
	
	AutoConnectedMode(Coord);
	
	SetCursorMacroblockModel(_MacroblockModel);
	SetCursorCoord(_MacroblockCoord, Coord);
	SetCursorDir(_MacroblockDir);
	
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
}

// ---------------------------------- //
/** Place the cursor at the right position
 *
 *	@param	_Add					Add or remove the macroblock
 *	@param	_MacroblockModel		The macroblock model
 *	@param	_MacroblockCoord		The macroblock coordinates
 *	@param	_MacroblockDir			The macroblock direction
 */
Void AutoCursorCoord(Boolean _Add, CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir) {
	if (G_Mode == C_Modes_ConstructTrack) {
		SetTrackCursorCoord(_Add, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
	} else if (G_Mode == C_Modes_ConstructDeco) {
		SetCursorMacroblockModel(_MacroblockModel);
		SetCursorCoord(_MacroblockCoord);
		SetCursorDir(_MacroblockDir);
		if (_MacroblockModel != Null) UI_MacroblockSelection::FindMacroblock(_MacroblockModel.Id);
	} else {
		SetCursorCoord(_MacroblockCoord);
		Camera::MoveTo(_MacroblockCoord);
	}
}

// ---------------------------------- //
/** Remove content from the map
 *
 *	@param	_MacroblockModel		The macroblock model
 *	@param	_MacroblockCoord		The macroblock coordinates
 *	@param	_MacroblockDir			The macroblock direction
 *	@param	_MacroblockType			The macroblock type
 */
Void RemoveContent(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir, Integer _MacroblockType) {
	AutoCursorCoord(False, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
	
	if (_MacroblockType == C_Modes_ConstructTrack || _MacroblockType == C_Modes_ConstructDeco) {
		MapContent::Remove(_MacroblockModel, _MacroblockCoord, _MacroblockDir, _MacroblockType);
		MapModified();
	}
}

// ---------------------------------- //
/** Add content to the map
 *
 *	@param	_MacroblockModel		The macroblock model
 *	@param	_MacroblockCoord		The macroblock coordinates
 *	@param	_MacroblockDir			The macroblock direction
 *	@param	_MacroblockType			The macroblock type
 */
Void AddContent(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir, Integer _MacroblockType) {
	if (_MacroblockType == C_Modes_ConstructTrack || _MacroblockType == C_Modes_ConstructDeco) {
		MapContent::Add(_MacroblockModel, _MacroblockCoord, _MacroblockDir, _MacroblockType);
		MapModified();
	}
	
	AutoCursorCoord(True, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
}

// ---------------------------------- //
/** Save a new state in the history
 *
 *	@param	_Action					The action to save
 *	@param	_Mode					The mode to save
 *	@param	_MacroblockModelsIds	The ids of the macroblock models
 *	@param	_MacroblocksCoords		The coordinates of the macroblocks
 *	@param	_MacroblocksDirs		The directions of the macroblocks
 *	@param	_MacroblocksEdits		True if the macroblocks can be edited
 */
Void SaveHistory2(Integer _Action, Integer _Mode, Ident[] _MacroblockModelsIds, Int3[] _MacroblocksCoords, CEditorPlugin::CardinalDirections[] _MacroblocksDirs) {
	// Save content of the map if we added or removed a macroblock
	if (_Mode == C_Modes_ConstructTrack || _Mode == C_Modes_ConstructDeco) {
		foreach (Key => MacroblockModelId in _MacroblockModelsIds) {
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
			declare MacroblockCoord = _MacroblocksCoords[Key];
			declare MacroblockDir = _MacroblocksDirs[Key];
			
			if (_Action == History2::Action_Add()) {
				MapContent::Add(MacroblockModel, MacroblockCoord, MacroblockDir, _Mode);
				MapModified();
			} else if (_Action == History2::Action_Remove()) {
				MapContent::Remove(MacroblockModel, MacroblockCoord, MacroblockDir, _Mode);
				MapModified();
			}
		}
	}
	
	/*	In the expert editor, when placing a macroblock with terraforming
	 *	we need to clean the map content from the macroblocks that were
	 *	automatically removed by the terrain
	 */
	if (IsEditor(C_Editor_Expert)) {
		// Get the keys of the broken macroblocks
		declare KeysToRemove = MapContent::Clean();
		
		// List the broken macroblocks properties
		declare MacroblocksActions = Integer[];
		declare MacroblocksTypes = Integer[];
		declare MacroblockModelsIds = Ident[];
		declare MacroblocksCoords = Int3[];
		declare MacroblocksDirs = CEditorPlugin::CardinalDirections[];
		foreach (Key in KeysToRemove) {
			declare MacroblockType = MapContent::GetMacroblockType(Key);
			declare MacroblockModel <=> MapContent::GetMacroblockModel(Key);
			declare MacroblockCoord = MapContent::GetMacroblockCoord(Key);
			declare MacroblockDir = MapContent::GetMacroblockDir(Key);
			
			MacroblocksActions.add(History2::Action_Remove());
			MacroblocksTypes.add(MacroblockType);
			MacroblockModelsIds.add(MacroblockModel.Id);
			MacroblocksCoords.add(MacroblockCoord);
			MacroblocksDirs.add(MacroblockDir);
			
			// Ensure that the macroblock was removed
			declare Removed = Macroblock::Remove(MacroblockModel, MacroblockCoord, MacroblockDir);
		}
		
		// Remove the macroblocks from the map content
		foreach (Key in KeysToRemove) {
			MapContent::Remove(Key);
			MapModified();
		}
	
		// /!\ Must be before History2::Bind() /!\
		// In normal editor, save history only for track block
		if (!CutPasteIsAllowed() || _Mode == C_Modes_ConstructTrack) {
			History2::Save(_Action, _Mode, _MacroblockModelsIds, _MacroblocksCoords, _MacroblocksDirs);
			AutoSave();
		}
		
		// /!\ Must be after History2::Save() /!\
		// Save the removed macroblocks in the history
		if (MacroblocksActions.count > 0) History2::Bind(MacroblocksActions, MacroblocksTypes, MacroblockModelsIds, MacroblocksCoords, MacroblocksDirs);
	} else {
		if (!CutPasteIsAllowed() || _Mode == C_Modes_ConstructTrack) {
			History2::Save(_Action, _Mode, _MacroblockModelsIds, _MacroblocksCoords, _MacroblocksDirs);
			AutoSave();
		}
	}
}

// ---------------------------------- //
/** Save a new state in the history
 *
 *	@param	_Action					The action to save
 *	@param	_Mode					The mode to save
 *	@param	_MacroblockModelId		The id of the macroblock
 *	@param	_MacroblockCoord		The coordinates of the macroblock
 *	@param	_MacroblockDir			The direction of the macroblock
 */
Void SaveHistory2(Integer _Action, Integer _Mode, Ident _MacroblockModelId, Int3 _MacroblockCoord, CEditorPlugin::CardinalDirections _MacroblockDir) {
	SaveHistory2(_Action, _Mode, [_MacroblockModelId], [_MacroblockCoord], [_MacroblockDir]);
}

// ---------------------------------- //
/** Undo history
 *
 *	@param	_Browse					Browse macroblocks after undoing history
 */
Void UndoHistory2(Boolean _Browse, Boolean _Cut) {
	declare Action = History2::GetAction();
	declare Mode = History2::GetMode();
	declare MacroblockModelsIds = History2::GetMacroblockModelsIds();
	declare MacroblocksCoords = History2::GetMacroblocksCoords();
	declare MacroblocksDirs = History2::GetMacroblocksDirs();
	
	declare BindActions = History2::GetBindActions();
	declare BindModes = History2::GetBindModes();
	declare BindIds = History2::GetBindIds();
	declare BindCoords = History2::GetBindCoords();
	declare BindDirs = History2::GetBindDirs();
	
	declare Undone = History2::Undo();
	if (Undone) {
		SelectMode(C_Categories_Construct, Mode);
		
		Undo();
		Yield();
		
		SelectSequence(); //< We have to be sure we are in the right sequence mode
		
		// Add / Remove the binded macroblocks
		foreach (Key => BindAction in BindActions) {
			declare BindMode = BindModes[Key];
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(BindIds[Key]);
			declare MacroblockCoord = BindCoords[Key];
			declare MacroblockDir = BindDirs[Key];
			
			if (BindAction == History2::Action_Add()) {
				RemoveContent(MacroblockModel, MacroblockCoord, MacroblockDir, BindMode);
			} else if (BindAction == History2::Action_Remove()) {
				AddContent(MacroblockModel, MacroblockCoord, MacroblockDir, BindMode);
			}
		}
		
		declare FindMacroblockModelId = NullId;
		declare FindMacroblockCoord = Utils::NullCoord();
		declare FindMacroblockDir = CEditorPlugin::CardinalDirections::North;
		foreach (Key => MacroblockModelId in MacroblockModelsIds) {
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
			declare MacroblockCoord = MacroblocksCoords[Key];
			declare MacroblockDir = MacroblocksDirs[Key];
			FindMacroblockModelId = MacroblockModelId;
			FindMacroblockCoord = MacroblockCoord;
			FindMacroblockDir = MacroblockDir;
			
			if (Action == History2::Action_Add()) {
				RemoveContent(MacroblockModel, MacroblockCoord, MacroblockDir, Mode);
			} else if (Action == History2::Action_Remove()) {
				AddContent(MacroblockModel, MacroblockCoord, MacroblockDir, Mode);
			}
		}
		
		if ((_Browse || _Cut) && G_Mode == C_Modes_ConstructTrack && (!IsFreeMode() || CutPasteIsAllowed())) {
			// If there are several macroblocks, find where to connect the next macroblock
			if (MacroblockModelsIds.count > 0) {
				foreach (Key => MacroblockModelId in MacroblockModelsIds) {
					declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
					declare MacroblockCoord = MacroblocksCoords[Key];
					declare MacroblockDir = MacroblocksDirs[Key];
					
					if (Action == History2::Action_Add()) {
						if (MapContent::GetDisconnectedClips(MacroblockModel, MacroblockCoord, MacroblockDir).count > 0) {
							SetTrackCursorCoord(False, MacroblockModel, MacroblockCoord, MacroblockDir);
							FindMacroblockModelId = MacroblockModelId;
							FindMacroblockCoord = MacroblockCoord;
							FindMacroblockDir = MacroblockDir;
							break;
						}
					} else if (Action == History2::Action_Remove()) {
						if (MapContent::GetConnectedClips(MacroblockModel, MacroblockCoord, MacroblockDir).count > 0) {
							SetTrackCursorCoord(True, MacroblockModel, MacroblockCoord, MacroblockDir);
							FindMacroblockModelId = MacroblockModelId;
							FindMacroblockCoord = MacroblockCoord;
							FindMacroblockDir = MacroblockDir;
							break;
						}
					}
				}
			}
			
			BrowseMacroblocks2();
		}
		
		// Select the next macroblock in the history by default
		if (Action == History2::Action_Remove()) {
			declare NextMacroblockModelsIds = History2::GetMacroblockModelsIds();
			if (NextMacroblockModelsIds.count > 0) FindMacroblockModelId = NextMacroblockModelsIds[0];
			declare NextMacroblockCoords = History2::GetMacroblocksCoords();
			if (NextMacroblockCoords.count > 0) FindMacroblockCoord = NextMacroblockCoords[0];
			declare NextMacroblockDirs = History2::GetMacroblocksDirs();
			if (NextMacroblockDirs.count > 0) FindMacroblockDir = NextMacroblockDirs[0];
		} 
		// Cut
		else if (Action == History2::Action_Add() && _Cut) {
			declare FindMacroblockModel <=> Macroblock::GetMacroblockModelFromId(FindMacroblockModelId);
			// Can't cut the start
			// Save cutted macroblock
			if (_Cut && FindMacroblockModel != Null && !FindMacroblockModel.HasStart && !FindMacroblockModel.HasMultilap) {
				declare ConnectionToPrevious = MapContent::GetConnectionToPrevious(FindMacroblockModel, FindMacroblockCoord, FindMacroblockDir);
				declare PrevMacroblockModel <=> MapContent::GetMacroblockModel(G_CursorCoord);
				declare PrevMacroblockModelId = NullId;
				if (PrevMacroblockModel != Null) PrevMacroblockModelId = PrevMacroblockModel.Id;
				CutPaste::Cut(PrevMacroblockModelId, ConnectionToPrevious[0], FindMacroblockModelId, ConnectionToPrevious[1]);
			}
		}
		
		if (FindMacroblockModelId != NullId) {
			SelectMacroblock(FindMacroblockModelId, FindMacroblockCoord, FindMacroblockDir);
			MoveMacroblock(<0, 0, 0>, False);
		}
		if (CanNotify()) {
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : cutting a block in the track.
			if (_Cut) UI_BlockHelp::Notify(_("Cut"));
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : undoing the last done action.
			else UI_BlockHelp::Notify(_("Undo"));
		}
	}
}

// ---------------------------------- //
/// Undo history
Void UndoHistory2() {
	UndoHistory2(True, False);
}

// ---------------------------------- //
/** Redo history
 *
 *	@param	_Browse					Browse macroblocks after undoing history
 */
Void RedoHistory2(Boolean _Browse) {
	declare Redone = History2::Redo();
	
	if (Redone) {
		declare Action = History2::GetAction();
		declare Mode = History2::GetMode();
		declare MacroblockModelsIds = History2::GetMacroblockModelsIds();
		declare MacroblocksCoords = History2::GetMacroblocksCoords();
		declare MacroblocksDirs = History2::GetMacroblocksDirs();
		
		declare BindActions = History2::GetBindActions();
		declare BindModes = History2::GetBindModes();
		declare BindIds = History2::GetBindIds();
		declare BindCoords = History2::GetBindCoords();
		declare BindDirs = History2::GetBindDirs();
		
		SelectMode(C_Categories_Construct, Mode);
		
		Redo();
		Yield();
		
		SelectSequence(); //< We have to be sure we are in the right sequence mode
		
		// Add / Remove the binded macroblocks
		foreach (Key => BindAction in BindActions) {
			declare BindMode = BindModes[Key];
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(BindIds[Key]);
			declare MacroblockCoord = BindCoords[Key];
			declare MacroblockDir = BindDirs[Key];
			
			if (BindAction == History2::Action_Add()) {
				AddContent(MacroblockModel, MacroblockCoord, MacroblockDir, BindMode);
			} else if (BindAction == History2::Action_Remove()) {
				RemoveContent(MacroblockModel, MacroblockCoord, MacroblockDir, BindMode);
			}
		}
		
		declare FindMacroblockModelId = NullId;
		declare FindMacroblockCoord = Utils::NullCoord();
		declare FindMacroblockDir = CEditorPlugin::CardinalDirections::North;
		foreach (Key => MacroblockModelId in MacroblockModelsIds) {
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
			declare MacroblockCoord = MacroblocksCoords[Key];
			declare MacroblockDir = MacroblocksDirs[Key];
			FindMacroblockModelId = MacroblockModelId;
			FindMacroblockCoord = MacroblockCoord;
			FindMacroblockDir = MacroblockDir;
			
			if (Action == History2::Action_Add()) {
				AddContent(MacroblockModel, MacroblockCoord, MacroblockDir, Mode);
			} else if (Action == History2::Action_Remove()) {
				RemoveContent(MacroblockModel, MacroblockCoord, MacroblockDir, Mode);
			}
		}
		
		if (_Browse && G_Mode == C_Modes_ConstructTrack && (!IsFreeMode() || CutPasteIsAllowed())) {
			// If there are several macroblocks, find where to connect the next macroblock
			if (MacroblockModelsIds.count > 0) {
				foreach (Key => MacroblockModelId in MacroblockModelsIds) {
					declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
					declare MacroblockCoord = MacroblocksCoords[Key];
					declare MacroblockDir = MacroblocksDirs[Key];
					
					if (Action == History2::Action_Add()) {
						if (MapContent::GetDisconnectedClips(MacroblockModel, MacroblockCoord, MacroblockDir).count > 0) {
							SetTrackCursorCoord(True, MacroblockModel, MacroblockCoord, MacroblockDir);
							FindMacroblockModelId = MacroblockModelId;
							FindMacroblockCoord = MacroblockCoord;
							FindMacroblockDir = MacroblockDir;
							break;
						}
					} else if (Action == History2::Action_Remove()) {
						if (MapContent::GetConnectedClips(MacroblockModel, MacroblockCoord, MacroblockDir).count > 0) {
							SetTrackCursorCoord(False, MacroblockModel, MacroblockCoord, MacroblockDir);
							FindMacroblockModelId = MacroblockModelId;
							FindMacroblockCoord = MacroblockCoord;
							FindMacroblockDir = MacroblockDir;
							break;
						}
					}
				}
			}
			
			BrowseMacroblocks2();
		}
		
		// Select the next macroblock in the history by default
		if (Action == History2::Action_Add()) {
			declare NextMacroblockModelsIds = History2::GetMacroblockModelsIds(History2::GetCursor()+1);
			if (NextMacroblockModelsIds.count > 0) FindMacroblockModelId = NextMacroblockModelsIds[0];
			declare NextMacroblockCoords = History2::GetMacroblocksCoords(History2::GetCursor()+1);
			if (NextMacroblockCoords.count > 0) FindMacroblockCoord = NextMacroblockCoords[0];
			declare NextMacroblockDirs = History2::GetMacroblocksDirs(History2::GetCursor()+1);
			if (NextMacroblockDirs.count > 0) FindMacroblockDir = NextMacroblockDirs[0];
		}
		if (FindMacroblockModelId != NullId) {
			SelectMacroblock(FindMacroblockModelId, FindMacroblockCoord, FindMacroblockDir);
			MoveMacroblock(<0, 0, 0>, False);
		}
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : redoing the last undone action.
		if (CanNotify()) UI_BlockHelp::Notify(_("Redo"));
	}
}

// ---------------------------------- //
/// Redo history
Void RedoHistory2() {
	RedoHistory2(True);
}

// ---------------------------------- //
/** Connect a macroblock
 *
 *	@param	_MacroblockModel		The macroblock model to connect
 *	@param	_MacroblockModelCoord	The macroblock coordinates
 *	@param	_MacroblockDir			The macroblock direction
 *	@param	_Browse					Browse macroblocks after placing the macroblock
 *	@param	_Notify					Display a notification
 *
 *	@return							True if the macroblock was placed, False otherwise
 */
Boolean AddMacroblock2(
	CMacroblockModel _MacroblockModel, 
	Int3 _MacroblockCoord, 
	CEditorPlugin::CardinalDirections _MacroblockDir,
	Boolean _Browse,
	Boolean _Notify
) {
	// Check copper limit if the macroblock is not a finish line
	if (MustCheckCoppersLimit() && Map.CopperPrice >= C_CopperLimit_Hard && (MapContent::HasFinish() || !_MacroblockModel.HasFinish)) {
		Alert(
			//L16N [MapEditor] Title of a pop-up displaying informations about the track editor
			_("Warning"), 
			//L16N [MapEditor] Pop-up warning the player that he reached the maximum number of blocks placed in the map and can't add more.
			_("You reached the maximum number of blocks. You cannot add more."),
			//L16N [MapEditor] Confirm an action
			_("|Infinitive|Confirm")
		);
		return False;
	}
	
	if (_MacroblockModel == Null) return False;
	if (!CustomCanPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir, True)) {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : placing a block in the track.
		if (_Notify && CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Place")));
		return False;
	}
	
	declare MacroblockPlaced = False;
	declare TransitionPlaced = False;
	declare CMacroblockModel TransitionMacroblockModel;
	declare Int3 TransitionCoord;
	declare CEditorPlugin::CardinalDirections TransitionDir;
	
	// Try to place the macroblock without transition
	if (CustomCanPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir, False)) {
		MacroblockPlaced = CustomPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
	}
	// Can't place the macroblock, does it need a transition?
	else if (Transitions::HasTransitions(_MacroblockModel)) {
		declare DisconnectedClips = MapContent::GetDisconnectedClips(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
		foreach (ClipId in DisconnectedClips) {
			declare Transitions = Transitions::GetTransitions(_MacroblockModel, _MacroblockCoord, _MacroblockDir, ClipId);
			foreach (Transition in Transitions) {
				TransitionMacroblockModel <=> Transitions::GetTransitionMacroblockModel(_MacroblockModel, Transition);
				TransitionCoord = Transitions::GetTransitionCoord(_MacroblockModel, Transition);
				TransitionDir = Transitions::GetTransitionDir(_MacroblockModel, Transition);
				
				// Place transition
				TransitionPlaced = CustomPlaceMacroblock(TransitionMacroblockModel, TransitionCoord, TransitionDir);
				
				// Place the macroblock
				if (TransitionPlaced && CustomCanPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir, False)) {
					MacroblockPlaced = CustomPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
				}
				
				// Remove transition if we couldn't place the macroblock
				if (TransitionPlaced && !MacroblockPlaced) {
					TransitionPlaced = False;
					declare Removed = Macroblock::Remove(TransitionMacroblockModel, TransitionCoord, TransitionDir);
				}
				
				if (MacroblockPlaced) break;
			}
		}
	}
	
	// Transition place success
	if (TransitionPlaced) {
		UpdateRecentMacroblocks(TransitionMacroblockModel);
		
		if (IsEditor(C_Editor_Expert) && !G_RandomMapGeneration) RestoreSkin(TransitionMacroblockModel, TransitionCoord, TransitionDir);
		else RandomSkin(TransitionMacroblockModel, TransitionCoord, TransitionDir);
		
		AutoCursorCoord(True, TransitionMacroblockModel, TransitionCoord, TransitionDir);
	}
	
	// Macroblock place success
	if (MacroblockPlaced) {
		if (!G_RandomMapGeneration) {
			if (G_Mode == C_Modes_ConstructDeco) {
				Sound::Play("EditorPlaceBlockDeco");
			} else if (_MacroblockModel.HasCheckpoint) {
				Sound::Play("EditorPlaceBlockCheckpoint");
			} else if (_MacroblockModel.HasFinish) {
				Sound::Play("EditorPlaceBlockFinish");
			} else if (_MacroblockModel.HasStart || _MacroblockModel.HasMultilap) {
				Sound::Play("EditorPlaceBlockStart");
			} else {
				Sound::Play("EditorPlaceBlockCommon");
			}
		}
		
		if (TransitionPlaced) {
			SaveHistory2(History2::Action_Add(), G_Mode, [_MacroblockModel.Id, TransitionMacroblockModel.Id], [_MacroblockCoord, TransitionCoord], [_MacroblockDir, TransitionDir]);
		} else {
			SaveHistory2(History2::Action_Add(), G_Mode, _MacroblockModel.Id, _MacroblockCoord, _MacroblockDir);
		}
		
		UpdateRecentMacroblocks(_MacroblockModel);
		
		if (IsEditor(C_Editor_Expert) && !G_RandomMapGeneration) RestoreSkin(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
		else RandomSkin(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
		
		if (!TransitionPlaced) {
			AutoCursorCoord(True, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
		}
		
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Multilaps()) && _MacroblockModel.HasMultilap) {
			UI_Tuto::Validate(UI_Tuto::Tuto_Multilaps());
			CheckTuto();
		}
		
		G_CanAskCheckpoint = True;
		
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : placing a block in the track.
		if (_Notify && CanNotify()) UI_BlockHelp::Notify(_("Place"));
	} else {
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : placing a block in the track.
		if (_Notify && CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Place")));
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
	}
	
	// Find the right style to continue
	if (IsSimpleEditor()) AutoSelectStyle();
	
	// Show a selection of compatible blocks to connect
	if (Utils::IsTrialVersion()) {
		if (_Browse && MacroblockPlaced) BrowseMacroblocks2();
	} else {
		if (_Browse) BrowseMacroblocks2();
	}
	
	if (IsEditor(C_Editor_Expert)) {
		DisplaySkinSelection(CursorCoord);
		SetCursorStyle();
	}
	
	CheckAdvices();
	CheckTuto();
	
	return MacroblockPlaced;
}

// ---------------------------------- //
/** Connect the given macroblock to the previous one
 *
 *	@param	_MacroblockModelId		The Id of the macroblock to connect
 *	@param	_Browse					Browse macroblocks after placing the macroblock
 */
Boolean AddMacroblock2(Ident _MacroblockModelId, Boolean _Browse) {
	// Get the macroblock model to use
	declare CMacroblockModel MacroblockModel;
	if (_MacroblockModelId == NullId) {
		MacroblockModel <=> GetRandomMacroblock();
	} else {
		MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	}
	if (MacroblockModel == Null) return False;
	
	// Get the macroblock coordinates and direction
	declare Int3 BlockCoord; 
	declare CEditorPlugin::CardinalDirections BlockDir;
	if (IsFreeMode() || !MapContent::HasStart()) {
		BlockCoord = CursorCoord;
		BlockDir = CursorDir;
	} else {
		if (Placement::Exists(MacroblockModel)) {
			BlockCoord = Placement::GetCoord(MacroblockModel);
			BlockDir = Placement::GetDir(MacroblockModel);
		}
	}
	
	return AddMacroblock2(MacroblockModel, BlockCoord, BlockDir, _Browse, True);
}

// ---------------------------------- //
/// Overload ConnectMacroblock
Boolean AddMacroblock2(Ident _MacroblockModelId) {
	if (CutPasteIsAllowed() && UI_Tuto::IsEnabled(UI_Tuto::Tuto_CutPaste())) {
		UI_Tuto::Disable(UI_Tuto::Tuto_CutPaste());
	}
	return AddMacroblock2(_MacroblockModelId, True);
}

// ---------------------------------- //
/// Add a random macroblock
Void AddRandomMacroblock2() {
	if (G_LastRandomPlace > 0 && Now - G_LastRandomPlace < C_RandomDecorationDelay) return;
	G_LastRandomPlace = Now;
	
	declare MacroblockPlaced = AddMacroblock2(NullId);
}

// ---------------------------------- //
/// Start a new track
Void AddStartMacroblock2() {
	if (G_CursorMacroblockModel == Null) return;
	if (!G_CursorMacroblockModel.HasStart && !G_CursorMacroblockModel.HasMultilap) return;
	
	declare MacroblockPlaced = AddMacroblock2(G_CursorMacroblockModel.Id);
	
	if (IsEditor(C_Editor_Expert) && !G_RandomMapGeneration) {
		switch (CursorDir) {
			case CEditorPlugin::CardinalDirections::North	: MoveMacroblock(<0, 0, 1>, False);
			case CEditorPlugin::CardinalDirections::West	: MoveMacroblock(<1, 0, 0>, False);
			case CEditorPlugin::CardinalDirections::South	: MoveMacroblock(<0, 0, -1>, False);
			case CEditorPlugin::CardinalDirections::East	: MoveMacroblock(<-1, 0, 0>, False);
		}
	}
}

// ---------------------------------- //
/** Add a decoration macroblock
 *
 *	@param	_MacroblockModelId		The id of the macroblock model
 *
 *	@return							True if the macroblock was placed, False otherwise
 */
Boolean AddDecoMacroblock2(Ident _MacroblockModelId) {
	// Get the macroblock model to use
	declare CMacroblockModel MacroblockModel;
	if (_MacroblockModelId != NullId) {
		MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	}
	if (MacroblockModel == Null) return False;
	
	// Get the macroblock coordinates and direction
	if (Placement::Exists(MacroblockModel, CursorDir)) {
		declare BlockDirs = Placement::GetDirs(MacroblockModel);
		Placement::Select(MacroblockModel, BlockDirs.keyof(CursorDir));
	}
	
	declare MacroblockPlaced = AddMacroblock2(_MacroblockModelId);
	DisplaySkinSelection(CursorCoord);
	CheckTuto();
	CheckHelper();
	
	return MacroblockPlaced;
}

// ---------------------------------- //
/** Add a terrain block
 *
 *	@param	_Terrain				The terrain to add
 *	@param	_StartCoord				The starting coordinates of the block
 *	@param	_EndCoord				The ending coordinates of the block
 */
Void AddTerrain2(CBlockModel _Terrain, Int3 _StartCoord, Int3 _EndCoord) {
	declare Placed = PlaceTerrainBlocks/*_NoDestruction*/(_Terrain, _StartCoord, _EndCoord);
	if (Placed) {
		if (!G_RandomMapGeneration) Sound::Play("EditorPlaceBlockCommon");
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : adding a terrain block in the landscape.
		if (CanNotify()) UI_BlockHelp::Notify(_("Add"));
		SaveHistory2(History2::Action_Add(), C_Modes_ConstructTerrain, NullId, _StartCoord, CEditorPlugin::CardinalDirections::North);
		
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_EditTerrain())) {
			UI_Tuto::Validate(UI_Tuto::Tuto_EditTerrain());
			CheckTuto();
		}
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : adding a terrain block in the landscape.
		if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Add")));
	}
	
	// Undo the terrain modification if it exceeds the copper limit
	Yield(); ///< yield to update map copper price
	if (Placed && MustCheckCoppersLimit() && Map.CopperPrice >= C_CopperLimit_Hard) {
		UndoHistory2();
		Alert(
			//L16N [MapEditor] Title of a pop-up displaying informations about the track editor
			_("Warning"), 
			//L16N [MapEditor] Pop-up warning the player that he reached the maximum number of blocks placed in the map and can't add more.
			_("You reached the maximum number of blocks. You cannot add more."),
			//L16N [MapEditor] Confirm an action
			_("|Infinitive|Confirm")
		);
	}
}


// ---------------------------------- //
/* Add a terrain block
 *
 *	@param	_CursorPlace			True to start the selection, False to end it
 */
Void AddTerrain2(Boolean _CursorPlace) {
	// Start selection
	if (_CursorPlace) {
		Selection::Start(CursorCoord);
		Selection::SetColor(<0., 0., 0.3>);
		Selection::Show();
	} 
	// Stop selection
	else {
		if (CursorTerrainBlockModel != Null) {
			Selection::Stop(CursorCoord);
			AddTerrain2(CursorTerrainBlockModel, Selection::GetStart(), Selection::GetEnd());
		}
		Selection::Hide();
		Selection::Destroy();
		SetCursorStyle();
		Camera::MoveTo(CursorCoord);
	}
}

// ---------------------------------- //
/** Remove a macroblock
 *
 *	@param	_Coord					The coordinates of one the block unit of the macroblock to remove
 *	@param	_Type					The type of macroblock to remove
 *	@param	_Cut					Cut and save the macroblock
 *	@param	_MoveCameraTo			Move the camera to the block position
 */
Void RemoveMacroblock2(Int3 _Coord, Integer _Type, Boolean _Cut, Boolean _MoveCameraTo) {
	if (_Cut && IsEditor(C_Editor_Advanced)) {
		UndoHistory2(True, True);
		return;
	}
	
	declare MacroblockType = MapContent::GetMacroblockType(_Coord);
	declare CannotRemoveOtherType = G_RandomMapGeneration || !IsEditor(C_Editor_Expert);
	if (!MapContent::Exists(_Coord) || (CannotRemoveOtherType && _Type != MapContent::GetMacroblockType(_Coord))) {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		if (CanNotify()) {
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : cutting a block in the track.
			if (_Cut) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Cut")));
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : removing a block.
			else UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Remove")));
		}
		return;
	}
	
	declare MacroblockModel <=> MapContent::GetMacroblockModel(_Coord);
	declare MacroblockCoord = MapContent::GetMacroblockCoord(_Coord);
	declare MacroblockDir = MapContent::GetMacroblockDir(_Coord);
	
	if (MacroblockModel == Null) return;
	
	// Save block connected to the transition
	declare CBlock[Int3] ConnectedBlocks;
	if (Transitions::IsTransition(MacroblockModel)) {
		declare ConnectedCoords = MapContent::GetConnectedMacroblockUnitCoords(MacroblockModel, MacroblockCoord, MacroblockDir);
		foreach (ConnectedCoord in ConnectedCoords) {
			ConnectedBlocks[ConnectedCoord] = GetBlock(ConnectedCoord);
		}
	}
	
	declare Removed = Macroblock::Remove(MacroblockModel, MacroblockCoord, MacroblockDir);
	if (Removed) {
		if (!G_RandomMapGeneration) Sound::Play("EditorRemoveBlock");
		
		declare RemovedCoord = _Coord;
		declare RemovedMacroblockModelsIds = [MacroblockModel.Id];
		declare RemovedMacroblocksCoords = [MacroblockCoord];
		declare RemovedMacroblocksDirs = [MacroblockDir];
		
		// Detect any block connected to a transition that was automatically removed by the editor
		foreach (ConnectedCoord => ConnectedBlock in ConnectedBlocks) {
			if (ConnectedBlock != GetBlock(ConnectedCoord)) {
				declare RemovedMacroblockModel <=> MapContent::GetMacroblockModel(ConnectedCoord);
				if (RemovedMacroblockModel == Null) continue;
				
				declare RemovedMacroblockCoord = MapContent::GetMacroblockCoord(ConnectedCoord);
				declare RemovedMacroblockDir = MapContent::GetMacroblockDir(ConnectedCoord);
				RemovedMacroblockModelsIds.add(RemovedMacroblockModel.Id);
				RemovedMacroblocksCoords.add(RemovedMacroblockCoord);
				RemovedMacroblocksDirs.add(RemovedMacroblockDir);
				
				// This block was removed automatically, so we must connect the next macroblock here and not where the transition was
				if (MapContent::GetConnectedMacroblockUnitCoords(RemovedMacroblockModel, RemovedMacroblockCoord, RemovedMacroblockDir).count > 1) {
					MacroblockModel <=> RemovedMacroblockModel;
					MacroblockCoord = RemovedMacroblockCoord;
					MacroblockDir = RemovedMacroblockDir;
				}
				
				// Be sure that the macroblock was removed
				declare RemovedForSure = Macroblock::Remove(RemovedMacroblockModel, RemovedMacroblockCoord, RemovedMacroblockDir);
			}
		}
		
		SaveHistory2(History2::Action_Remove(), MacroblockType, RemovedMacroblockModelsIds, RemovedMacroblocksCoords, RemovedMacroblocksDirs);
		if (G_Mode == C_Modes_ConstructTrack) {
			if (IsSimpleEditor()) {
				AutoCursorCoord(False, MacroblockModel, MacroblockCoord, MacroblockDir);
				AutoSelectStyle();
			}
			BrowseMacroblocks2();
			// Check again if we can place a block in place of the removed one
			if (!IsSimpleEditor()) {
				SetCursorCoord(CursorCoord);
				MoveMacroblock(<0,0,0>, False);
			}
			if (MacroblockModel != Null) {
				if (IsSimpleEditor()) SelectMacroblock(MacroblockModel.Id, MacroblockCoord, MacroblockDir);
				
				// Can't cut the start
				// Save cutted macroblock
				if (_Cut && !MacroblockModel.HasStart && !MacroblockModel.HasMultilap) {
					declare ConnectionToPrevious = MapContent::GetConnectionToPrevious(MacroblockModel, MacroblockCoord, MacroblockDir);
					declare PrevMacroblockModel <=> MapContent::GetMacroblockModel(G_CursorCoord);
					declare PrevMacroblockModelId = NullId;
					if (PrevMacroblockModel != Null) PrevMacroblockModelId = PrevMacroblockModel.Id;
					CutPaste::Cut(PrevMacroblockModelId, ConnectionToPrevious[0], MacroblockModel.Id, ConnectionToPrevious[1]);
				}
			}
		} else if (G_Mode == C_Modes_ConstructDeco) {
			// Check again if we can place a block in place of the removed one
			if (!IsSimpleEditor()) {
				SetCursorCoord(CursorCoord);
				BrowseMacroblocks2();
				MoveMacroblock(<0,0,0>, False);
			}
			
			if (MacroblockModel != Null) {
				if (IsSimpleEditor()) SelectMacroblock(MacroblockModel.Id, MacroblockCoord, MacroblockDir);
			}
		}
		
		if (_MoveCameraTo) {
			MoveCameraToClip(MacroblockCoord);
		}
		DisplaySkinSelection(RemovedCoord);
		SetCursorStyle();
		CheckAdvices();
		CheckTuto();
		CheckHelper();
		
		if (CanNotify()) {
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : cutting a block in the track.
			if (_Cut) UI_BlockHelp::Notify(_("Cut"));
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : removing a block.
			else UI_BlockHelp::Notify(_("Remove"));
		}
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		if (CanNotify()) {
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : cutting a block in the track.
			if (_Cut) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Cut")));
			//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : removing a block.
			else UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Remove")));
		}
	}
}

// ---------------------------------- //
/** Remove a macroblock
 *
 *	@param	_Coord					The coordinates of one the block unit of the macroblock to remove
 *	@param	_MoveCameraTo			Move the camera to the block position
 */
Void RemoveMacroblock2(Int3 _Coord, Boolean _MoveCameraTo) {
	// Switch to the right building mode if necessary
	if (C_RemoveAutoSwitchMode && !G_RandomMapGeneration && IsEditor(C_Editor_Expert)) {
		declare MacroblockMode = MapContent::GetMacroblockType(_Coord);
		if (MapContent::Exists(CursorCoord) && (MacroblockMode == C_Modes_ConstructTrack || MacroblockMode == C_Modes_ConstructDeco)) {
			if (G_Mode != MacroblockMode) {
				declare PrevCursorCoord = CursorCoord;
				SelectMode(C_Categories_Construct, MacroblockMode);
				SelectSequence();
				SetCursorCoord(PrevCursorCoord);
			}
		}
	}
	
	RemoveMacroblock2(_Coord, G_Mode, False, _MoveCameraTo);
}

// ---------------------------------- //
/** Remove a macroblock
 *
 *	@param	_Coord					The coordinates of one the block unit of the macroblock to remove
 */
Void ExpertRemoveMacroblock2(Int3 _Coord) {
	if (!G_IsEditing && !G_IsSkinning) return;
	
	declare Coord = _Coord;
	
	if (MapContent::GetMacroblockKey(G_CursorMacroblockModel, CursorCoord, CursorDir) >= 0) {
		Coord = Macroblock::GetBlockUnitCoord(G_CursorMacroblockModel, CursorCoord, CursorDir);
	}
	
	RemoveMacroblock2(Coord, False);
}

// ---------------------------------- //
/** Remove a macroblock
 *
 *	@param	_MacroblockModel		The macroblock model
 *	@param	_Coord					The macroblock coordinates
 *	@param	_Dir					The macroblock direction
 *	@param	_Type					The macroblock type
 *	@param	_MoveCameraTo			Move the camera to the block position
 */
Void RemoveMacroblock2(CMacroblockModel _MacroblockModel, Int3 _Coord, CEditorPlugin::CardinalDirections _Dir, Integer _Type, Boolean _MoveCameraTo) {
	if (_MacroblockModel == Null) return;
	
	// Save block connected to the transition
	declare CBlock[Int3] ConnectedBlocks;
	if (Transitions::IsTransition(_MacroblockModel)) {
		declare ConnectedCoords = MapContent::GetConnectedMacroblockUnitCoords(_MacroblockModel, _Coord, _Dir);
		foreach (ConnectedCoord in ConnectedCoords) {
			ConnectedBlocks[ConnectedCoord] = GetBlock(ConnectedCoord);
		}
	}
	
	declare Removed = Macroblock::Remove(_MacroblockModel, _Coord, _Dir);
	if (Removed) {
		if (!G_RandomMapGeneration) Sound::Play("EditorRemoveBlock");
		
		declare MacroblockModel <=> _MacroblockModel;
		declare MacroblockCoord = _Coord;
		declare MacroblockDir = _Dir;
		
		declare RemovedMacroblockModelsIds = [MacroblockModel.Id];
		declare RemovedMacroblocksCoords = [MacroblockCoord];
		declare RemovedMacroblocksDirs = [MacroblockDir];
		
		// Detect any block connected to a transition that was automatically removed by the editor
		foreach (ConnectedCoord => ConnectedBlock in ConnectedBlocks) {
			if (ConnectedBlock != GetBlock(ConnectedCoord)) {
				declare RemovedMacroblockModel <=> MapContent::GetMacroblockModel(ConnectedCoord);
				if (RemovedMacroblockModel == Null) continue;
				
				declare RemovedMacroblockCoord = MapContent::GetMacroblockCoord(ConnectedCoord);
				declare RemovedMacroblockDir = MapContent::GetMacroblockDir(ConnectedCoord);
				RemovedMacroblockModelsIds.add(RemovedMacroblockModel.Id);
				RemovedMacroblocksCoords.add(RemovedMacroblockCoord);
				RemovedMacroblocksDirs.add(RemovedMacroblockDir);
				
				// This block was removed automatically, so we must connect the next macroblock here and not where the transition was
				if (MapContent::GetConnectedMacroblockUnitCoords(RemovedMacroblockModel, RemovedMacroblockCoord, RemovedMacroblockDir).count > 1) {
					MacroblockModel <=> RemovedMacroblockModel;
					MacroblockCoord = RemovedMacroblockCoord;
					MacroblockDir = RemovedMacroblockDir;
				}
				
				// Be sure that the macroblock was removed
				declare RemovedForSure = Macroblock::Remove(RemovedMacroblockModel, RemovedMacroblockCoord, RemovedMacroblockDir);
			}
		}
		
		SaveHistory2(History2::Action_Remove(), _Type, RemovedMacroblockModelsIds, RemovedMacroblocksCoords, RemovedMacroblocksDirs);
		
		AutoCursorCoord(False, MacroblockModel, MacroblockCoord, MacroblockDir);
		if (_MoveCameraTo) {
			MoveCameraToClip(MacroblockCoord);
		}
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
	}
}

// ---------------------------------- //
/** Remove all finishes block from the map
 *
 *	@param	_Cut					Cut or simply remove the finishes
 */
Void RemoveAllFinishes(Boolean _Cut) {
	declare FinishesCoords = MapContent::GetFinishesUnitCoord(C_Modes_ConstructTrack);
	
	declare CMacroblockModel MacroblockModel;
	declare Int3 MacroblockCoord;
	declare CEditorPlugin::CardinalDirections MacroblockDir;
	if (FinishesCoords.count > 0 && IsEditor(C_Editor_Advanced)) {
		declare Coord = FinishesCoords[FinishesCoords.count-1];
		MacroblockModel <=> MapContent::GetMacroblockModel(Coord);
		MacroblockCoord = MapContent::GetMacroblockCoord(Coord);
		MacroblockDir = MapContent::GetMacroblockDir(Coord);
	}
	
	foreach (FinishCoord in FinishesCoords) {
		RemoveMacroblock2(FinishCoord, C_Modes_ConstructTrack, _Cut, True);
	}
	
	// Select disconnect/connect mode
	if (MacroblockModel != Null && IsEditor(C_Editor_Advanced)) {
		SetTrackCursorCoord(False, MacroblockModel, MacroblockCoord, MacroblockDir);
	}
}

// ---------------------------------- //
/* Remove a terrain block
 *
 *	@param	_StartCoord				The starting coordinates of the block
 *	@param	_EndCoord				The ending coordinates of the block
 */
Void RemoveTerrain2(Int3 _StartCoord, Int3 _EndCoord) {
	declare Removed = RemoveTerrainBlocks(_StartCoord, _EndCoord);
	if (Removed) {
		if (!G_RandomMapGeneration) Sound::Play("EditorRemoveBlock");
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : removing a block.
		if (CanNotify()) UI_BlockHelp::Notify(_("Remove"));
		SaveHistory2(History2::Action_Remove(), C_Modes_ConstructTerrain, NullId, _StartCoord, CEditorPlugin::CardinalDirections::North);
		
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_EditTerrain())) {
			UI_Tuto::Validate(UI_Tuto::Tuto_EditTerrain());
			CheckTuto();
		}
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : removing a block.
		if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Remove")));
	}
	
	// Undo the terrain modification if it exceeds the copper limit
	Yield(); ///< yield to update map copper price
	if (Removed && MustCheckCoppersLimit() && Map.CopperPrice >= C_CopperLimit_Hard) {
		UndoHistory2();
		Alert(
			//L16N [MapEditor] Title of a pop-up displaying informations about the track editor
			_("Warning"), 
			//L16N [MapEditor] Pop-up warning the player that he reached the maximum number of blocks placed in the map and can't add more.
			_("You reached the maximum number of blocks. You cannot add more."),
			//L16N [MapEditor] Confirm an action
			_("|Infinitive|Confirm")
		);
	}
}

// ---------------------------------- //
/* Remove a terrain block
 *
 *	@param	_CursorDelete			True to start the selection, False to end it
 */
Void RemoveTerrain2(Boolean _CursorDelete) {
	// Start selection
	if (_CursorDelete) {
		SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Terraform, CEditorPlugin::EditMode::Erase);
		Selection::Start(CursorCoord);
		Selection::SetColor(<0.3, 0.3, 0.3>);
		Selection::Show();
	} 
	// Stop selection
	else {
		SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Terraform, CEditorPlugin::EditMode::Place);
		Selection::Stop(CursorCoord);
		RemoveTerrain2(Selection::GetStart(), Selection::GetEnd());
		Selection::Hide();
		Selection::Destroy();
		SetCursorStyle();
		Camera::MoveTo(CursorCoord);
	}
}

Void ExpertCursorConnect(Ident _MacroblockModelId, Int3 _Coord) {
	if (!MacroblockModels.existskey(_MacroblockModelId)) return;
	declare MacroblockModel <=> MacroblockModels[_MacroblockModelId];
	declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
	if (MacroblockModel == Null || Variant == Null) return;
	
	if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_MoveBlock_Mouse())) {
		UI_Tuto::Validate(UI_Tuto::Tuto_MoveBlock_Mouse());
		CheckTuto();
	}
	
	declare Connected = False;
	if (MapContent::ClipExists(_Coord)) {
		// The properties of the clip we want to connect to
		declare ClipCoord = _Coord;
		declare ClipDir = MapContent::GetClipDir(_Coord);
		declare ClipName = MapContent::GetClipName(_Coord);
		
		// The properties of the clip that can be connected
		declare ValidClipDir = MU::GetOpposedDir(ClipDir);
		declare ValidClipCoord = MU::GetNeighbourCoord(ClipCoord, ValidClipDir);
		declare ValidClipNames = Macroblock::GetConnectableClips(ClipName);
		
		// The clips available on the macroblock to connect
		declare NextClipNames = Macroblock::GetClipNames(MacroblockModel);
		declare NextClipOffsets = Macroblock::GetClipOffsets(MacroblockModel);
		declare NextClipDirs = Macroblock::GetClipDirs(MacroblockModel);
		
		// The best block placement
		declare BestDir = CEditorPlugin::CardinalDirections::North;
		declare BestCoord = Utils::NullCoord();
		declare DirDiff = -1;
		
		foreach (NextClipId => NextClipName in NextClipNames) {
			// Skip -out clip, we can't use them to connect the next macroblock
			if (Macroblock::IsOutClip(NextClipName)) continue;
			
			// Skip clips that can't be connected
			if (!ValidClipNames.exists(NextClipName)) continue;
			
			// Determine next block coord and dir
			if (!NextClipOffsets.existskey(NextClipId) || !NextClipDirs.existskey(NextClipId)) continue;
			declare NextBlockDir = MU::SubDirs(ValidClipDir, NextClipDirs[NextClipId]);
			declare NextBlockCoord = ValidClipCoord - MU::GetRotatedOffsetPositive(NextClipOffsets[NextClipId], NextBlockDir, Variant.Size);
			
			if (CustomCanPlaceMacroblock(MacroblockModel, NextBlockCoord, NextBlockDir, True)) {
				declare Diff = ML::Abs(Utils::DirToInt(NextBlockDir) - Utils::DirToInt(CursorDir));
				if (DirDiff == -1 || Diff < DirDiff) {
					DirDiff = Diff;
					BestCoord = NextBlockCoord;
					BestDir = NextBlockDir;
				}
			}
		}
		
		// Set the cursor to the best placement
		if (BestCoord != Utils::NullCoord()) {
			SetCursorCoord(BestCoord);
			SetCursorDir(BestDir);
			Connected = True;
		}
	}
	
	if (!Connected && !CustomCanPlaceMacroblock(MacroblockModel, CursorCoord, CursorDir, True)) {
		for (Dir, 0, 3) {
			declare ShiftDir = (Utils::DirToInt(CursorDir) + Dir) % 4;
			if (CustomCanPlaceMacroblock(MacroblockModel, CursorCoord, Utils::IntToDir(ShiftDir), True)) {
				SetCursorDir(Utils::IntToDir(ShiftDir));
				break;
			}
		}
	}
}

// ---------------------------------- //
/** Try to place the given macroblock
 *	If it can't then check why and do what's best
 *
 *	@param	_MacroblockModelId		The id of the macroblock model to place
 *
 *	@return							True if the macroblock was placed, False otherwise
 */
Boolean ExpertCursorPlace(Ident _MacroblockModelId) {
	declare MacroblockPlaced = False;
	if (G_CurrentSequence == C_Sequence_EditDecoration) {
		MacroblockPlaced = AddDecoMacroblock2(_MacroblockModelId); ///< Place deco macroblock
	} else {
		MacroblockPlaced = AddMacroblock2(_MacroblockModelId); ///< Place macroblock
	}
	if (!MacroblockPlaced) {
		declare Coord = CursorCoord;
		declare OriginalCoord = CursorCoord;
		
		if (MapContent::GetMacroblockKey(G_CursorMacroblockModel, CursorCoord, CursorDir) >= 0) {
			Coord = Macroblock::GetBlockUnitCoord(G_CursorMacroblockModel, CursorCoord, CursorDir);
		}
			
		// Cursor is on a macroblock, find a macroblock that can be connected
		if ((G_IsEditing || G_IsSkinning) && MapContent::Exists(Coord)) {
			if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Edit())) {
				UI_Tuto::Validate(UI_Tuto::Tuto_Edit());
				CheckTuto();
			}
			
			// Select the right building mode
			declare MacroblockMode = MapContent::GetMacroblockType(Coord);
			if ((MacroblockMode == C_Modes_ConstructTrack || MacroblockMode == C_Modes_ConstructDeco)) {
				if (G_Mode != MacroblockMode) {
					declare PrevCursorCoord = Coord;
					SelectMode(C_Categories_Construct, MacroblockMode);
					SelectSequence();
					SetCursorCoord(PrevCursorCoord);
				}
			}
			
			// Select the right style
			if (MacroblockMode == C_Modes_ConstructTrack) {
				declare EditedMacroblockModel = MapContent::GetMacroblockModel(Coord);
				if (EditedMacroblockModel != Null) SelectMacroblockStyle(EditedMacroblockModel.Id);
			}
			
			SetCursorCoord(Coord);
			declare ValidMacroblockModels = FilterMacroblocks2(True);
			if (ValidMacroblockModels.count > 0) {
				declare MacroblockModel <=> MapContent::GetMacroblockModel(Coord);
				if (MacroblockModel == Null || !ValidMacroblockModels.exists(MacroblockModel)) {
					MacroblockModel = SelectSimplestMacroblock(ValidMacroblockModels);
				}
				
				SetCursorDir(Placement::GetDir(MacroblockModel));
				SetCursorCoord(Placement::GetCoord(MacroblockModel));
				SetCursorMacroblockModel(MacroblockModel);
				
				MoveMacroblock(<0, 0, 0>, False);
				//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : connecting the currently selected block to the previous one.
				if (CanNotify()) UI_BlockHelp::Notify(_("Connect"));
			} else {
				SetCursorCoord(OriginalCoord);
				MoveMacroblock(<0, 0, 0>, False);
			}
		} 
		// Cursor in on an empty space, try to find a valid placement for the cursor macroblock
		else {
			if (MacroblockModels.existskey(_MacroblockModelId)) {
				declare MacroblockModel <=> MacroblockModels[_MacroblockModelId];
				declare PlacementCoords = Placement::GetCoords(MacroblockModel);
				declare PlacementDirs = Placement::GetDirs(MacroblockModel);
				foreach (Placement => Coord in PlacementCoords) {
					if (CustomCanPlaceMacroblock(MacroblockModel, Coord, PlacementDirs[Placement], True)) {
						if (CursorDir != PlacementDirs[Placement] || Coord != CursorCoord) {
							SetCursorDir(PlacementDirs[Placement]);
							SetCursorCoord(Coord);
							
							//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : rotating the currently selected block.
							if (CanNotify()) UI_BlockHelp::Notify(_("Rotate"));
						}
						break;
					}
				}
			}
		}
	}
	
	return MacroblockPlaced;
}

// ---------------------------------- //
/** Try to turn the current macroblock if we are in an open block
 *	Pick the select macroblock if we are on an occupied block
 */
Void ExpertCursorTurn() {
	if (G_IsEditing || G_IsSkinning) {
		declare MacroblockMode = MapContent::GetMacroblockType(CursorCoord);
		if (MapContent::Exists(CursorCoord) && (MacroblockMode == C_Modes_ConstructTrack || MacroblockMode == C_Modes_ConstructDeco)) {
			if (G_Mode != MacroblockMode) {
				declare PrevCursorCoord = CursorCoord;
				SelectMode(C_Categories_Construct, MacroblockMode);
				SelectSequence();
				SetCursorCoord(PrevCursorCoord);
			}
			
			declare MacroblockModel = MapContent::GetMacroblockModel(CursorCoord);
			
			if (MacroblockModel != Null && !MacroblockModel.HasStart && !MacroblockModel.HasMultilap) {
				if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Edit())) {
					UI_Tuto::Validate(UI_Tuto::Tuto_Edit());
					CheckTuto();
				}
				
				declare MacroblockCoord = MapContent::GetMacroblockCoord(CursorCoord);
				declare MacroblockDir = MapContent::GetMacroblockDir(CursorCoord);
				SelectMacroblock(MacroblockModel.Id, MacroblockCoord, MacroblockDir);
				
				SetCursorMacroblockModel(Null, MacroblockModel);
				SetCursorDir(MacroblockDir);
				CopySkin(MacroblockModel, MacroblockCoord, MacroblockDir);
				
				//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : copying a block from the track and selecting it in the block selection UI.
				if (CanNotify()) UI_BlockHelp::Notify(_("Copy"));
				Sound::Play("EditorBlockSelection");
			} else {
				//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : copying a block from the track and selecting it in the block selection UI.
				if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Copy"))); 
				Sound::Play("EditorWrongAction");
			}
		}
	} else {
		RotateMacroblock(1);
	}
}

// ---------------------------------- //
/// Skip a macroblock from the paste stack
Void SkipMacroblock() {
	// Cut and paste tuto
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_CutPaste())) {
		UI_Tuto::Validate(UI_Tuto::Tuto_CutPaste());
		CheckTuto();
	}
	
	if (CutPaste::Count() > 0) {
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : when cutting a block, it goes inside a stack. You can then paste a block from this stack or discard it.
		if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive - throw out|Discard"));
		if (!G_RandomMapGeneration) Sound::Play("EditorRemoveBlock");
	} else {
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : when cutting a block, it goes inside a stack. You can then paste a block from this stack or discard it.
		//if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive - throw out|Discard")));
		//if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
	}
	
	CutPaste::Skip();
}

// ---------------------------------- //
/// Cut the latest macroblock
Void CutMacroblock() {
	// Cut and paste tuto
	if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_CutPaste())) {
		UI_Tuto::Enable(UI_Tuto::Tuto_CutPaste());
	}
	
	Sound::Play("EditorRemoveBlock");
	RemoveMacroblock2(MapContent::GetLatestMacroblockUnitCoord(G_Mode, False), G_Mode, True, False);
}

// ---------------------------------- //
/// Find the informations about the next paste
Void FindNextPaste() {
	declare CMacroblockModel PartyEditor_NextPasteMacroblockModel for This;
	declare Int3 PartyEditor_NextPasteCoord for This;
	declare CEditorPlugin::CardinalDirections PartyEditor_NextPasteDir for This;
	PartyEditor_NextPasteMacroblockModel = Null;
	PartyEditor_NextPasteCoord = Utils::NullCoord();
	PartyEditor_NextPasteDir = CEditorPlugin::CardinalDirections::North;
		
	declare CutNextMacroblockModelId = CutPaste::GetNextMacroblockModelId();
	if (CutNextMacroblockModelId != NullId && MacroblockModels.existskey(CutNextMacroblockModelId)) {
		
		// Get the macroblock at the current cursor coordinates
		declare PrevMacroblockModel <=> MapContent::GetMacroblockModel(G_FilteringCoord);
		declare PrevMacroblockCoord = MapContent::GetMacroblockCoord(G_FilteringCoord);
		declare PrevMacroblockDir = MapContent::GetMacroblockDir(G_FilteringCoord);
		
		declare CutNextMacroblockModel <=> MacroblockModels[CutNextMacroblockModelId];
		declare CutNextConnectedBy = CutPaste::GetNextMacroblockConnectedBy();
		declare CutPrevMacroblockModelId = CutPaste::GetPrevMacroblockModelId();
		declare CutPrevConnectedBy = CutPaste::GetPrevMacroblockConnectedBy();
		
		declare FoundConnection = False;
		
		declare PrevClipsDisconnected = MapContent::GetDisconnectedClips(PrevMacroblockModel, PrevMacroblockCoord, PrevMacroblockDir);
		if (PrevClipsDisconnected.count > 0) {
			// Valid data for the next macroblock
			declare PrevClipCoords = Macroblock::GetClipCoords(PrevMacroblockModel, PrevMacroblockCoord, PrevMacroblockDir);
			declare PrevClipNames = Macroblock::GetClipNames(PrevMacroblockModel);
			declare PrevClipDirs = Macroblock::GetClipDirs(PrevMacroblockModel, PrevMacroblockDir);
			
			foreach (PrevClipId in PrevClipsDisconnected) {
				if (
					!PrevClipCoords.existskey(PrevClipId) || 
					!PrevClipNames.existskey(PrevClipId) || 
					!PrevClipDirs.existskey(PrevClipId)
				) continue;
				
				declare ValidClipDir = MU::GetOpposedDir(PrevClipDirs[PrevClipId]);
				declare ValidClipCoord = MU::GetNeighbourCoord(PrevClipCoords[PrevClipId], ValidClipDir);
				declare ValidClipName = Macroblock::GetConnectableClips(PrevClipNames[PrevClipId]);
				
				// Test all variants
				declare MacroblockVariants = Macroblock::GetVariants(CutNextMacroblockModel);
				foreach (VariantId in MacroblockVariants) {
					declare VariantModel <=> Macroblock::GetMacroblockModelFromId(VariantId);
					
					// Get variant
					declare NextVariant <=> Macroblock::GetBlockModelVariant(VariantModel);
					if (NextVariant == Null) continue;
			
					// Data of the next macroblock
					declare NextClipNames = Macroblock::GetClipNames(VariantModel);
					declare NextClipOffsets = Macroblock::GetClipOffsets(VariantModel);
					declare NextClipDirs = Macroblock::GetClipDirs(VariantModel);
					
					foreach (NextClipId => NextClipName in NextClipNames) {
						// Skip clips that can't be connected
						if (!ValidClipName.exists(NextClipName)) continue;
						
						// Determine next block coord and dir
						if (!NextClipOffsets.existskey(NextClipId) || !NextClipDirs.existskey(NextClipId)) continue;
						declare NextBlockDir = MU::SubDirs(ValidClipDir, NextClipDirs[NextClipId]);
						declare NextBlockCoord = ValidClipCoord - MU::GetRotatedOffsetPositive(NextClipOffsets[NextClipId], NextBlockDir, NextVariant.Size);
					
						// Skip macroblock that can't be placed and have no transition
						if (!CustomCanPlaceMacroblock(VariantModel, NextBlockCoord, NextBlockDir, True)) continue;
						
						declare IsConnectedTo = (PrevMacroblockModel.Id == CutPrevMacroblockModelId && PrevClipId == CutPrevConnectedBy);
						declare IsConnectedBy = (NextClipId == CutNextConnectedBy);
						
						if (IsConnectedTo && IsConnectedBy) FoundConnection = True;
						
						if (PartyEditor_NextPasteMacroblockModel == Null || IsConnectedBy || FoundConnection) {
							PartyEditor_NextPasteMacroblockModel <=> VariantModel;
							PartyEditor_NextPasteCoord = NextBlockCoord;
							PartyEditor_NextPasteDir = NextBlockDir;
						}
						
						if (FoundConnection) break;
					}
					if (FoundConnection) break;
				}
				if (FoundConnection) break;
			}
		}
	}
}

// ---------------------------------- //
/// Try to select the next paste in the macroblocks list
Void SelectNextPaste() {
	FindNextPaste();
	
	declare CMacroblockModel PartyEditor_NextPasteMacroblockModel for This;
	declare Int3 PartyEditor_NextPasteCoord for This;
	declare CEditorPlugin::CardinalDirections PartyEditor_NextPasteDir for This;
	
	if (PartyEditor_NextPasteMacroblockModel == Null) return;
	
	SelectMacroblock(PartyEditor_NextPasteMacroblockModel.Id, PartyEditor_NextPasteCoord, PartyEditor_NextPasteDir);
}

// ---------------------------------- //
/// Paste the newest macroblock
Void PasteMacroblock() {
	FindNextPaste();
	
	declare CMacroblockModel PartyEditor_NextPasteMacroblockModel for This;
	declare Int3 PartyEditor_NextPasteCoord for This;
	declare CEditorPlugin::CardinalDirections PartyEditor_NextPasteDir for This;
		
	if (PartyEditor_NextPasteMacroblockModel != Null) {
		declare MacroblockPlaced = AddMacroblock2(PartyEditor_NextPasteMacroblockModel, PartyEditor_NextPasteCoord, PartyEditor_NextPasteDir, True, False);
		if (MacroblockPlaced) {
			CutPaste::Paste();
			SelectNextPaste();
			if (CanNotify()) UI_BlockHelp::Notify(_("Paste"));
		} else {
			if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Paste")));
		}
	} else {
		if (!G_RandomMapGeneration && CutPaste::Count() > 0) {
			if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Paste")));
			Sound::Play("EditorWrongAction");
		}
	}
	
	// Cut and paste tuto
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_CutPaste())) {
		UI_Tuto::Validate(UI_Tuto::Tuto_CutPaste());
	}
	
	CheckAdvices();
	CheckTuto();
}

// ---------------------------------- //
/** Add a random prefab landscape
 *
 *	@param	_Beginner				Add a beginner landscape or a normal one
 *	@param	_Random					Generating a random track
 */
Void RandomLandscape(Boolean _Beginner, Boolean _Random) {
	if (!_Beginner) RemoveAllTerrain();
	
	declare CMacroblockModel Terrain;
	declare TerrainName = "";
	declare Terrains = Terrain::GetTerrains(_Beginner, _Random);
	declare TerrainIndex = Random::Rand(0, Terrains.count-1);
	declare Count = 0;
	foreach (Name => MacroblockModel in Terrains) {
		if (Count == TerrainIndex) {
			TerrainName = Name;
			Terrain <=> MacroblockModel;
			break;
		}
		Count += 1;
	}
	
	declare Directions = Terrain::GetTerrainDirs(TerrainName);
	declare Dir = Directions[Random::Rand(0, Directions.count-1)];
	
	declare PartsCount = Terrain::GetPartsCount(TerrainName);
	for (Part, 0, PartsCount-1) {
		declare Placed = Terrain::PlacePart(TerrainName, Part, Dir);
		Yield();
	}
	
	declare metadata Text PartyEditor_TerrainId for Map;
	declare metadata Integer PartyEditor_TerrainDir for Map;
	PartyEditor_TerrainId = Macroblock::GetId(Terrain);
	PartyEditor_TerrainDir = Utils::DirToInt(Dir);
	
	AutoSave();
	
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	MapModified();
}

// ---------------------------------- //
/// Add a random decoration block at a random position
Void AddRandomDecoration() {
	declare TrackCoords = MapContent::GetMacroblocksCoords(C_Modes_ConstructTrack);
	if (TrackCoords.count <= 0) return;
	
	if (G_LastRandomPlace > 0 && Now - G_LastRandomPlace < C_RandomDecorationDelay) return;
	G_LastRandomPlace = Now;
	
	// Get list of available deco macroblocks
	declare DecorationTypeAndModels = GetDecorationMacroblocks(True);
	
	// Create deco type source
	declare Text[] DecoTypeSource;
	declare Max = 0;
	declare UsePodium = False;
	foreach (DecorationType => DecorationMacroblockModels in DecorationTypeAndModels) {
		if (DecorationType == "|Decoration|Podium") {
			declare Amount = C_DefaultPodiumAmount;
			if (RandomStyles::ExistsMultiplier(DecorationType)) Amount = RandomStyles::GetMultiplier(DecorationType);
			if (Amount > 0.) UsePodium = True;
			continue;
		}
		
		declare Amount = C_DefaultDecoAmount;
		if (RandomStyles::ExistsMultiplier(DecorationType)) Amount = RandomStyles::GetMultiplier(DecorationType);
		declare End = ML::NearestInteger(Amount * 10);
		if (End > Max) Max = End;
		for (I, 1, End) {
			DecoTypeSource.add(DecorationType);
		}
	}
	for (I, Max, 9) {
		DecoTypeSource.add("");
	}
	
	// Check each block around the track
	declare Placed = False;
	declare TrackCoord = TrackCoords[Random::Rand(0, TrackCoords.count-1)];
	declare CubeStart = <TrackCoord.X-2, CollectionGroundY, TrackCoord.Z-2>;
	declare CubeEnd = <TrackCoord.X+2, CollectionGroundY, TrackCoord.Z+2>;
	declare Int3[] CubeCoords;
	for (X, CubeStart.X, CubeEnd.X) {
		if (X < 0 || X > Map.Size.X - 1) continue;
		for (Z, CubeStart.Z, CubeEnd.Z) {
			if (Z < 0 || Z > Map.Size.Z - 1) continue;
			CubeCoords.add(<X, CollectionGroundY, Z>);
		}
	}
	
	while (CubeCoords.count > 0) {
		declare CubeCoord = CubeCoords[Random::Rand(0, CubeCoords.count-1)];
		declare Removed = CubeCoords.remove(CubeCoord);
		
		// Select a random deco macroblock
		declare DecoType = DecoTypeSource[Random::Rand(0, DecoTypeSource.count-1)];
		if (DecoType == "") continue;
		declare DecoMacroblockModel <=> DecorationTypeAndModels[DecoType][Random::Rand(0, DecorationTypeAndModels[DecoType].count-1)];
		
		// Try to place it in all direction
		declare StartDir = Random::Rand(0, 3);
		for (I, StartDir, StartDir+3) {
			declare IntDir = I % 4;
			declare Dir = Utils::IntToDir(IntDir);
			CubeCoord.Y = GetBlockGroundHeight(DecoMacroblockModel.GeneratedBlockModel, CubeCoord.X, CubeCoord.Z, Dir);
			
			if (CustomCanPlaceMacroblock(DecoMacroblockModel, CubeCoord, Dir, False)) {
				SetCursorMacroblockModel(DecoMacroblockModel);
				Placed = AddMacroblock2(DecoMacroblockModel, CubeCoord, Dir, False, True);
				DisplaySkinSelection(CursorCoord);
				break;
			}
		}
		
		if (Placed) break;
	}
}

// ---------------------------------- //
/** Select the connection clip to use
 *
 *	@param	_MacroblockModelId		The Id of the next macroblock
 *	@param	_ConnectedTo			Select the clip to use
 */
Void SelectConnectedTo(Ident _MacroblockModelId, Integer _ConnectedTo) {
	if (G_AvailableConnectors.exists(_ConnectedTo)) G_CursorConnectedTo = _ConnectedTo;
	else G_CursorConnectedTo = -1;
	SendMacroblockList(G_AvailableMacroblocks);
		
	if (G_CursorConnectedTo >= 0) {
		// Get the macroblock model variant to use
		declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
		
		declare MacroblockConnectedByClips = Placement::GetConnectedByClips(MacroblockModel);
		declare MacroblockConnectedByClip = Placement::GetConnectedByClip(MacroblockModel);
		foreach (Placement => ConnectedBy in MacroblockConnectedByClips) {
			if (ConnectedBy != MacroblockConnectedByClip) continue;
			if (Placement::GetConnectedToClip(MacroblockModel, Placement) == G_CursorConnectedTo) {
				Placement::Select(MacroblockModel, Placement);
				if (MacroblockModel != Null) UI_MacroblockSelection::FindMacroblock(MacroblockModel.Id, Placement);
				break;
			}
		}
	}
}

// ---------------------------------- //
/** Switch between the in clip of the next block
 *
 *	@param	_MacroblockModelId		The Id of the next macroblock
 *	@param	_SwitchOnlyConnection	Only switch the connection of the macroblock and not the rotation
 */
Void SwitchMacroblockPlacement(Ident _MacroblockModelId, Boolean _SwitchOnlyConnection) {
	// Get the macroblock model variant to use
	declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	
	if (_SwitchOnlyConnection) {
		declare ConnectedTo = G_CursorConnectedTo;
		declare Key = G_AvailableConnectors.keyof(ConnectedTo) + 1;
		if (!G_AvailableConnectors.existskey(Key)) {
			if (G_AvailableConnectors.count > 0) ConnectedTo = G_AvailableConnectors[0];
			else ConnectedTo = -1;
		} else {
			ConnectedTo = G_AvailableConnectors[Key];
		}
		
		SelectConnectedTo(_MacroblockModelId, ConnectedTo);
		
		if (!G_RandomMapGeneration) {
			if (G_AvailableConnectors.count > 1) {
				Sound::Play("EditorBlockRotate");
				//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : switching between several available block connectors.
				if (CanNotify()) UI_BlockHelp::Notify(_("Switch"));
			}
			else {
				Sound::Play("EditorWrongAction");
				//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : switching between several available block connectors.
				if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Switch")));
			}
		}
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorBlockRotate");
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : switching between several available block connectors.
		if (CanNotify()) UI_BlockHelp::Notify(_("Switch"));
	}
	
	// Next placement
	PreviewMacroblock(_MacroblockModelId, Placement::GetPlacement(MacroblockModel), False);
	
	// Update tuto
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Switch())) {
		UI_Tuto::Trigger(UI_Tuto::Tuto_Switch());
		CheckTuto();
	}
}

// ---------------------------------- //
/** Switch between the in clip of the next block
 *
 *	@param	_MacroblockModelId		The Id of the next macroblock
 */
Void SwitchMacroblockPlacement(Ident _MacroblockModelId) {
	SwitchMacroblockPlacement(_MacroblockModelId, False);
}

// ---------------------------------- //
/// Select the right state when switching to the construct mode
Void InitConstructMode() {
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	
	// Try to find an open clip
	declare Coord = MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, True);
	if (Coord != Utils::NullCoord()) {
		SetCursorCoord(Coord);
	} else {
		Coord = MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, False);
		if (Coord != Utils::NullCoord()) {
			SetCursorCoord(Coord);
		}
	}
}

// ---------------------------------- //
/** Turn on/off the test mode
 *
 *	@param	_Status					Activated or not
 */
Void SetTestMode(Boolean _Status) {
	// Can't start test if there's no start and checkpoint
	if (!MapContent::HasStart() && !MapContent::HasCheckpoint()) {
		G_TestMode = False;
		Sound::Play("EditorWrongAction");
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : launching a test race on the track.
		if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("Test")));
		return;
	}
	
	G_TestMode = _Status;
	
	if (_Status) {
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Test())) {
			UI_Tuto::Validate(UI_Tuto::Tuto_Test());
			CheckTuto();
		}
		
		// Place currently selected macroblock
		/*if (IsSimpleEditor()) {
			declare PartyEditor_RemoveAfterTest for This = False;
			PartyEditor_RemoveAfterTest = AddMacroblock2(UI_MacroblockSelection::GetMacroblockId());
		}*/
	} else {
		// Return to the right macroblock
		if (G_Mode == C_Modes_ConstructTrack) {
			InitConstructMode();
		}
		
		// Remove previously selected macroblock
		/*declare PartyEditor_RemoveAfterTest for This = False;
		if (IsSimpleEditor() && PartyEditor_RemoveAfterTest) {
			RemoveMacroblock2(MapContent::GetLatestMacroblockUnitCoord(G_Mode, False), False);
		}*/
	}
	
	if (CanNotify() && _Status) {
		//L16N [MapEditor] Notification displayed to describe the action that the player is doing. Here : launching a test race on the track.
		if (CanNotify()) UI_BlockHelp::Notify(_("Test"));
	}
	
	if (_Status) {
		Sound::Play("EditorTestStart");
	} else {
		Sound::Play("EditorMenuCancel");
	}
}

// ---------------------------------- //
/** Convert a shadow qualite into an Integer
 *	The higher the value, the better the quality
 *
 *	@param	_ShadowQuality			The shadow quality to convert
 *
 *	@return							The converted shadow quality
 */
Integer ShadowsQualityToInt(CEditorPlugin::ShadowsQuality _ShadowQuality) {
	switch (_ShadowQuality) {
		case CEditorPlugin::ShadowsQuality::NotComputed	: return 0;
		case CEditorPlugin::ShadowsQuality::VeryFast	: return 1;
		case CEditorPlugin::ShadowsQuality::Fast		: return 2;
		case CEditorPlugin::ShadowsQuality::Default		: return 3;
		case CEditorPlugin::ShadowsQuality::High		: return 4;
		case CEditorPlugin::ShadowsQuality::Ultra		: return 5;
	}
	
	return -1;
}

// ---------------------------------- //
/// Update the thumbnail of the map
Void UpdateThumbnail() {
	declare metadata PartyEditor_HasCustomThumbnail for Map = False;
	if (!PartyEditor_HasCustomThumbnail) {
		Camera::UpdateThumbnail(C_Modes_ConstructTrack);
		MapModified();
	}
}

// ---------------------------------- //
/// Update the Uid of the map
Void UpdateUid() {
	declare MacroblockModel <=> Macroblock::GetUpdateUidBlock();
	if (MacroblockModel == Null) return;
	declare Stop = False;
	
	for (RevertY, 0, Map.Size.Y-1) {
		declare Y = Map.Size.Y - 1 - RevertY;
		for (X, 0, Map.Size.X-1) {
			for (Z, 0, Map.Size.Z-1) {
				declare Placed = False;
				if (CanPlaceMacroblock_NoTerrain(MacroblockModel, <X, Y, Z>, CEditorPlugin::CardinalDirections::North)) {
					Placed = PlaceMacroblock_NoTerrain(MacroblockModel, <X, Y, Z>, CEditorPlugin::CardinalDirections::North);
				}
				if (Placed) {
					yield; ///< Let the map type unvalidate the track
					declare Removed = RemoveMacroblock_NoTerrain(MacroblockModel, <X, Y, Z>, CEditorPlugin::CardinalDirections::North);
					Stop = True;
				}
				
				if (Stop) break;
			}
			if (Stop) break;
		}
		yield;
		if (Stop) break;
	}
	
	MapModified();
}

// ---------------------------------- //
/** Update map style selection UI
 *
 *	@return														True if the map style selection was canceled
 */
Boolean UpdateMapStyleSelection() {
	declare Canceled = False;
	foreach (Key => Input in G_InputBuffer) {
		declare Device = -1;
		if (G_DeviceBuffer.existskey(Key)) Device = G_DeviceBuffer[Key];
		switch (Input) {
			case CEditorPluginEvent::EInput::CursorPlace	: { ///< Valid map style selection
				declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
				declare metadata PartyEditor_MapStyleSelected for Map = False;
				PartyEditor_MapStyle = UI_MapStyleSelection::Valid();
				PartyEditor_MapStyleSelected = True;
				G_MapStyleSelection = False;
			}
			case CEditorPluginEvent::EInput::RemoveAll	: { ///< Cancel map style selection
				if (Device == Buttons2::Device_Keyboard()) {
					declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
					UI_MapStyleSelection::Select(PartyEditor_MapStyle);
					G_MapStyleSelection = False;
					Canceled = True;
					Sound::Play("EditorMenuCancel");
				}
			}
			case CEditorPluginEvent::EInput::CursorDelete	: { ///< Cancel map style selection
				if (Device == Buttons2::Device_Pad()) {
					declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
					UI_MapStyleSelection::Select(PartyEditor_MapStyle);
					G_MapStyleSelection = False;
					Canceled = True;
					Sound::Play("EditorMenuCancel");
				}
			}
			case CEditorPluginEvent::EInput::IconUp			: UI_MapStyleSelection::Prev(); ///< Previous selection in the menu
			case CEditorPluginEvent::EInput::IconDown		: UI_MapStyleSelection::Next(); ///< Next selection in the menu
			case CEditorPluginEvent::EInput::CursorUp		: UI_MapStyleSelection::Prev(); ///< Previous selection in the menu
			case CEditorPluginEvent::EInput::CursorDown		: UI_MapStyleSelection::Next(); ///< Next selection in the menu
		}
	}
	foreach (Input in G_UIInputBuffer) {
		declare EventType = "";
		declare EventData = Text[];
		
		foreach (Type => Data in Input) {
			EventType = Type;
			EventData = Data;
		}
		
		switch (EventType) {
			case UI_MapStyleSelection::Event_Hover(): UI_MapStyleSelection::Select(TL::ToInteger(EventData[0]), True);
			case UI_MapStyleSelection::Event_Click(): {
				declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
				declare metadata PartyEditor_MapStyleSelected for Map = False;
				UI_MapStyleSelection::Select(TL::ToInteger(EventData[0]));
				PartyEditor_MapStyle = UI_MapStyleSelection::Valid();
				PartyEditor_MapStyleSelected = True;
				G_MapStyleSelection = False;
			}
			case UI_MapStyleSelection::Event_Confirm(): { ///< Valid map style selection
				declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
				declare metadata PartyEditor_MapStyleSelected for Map = False;
				PartyEditor_MapStyle = UI_MapStyleSelection::Valid();
				PartyEditor_MapStyleSelected = True;
				G_MapStyleSelection = False;
			}
			case UI_MapStyleSelection::Event_Cancel(): { ///< Cancel map style selection
				declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
				UI_MapStyleSelection::Select(PartyEditor_MapStyle);
				G_MapStyleSelection = False;
				Canceled = True;
				Sound::Play("EditorMenuCancel");
			}
		}
	}
	ClearInputBuffer();
	G_TerrainCanPress = False;
	return Canceled;
}

// ---------------------------------- //
/** Custom save map function
 *
 *	@param	_SaveAs					Save the map with a new name
 */
Void CustomSaveMap(Boolean _SaveAs, Boolean _UnlockAchievements) {
	// Check that there is enough space on disk
	if (_SaveAs && DataMgr != Null) {
		while (DataMgr != Null && !DataMgr.Ready) Yield();
		DataMgr.QueryHasFreeSpaceForNewMap(DataMgr.MenuUserId);
		Yield();
		while (DataMgr != Null && !DataMgr.Ready) Yield();
		if (!DataMgr.HasFreeSpaceForNewMap) {
			//L16N [MapEditor] Pop-up warning the player that he has not enough space on disk to save his track
			Alert(_("You have no more space to create tracks. You must delete or upload some tracks before creating new ones."));
			return;
		}
	}
	
	if (_SaveAs) {
		if (ValidationStatus == CEditorPlugin::ValidationStatus::Validated) {
			declare ConfirmSave = Confirm(
				//L16N [MapEditor] Save the track in a new file
				_("Save as new"),
				//L16N [MapEditor] Pop-up asking confirmation to the player before saving a copy of the track
				_("You will have to validate the track again."),
				//L16N [MapEditor] Validate an action
				_("|Infinitive|Confirm"),
				//L16N [MapEditor] Cancel an action
				_("Cancel")
			);
			if (!ConfirmSave) return;
		}
		UpdateUid();
	}
	
	// Select style on first save after validation
	declare metadata PartyEditor_MapStyleSelected for Map = False;
	if (!G_RandomMapGeneration && !PartyEditor_MapStyleSelected && ValidationStatus == CEditorPlugin::ValidationStatus::Validated) {
		declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
		declare Canceled = False;
		G_MapStyleSelection = True;
		SelectSequence();
		ClearInputBuffer();
		G_TerrainCanPress = False;
		
		while (G_MapStyleSelection) {
			Yield();
			
			declare TmpCanceled = UpdateMapStyleSelection();
			if (TmpCanceled) Canceled = True;
		}
		SelectSequence();
		if (Canceled) return;
	}
	
	declare CurMapName = "";
	if (!_SaveAs) CurMapName = GetMapName();
	
	if (DataMgr != Null && UserMgr != Null && UserMgr.MainUser != Null && CurMapName == "") {
		while (!DataMgr.Ready) Yield();
		// Do not modify the name of "PartyEditor_MinEditionId", it is also used in the menu
		declare persistent PartyEditor_MinEditionId for UserMgr.MainUser = 0;
		DataMgr.GetNewMapEditionId(DataMgr.MenuUserId, PartyEditor_MinEditionId);
		while (!DataMgr.Ready) Yield();
		CurMapName = DataMgr.NewFileName;
		PartyEditor_MinEditionId = DataMgr.MinEditionId;
		UserMgr.MainUser.PersistentSave();
	}
	
	// Map style size is limited
	//SetMapStyle("""<map style="{{{UI_MapStyleSelection::GetStyleRawName()}}}" length="{{{MapTypeSynchro::GetLength()}}}" random="{{{IsRandom}}}" />""");
	if (G_RandomMapGeneration) SetMapStyle(UI_MapStyleSelection::GetStyleRawName(UI_MapStyleSelection::Style_Random()));
	else SetMapStyle(UI_MapStyleSelection::GetStyleRawName());
	
	// Save the version of the editor used to create the track
	declare metadata PartyEditor_TrackbuilderVersion_Created for Map = "";
	declare metadata PartyEditor_TrackbuilderVersion_Modified for Map = "";
	if (PartyEditor_TrackbuilderVersion_Created == "") PartyEditor_TrackbuilderVersion_Created = C_EditorVersion;
	PartyEditor_TrackbuilderVersion_Modified = C_EditorVersion;
	
	SetMapName(CurMapName);
	
	UpdateThumbnail();
	
	// Save map a first time to have a back up if the editor crash during shadows computation
	//SaveMap(CurMapName);
	//WaitReady();
	
	// Compute shadows
	if (G_RandomMapGeneration && !S_RandomMap_Validate) {
		CustomComputeShadows();
	} else if (ValidationStatus == CEditorPlugin::ValidationStatus::Validated) {
		//L16N [MapEditor] Message displayed during the map's shadow computation
		//Loading(True, _("Computing shadows"), True);
		CustomComputeShadows();
	}
	
	//L16N [MapEditor] Message displayed while the map is being saved
	Loading(True, SystemText::GetSavingMessage(), True);
	
	// Achievements update
	declare metadata PartyEditor_AchievementUnlocked for Map = False;
	if (DataMgr != Null && !PartyEditor_AchievementUnlocked && _UnlockAchievements) {
		if (G_RandomMapGeneration) {
			Achievements::TrackValidated(Achievements::Editor_Random());
			PartyEditor_AchievementUnlocked = True;
		} else if (IsEditor(C_Editor_Beginner)) {
			Achievements::TrackValidated(Achievements::Editor_Simple());
			PartyEditor_AchievementUnlocked = True;
		} else if (IsEditor(C_Editor_Advanced)) {
			Achievements::TrackValidated(Achievements::Editor_Normal());
			PartyEditor_AchievementUnlocked = True;
		} else if (IsEditor(C_Editor_Expert)) {
			Achievements::TrackValidated(Achievements::Editor_Expert());
			PartyEditor_AchievementUnlocked = True;
		}
	}
	
	// Save map again once shadows are computed
	SaveMap(CurMapName);
	WaitReady();
	
	Utils::SetSaveStatus(Utils::SaveStatus_Saved());
	
	// Update progression
	CheckProgression();
	
	Loading(False);
}

// ---------------------------------- //
/// Overload the CustomSaveMap function
Void CustomSaveMap(Boolean _SaveAs) {
	CustomSaveMap(_SaveAs, True);
}

// ---------------------------------- //
/** Create a copy of the map
 *
 *	@param	_Save										Save the copy immediatly
 */
Void CopyMap(Boolean _Save) {
	// Wait a bit for the editor to be ready, otherwise it crashes...
	while (!IsEditorReadyForRequest) yield;
	declare TimeLimit = Now + 1000;
	while (Now < TimeLimit) yield;
	
	// Check that there is enough space on disk
	while (DataMgr == Null) yield;
	if (DataMgr != Null) {
		while (DataMgr != Null && !DataMgr.Ready) yield;
		if (DataMgr != Null && DataMgr.Ready) {
			DataMgr.QueryHasFreeSpaceForNewMap(DataMgr.MenuUserId);
			yield;
			while (DataMgr != Null && !DataMgr.Ready) yield;
			if (DataMgr != Null && !DataMgr.HasFreeSpaceForNewMap) {
				return;
			}
		}
	}
	
	UpdateUid();
	
	declare CurMapName = "";
	if (DataMgr != Null && UserMgr != Null && UserMgr.MainUser != Null && CurMapName == "") {
		while (DataMgr != Null && !DataMgr.Ready) yield;
		if (DataMgr != Null && DataMgr.Ready && UserMgr != Null && UserMgr.MainUser != Null) {
			declare persistent PartyEditor_MinEditionId for UserMgr.MainUser = 0;
			DataMgr.GetNewMapEditionId(DataMgr.MenuUserId, PartyEditor_MinEditionId);
			while (DataMgr != Null && !DataMgr.Ready) yield;
			if (DataMgr != Null && DataMgr.Ready && UserMgr != Null && UserMgr.MainUser != Null) {
				CurMapName = DataMgr.NewFileName;
				PartyEditor_MinEditionId = DataMgr.MinEditionId;
				UserMgr.MainUser.PersistentSave();
			}
		}
	}
	if (CurMapName == "") return;
	
	// Save the version of the editor used to create the track
	declare metadata PartyEditor_TrackbuilderVersion_Created for Map = "";
	declare metadata PartyEditor_TrackbuilderVersion_Modified for Map = "";
	if (PartyEditor_TrackbuilderVersion_Created == "") PartyEditor_TrackbuilderVersion_Created = C_EditorVersion;
	PartyEditor_TrackbuilderVersion_Modified = C_EditorVersion;
	
	SetMapName(CurMapName);
	
	while (!IsEditorReadyForRequest) yield;
	if (_Save) SaveMap(CurMapName);
	while (!IsEditorReadyForRequest) yield;
}

// ---------------------------------- //
/** Check if the map contains at least one respawnable checkpoint
 *
 *	@return							True if there is at least one respawnable checkpoint, False otherwise
 */
Boolean HasRespawnableCheckpoint() {
	foreach (Block in Blocks) {
		if (Block == Null) continue;
		if (Block.BlockModel.WaypointType == CBlockModel::EWayPointType::Checkpoint && !Block.BlockModel.NoRespawn) return True;
	}
	
	return False;
}

// ---------------------------------- //
/** Count the number of podium in the map
 *
 *	@return							The number of podium in the track
 */
Integer CountPodium() {
	declare PodiumIds = Ident[];
	
	foreach (Block in Blocks) {
		if (Block == Null) continue;
		if (!PodiumIds.exists(Block.Id) && Block.BlockModel.IsPodium) {
			PodiumIds.add(Block.Id);
		}
	}
	
	return PodiumIds.count;
}

// ---------------------------------- //
/** Ask the player to confirm the validate
 *
 *	@return							True if the player want to validate the map, False otherwise
 */
Boolean ConfirmValidate() {
	if (IsEditor(C_Editor_Beginner)) {
		return Confirm(
			//L16N [MapEditor] Pop-up explaining to the player that his track must be validated before he can play it outside the editor
			_("Validate track"),
			ComposeMultilines([
				//L16N [MapEditor] Pop-up explaining to the player that his track must be validated before he can play it outside the editor
				_("To play this track outside of the editor you need to validate it."),
				//L16N [MapEditor] Pop-up explaining to the player that his track must be validated before he can play it outside the editor
				_("To do so you have to complete one race, from start to finish, passing through all checkpoints.")
			]),
			//L16N [MapEditor] Validate an action
			_("|Infinitive|Validate"),
			//L16N [MapEditor] Cancel an action
			_("Cancel"),
			False
		);
	}
	
	return Confirm(
		//L16N [MapEditor] Pop-up explaining to the player that his track must be validated before he can play it outside the editor
		_("Validate track"),
		ComposeMultilines([
			//L16N [MapEditor] Pop-up explaining to the player that his track must be validated before he can play it outside the editor
			_("To play this track outside of the editor you need to validate it."),
			//L16N [MapEditor] Pop-up explaining to the player that his track must be validated before he can play it outside the editor
			_("Do you want to validate the track now?")
		]),
		//L16N [MapEditor] Validate an action
		_("Yes"),
		//L16N [MapEditor] Cancel an action
		_("No")
	);
}

// ---------------------------------- //
/// Validate the map
Void CustomValidate() {
	declare PodiumNb = CountPodium();
	
	if (!MapContent::HasStart() || GetStartLineBlock() == Null) {
		//L16N [MapEditor] Pop-up warning the player that he has to place a starting line in his track.
		Alert(_("You need to place a starting point!"));
	} else if (GetStartLineBlock().BlockModel.WaypointType == CBlockModel::EWayPointType::StartFinish && (!MapContent::HasCheckpoint() || !HasRespawnableCheckpoint())) {
		//L16N [MapEditor] Pop-up warning the player that he has to place at least one respawnable checkpoint in his track.
		Alert(_("You must place at least one respawnable checkpoint!"));
	} else if (GetStartLineBlock().BlockModel.WaypointType != CBlockModel::EWayPointType::StartFinish && !MapContent::HasFinish()) {
		//L16N [MapEditor] Pop-up warning the player that he has to place at least one finish line in his track.
		Alert(_("You must place at least one finish line!"));
	} else if (IsEditor(C_Editor_Expert) && PodiumNb != 1) {
		if (PodiumNb < 1) {
			Alert(
				ComposeMultilines([
					//L16N [MapEditor] Pop-up warning the player that he has to place exactly one podium.
					_("You have to place exactly one podium!"),
					//L16N [MapEditor] Pop-up warning the player that he has to place exactly one podium.
					_("You can find the podium block in the decoration section of the trackbuilder.")
				])
			);
		} else if (PodiumNb > 1) {
			Alert(
				//L16N [MapEditor] Pop-up warning the player that he has to place exactly one podium. %1 is replaced by the number of podium already placed on the track (always more than one).
				TL::Compose(_("There are %1 podiums on your track. You can only place one."), TL::ToText(PodiumNb))
			);
		}
	} else {
		MapTypeSynchro::NewValidation(False);
		declare LaunchValidation = True;
		if (!G_RandomMapGeneration && ValidationStatus == CEditorPlugin::ValidationStatus::Validated) {
			LaunchValidation = Confirm(
				//L16N [MapEditor] Pop-up asking the player if he wants to improve the validation time of the track
				_("Improve validation time"),
				ComposeMultilines([
					//L16N [MapEditor] Pop-up asking the player if he wants to improve the validation time of the track
					_("This track is already validated."),
					//L16N [MapEditor] Pop-up asking the player if he wants to improve the validation time of the track
					_("Do you want to improve the validation time?")
				]),
				//L16N [MapEditor] Validate an action
				_("|Infinitive|Confirm"), 
				//L16N [MapEditor] Cancel an action
				_("Cancel")
			);
		}
		
		if (LaunchValidation) {
			declare PreviousLapsNb = Map.TMObjective_NbLaps;
			declare MenuWasVisible = UI_Menu::IsVisible();
			declare MenuOutroWasVisible = UI_MenuOutro::IsVisible();
			declare ProgressionWasVisible = UI_Progression::IsVisible();
			declare HeaderWasVisible = UI_Header::IsVisible();
			declare SimpleChoiceWasVisible = UI_SimpleChoice::IsVisible();
			if (MenuWasVisible) UI_Menu::Hide();
			if (MenuOutroWasVisible) UI_MenuOutro::Hide();
			if (ProgressionWasVisible) UI_Progression::Hide();
			if (HeaderWasVisible) UI_Header::Hide();
			if (SimpleChoiceWasVisible) UI_SimpleChoice::Hide();
			Sleep(250);
			
			MapTypeSynchro::TimeToRestore(-1);
			
			// Set the number of laps
			if (GetStartLineBlock().BlockModel.WaypointType == CBlockModel::EWayPointType::StartFinish) {
				UI_Multilaps::Show();
				
				while (!UI_Multilaps::Confirmed() && !UI_Multilaps::Canceled()) {
					Yield();
					UI_Multilaps::Loop();
				}
				
				UI_Multilaps::Hide();
				LaunchValidation = UI_Multilaps::Confirmed();
				
				// We changed the number of laps, reset author time
				if (LaunchValidation && PreviousLapsNb != Map.TMObjective_NbLaps) {
					MapTypeSynchro::TimeToRestore(Map.TMObjective_AuthorTime);
				}
			}
			
			if (LaunchValidation) {
				declare PrevThumbnailUpdate = MapTypeSynchro::GetThumbnailUpdate();
				
				Sleep(250);
				//Loading(True);
				
				if (!ManiaPlanet.HMD_IsActive || !C_DemoSony) {
					//CustomComputeShadows(CEditorPlugin::ShadowsQuality::Default);
					Yield();
				}
			
				// Force map type update
				MapTypeSynchro::AskSynchro();
				declare MaxDuration = Now + 2500;
				while (!MapTypeSynchro::Synchronized()) {
					Yield();
					if (Now > MaxDuration) break;
				}
				
				Camera::SetWorldScale(Camera::WorldScale_Default());
				Camera::SetMoveScale(Camera::MoveScale_Default());
				Camera::SetHudDistance(Camera::HudDistance_Default());
				Validate();
				Sleep(250);
				//Loading(False);
				while (EditorStatus != CEditorPlugin::EditorStatus::ChangeEditor) Yield();
				while (EditorStatus != CEditorPlugin::EditorStatus::Running) Yield();
				Camera::SetWorldScale(Camera::WorldScale_Editor());
				Camera::SetMoveScale(Camera::MoveScale_Editor());
				Camera::SetHudDistance(Camera::HudDistance_Editor());
				
				// Update thumbnail
				if (PrevThumbnailUpdate != MapTypeSynchro::GetThumbnailUpdate()) {
					Camera::UpdateThumbnail(MapTypeSynchro::GetThumbnailPos(), MapTypeSynchro::GetThumbnailRot(), MapTypeSynchro::GetThumbnailFov());
					declare metadata PartyEditor_HasCustomThumbnail for Map = False;
					PartyEditor_HasCustomThumbnail = True;
					MapModified();
				}
				
				if (!G_RandomMapGeneration) Sound::Play("EditorValidationStop");
			}
				
			if (MenuWasVisible) UI_Menu::Show();
			
			Sleep(250);
			
			// The new validation was completed
			if (MapTypeSynchro::NewValidation()) {
				MapModified();
				if (GetMapName() != "") CustomSaveMap(False); //< Save new best author time
			}
			// The new validation was not completed
			else {
				Map.TMObjective_NbLaps = PreviousLapsNb; //< Restore the previous laps nb
			}
			
			if (ProgressionWasVisible) UI_Progression::Show();
			if (HeaderWasVisible) {
				if (ManiaPlanet.HMD_IsActive) UI_Header::SetVisibility(True, False);
				else UI_Header::Show();
			}
			
			if (SimpleChoiceWasVisible) {
				UI_SimpleChoice::Show();
			}
			
			if (MenuOutroWasVisible) {
				UI_MenuOutro::Show();
				OnSequenceStart(G_CurrentSequence);
			}
			
			CheckProgression();
		}
	}
	
	Yield();
	UI_Menu::Select(UI_Menu::Selection_Validate());
	SelectSequence();
}

// ---------------------------------- //
/** Start the map with a mode script
 *
 *	@param	_Validated				Check if the track is validated
 */
Void CustomPlay(Boolean _Validated) {
	if (_Validated && ValidationStatus != CEditorPlugin::ValidationStatus::Validated) {
		//L16N [MapEditor] Pop-up explaining to the player that his track must be validated before he can play it outside the editor
		Alert(_("To play this track outside of the editor you need to validate it."));
		return;
	}
	/*
	//TestMapWithMode("TMC_LocalArcade.Script.txt");
	TestMapWithMode("TimeAttack.Script.txt");
	WaitReady();
	//while (EditorStatus != CEditorPlugin::EditorStatus::ChangeEditor) Yield();
	while (EditorStatus != CEditorPlugin::EditorStatus::Running) Yield();
	*/
}

// ---------------------------------- //
/// Start to test the map on the selected spawn
Void StartTest() {
	declare Block <=> UI_SpawnSelection::GetSpawn();
	if (Block == Null) Block <=> GetStartLineBlock();
	if (Block == Null) return;
	
	declare PrevThumbnailUpdate = MapTypeSynchro::GetThumbnailUpdate();
	// Force map type update
	MapTypeSynchro::AskSynchro();
	declare MaxDuration = Now + 2500;
	while (!MapTypeSynchro::Synchronized()) {
		Yield();
		if (Now > MaxDuration) break;
	}
	
	Camera::SetWorldScale(Camera::WorldScale_Default());
	Camera::SetMoveScale(Camera::MoveScale_Default());
	Camera::SetHudDistance(Camera::HudDistance_Default());
	Yield();
	
	declare PrevUndergroundMode = UndergroundMode;
	UndergroundMode = False;
	TestMapFromCoordWithMapTypeScript(GetSpawnCoord(Block), Utils::DirToDir(Block.Direction));
	while (EditorStatus != CEditorPlugin::EditorStatus::ChangeEditor) Yield();
	while (EditorStatus != CEditorPlugin::EditorStatus::Running) Yield();
	UndergroundMode = PrevUndergroundMode;
	Camera::SetWorldScale(Camera::WorldScale_Editor());
	Camera::SetMoveScale(Camera::MoveScale_Editor());
	Camera::SetHudDistance(Camera::HudDistance_Editor());
			
	SetTestMode(False);
	
	// Update thumbnail
	if (PrevThumbnailUpdate != MapTypeSynchro::GetThumbnailUpdate()) {
		Camera::UpdateThumbnail(MapTypeSynchro::GetThumbnailPos(), MapTypeSynchro::GetThumbnailRot(), MapTypeSynchro::GetThumbnailFov());
		declare metadata PartyEditor_HasCustomThumbnail for Map = False;
		PartyEditor_HasCustomThumbnail = True;
		MapModified();
	}
}

// ---------------------------------- //
/// Remove track
Void RemoveTrack() {
	declare MacroblockUnitsCoords = MapContent::GetMacroblockUnitsCoords(C_Modes_ConstructTrack);
	foreach (MacroblockUnitCoord in MacroblockUnitsCoords) {
		RemoveMacroblock2(MacroblockUnitCoord, C_Modes_ConstructTrack, False, False);
	}
}

// ---------------------------------- //
/// Remove decoration
Void RemoveDecoration() {
	declare MacroblockUnitsCoords = MapContent::GetMacroblockUnitsCoords(C_Modes_ConstructDeco);
	foreach (MacroblockUnitCoord in MacroblockUnitsCoords) {
		RemoveMacroblock2(MacroblockUnitCoord, C_Modes_ConstructDeco, False, False);
	}
	
	declare metadata Boolean PartyEditor_IsDecorated for Map;
	declare metadata Boolean PartyEditor_DecoConfirmed for Map;
	PartyEditor_IsDecorated = False;
	PartyEditor_DecoConfirmed = False;
}

// ---------------------------------- //
/// Confirm decoration
Void ConfirmDecoration() {
	if (!IsDecorated()) return;
	
	declare metadata Boolean PartyEditor_DecoConfirmed for Map;
	PartyEditor_DecoConfirmed = True;
}

// ---------------------------------- //
/// Set decoration ratios to their default values
Void DefaultDecoration() {
	declare metadata Real[Text] PartyEditor_DecoRatios for Map;
	UI_DecoSelection::SetRatios(ThemePack::GetDecoRatios());
}

// ---------------------------------- //
/// Reset map style
Void ResetMapStyle() {
	declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
	declare metadata PartyEditor_MapStyleSelected for Map = False;
	PartyEditor_MapStyle = UI_MapStyleSelection::Style_Race();
	UI_MapStyleSelection::Select(PartyEditor_MapStyle);
	PartyEditor_MapStyleSelected = False;
}

// ---------------------------------- //
/// Reset the plugin
Void Reset(Boolean _Soft) {
	Loading(True);
	
	// Test
	if (_Soft && ManiaPlanet.HMD_IsActive) {
		declare MacroblockUnitsCoords = MapContent::GetMacroblockUnitsCoords(C_Modes_ConstructTrack);
		foreach (MacroblockUnitCoord in MacroblockUnitsCoords) {
			RemoveMacroblock2(MacroblockUnitCoord, C_Modes_ConstructTrack, False, False);
			Yield();
		}
		
		MacroblockUnitsCoords = MapContent::GetMacroblockUnitsCoords(C_Modes_ConstructDeco);
		foreach (MacroblockUnitCoord in MacroblockUnitsCoords) {
			RemoveMacroblock2(MacroblockUnitCoord, C_Modes_ConstructDeco, False, False);
			Yield();
		}
		
		RemoveAllBlocks();
		
		declare UnitSize = 5;
		for (X, 0, Map.Size.X/UnitSize) {
			for (Y, 0, Map.Size.Y/UnitSize) {
				declare Position = <X*UnitSize, 0, Y*UnitSize>;
				declare Size = Position + <UnitSize, 0, UnitSize>;
				declare Removed = RemoveTerrainBlocks(Position, Size);
				Yield();
			}
		}
	}
	
	SetMapName("");
	MapContent::RemoveAllContent();
	RemoveDecoration();
	DefaultDecoration();
	History2::Clear();
	
	RemoveAll();
	WaitReady();
	RemoveTerrain();
	WaitReady();
	
	// Reset thumbnail
	declare metadata PartyEditor_HasCustomThumbnail for Map = False;
	PartyEditor_HasCustomThumbnail = False;
	
	// Reset achievements
	declare metadata PartyEditor_AchievementUnlocked for Map = False;
	PartyEditor_AchievementUnlocked = False;
	
	Utils::SetSaveStatus(Utils::SaveStatus_NotSaved());
	SetCustomTerrain(False);
	if (IsSimpleEditor()) SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
	else SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	UI_Tuto::DisableAll();
	ThemePack::Select(0, 0);
	UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
	ResetMapStyle();
	Loading(False);
}

// ---------------------------------- //
/// Overload Reset()
Void Reset() {
	Reset(False);
}

// ---------------------------------- //
/** Check if a can place a finish at the position
 *
 *	@param	_Coord					The coordinates to check
 *
 *	@return							True if the finish can be placed
 */
Boolean AutoFinish_CanPlaceFinish(Int3 _Coord) {
	declare AutoFinish_Finishes for This = CMacroblockModel[];
	foreach (MacroblockModel in AutoFinish_Finishes) {
		for (I, 0, 3) {
			if (CustomCanPlaceMacroblock(MacroblockModel, _Coord, Utils::IntToDir(I), False)) {
				return True;
			}
		}
	}
	
	return False;
}

// ---------------------------------- //
/** Find the nearest block where a finish can be placed
 *
 *	@param	_Start					The starting point of the search
 *
 *	@return							The position of the first placable finish
 */
Int3 AutoFinish_GetFinishCoord_BFS(Int3 _Start) {
	// Can place finish at start point, exit
	if (AutoFinish_CanPlaceFinish(_Start)) return _Start;
	
	foreach (MacroblockModel in MacroblockModels) {
		if (!Macroblock::GetValidity(MacroblockModel)) continue;
		
		declare AutoFinish_Visited for MacroblockModel = False;
		AutoFinish_Visited = False;
	}
	
	declare Frontier = Int3[];
	Frontier.add(_Start);
	declare Visited = Int3[];
	Visited.add(_Start);
	declare NextYield = C_Tick_GetFinishCoordBFS;
	//CustomSelectionCoords.clear();
	
	while (Frontier.count > 0) {
		declare Current = Frontier[0];
		declare Removed = Frontier.removekey(0);
		declare Neighbors = Utils::GetNeighbors(Current);
		foreach (Neighbor in Neighbors) {
			if (Collection::IsObstacle(Neighbor)) continue;
			if (Visited.exists(Neighbor)) continue;
			Frontier.add(Neighbor);
			Visited.add(Neighbor);
			//CustomSelectionCoords.add(Neighbor);
			if (AutoFinish_CanPlaceFinish(Neighbor)) return Neighbor;
			if (G_CancelGeneration) break;
		}
		NextYield -= 1;
		if (NextYield <= 0) {
			NextYield = C_Tick_GetFinishCoordBFS;
			Yield();
		}
		if (G_CancelGeneration) break;
	}
	
	return _Start;
}

// ---------------------------------- //
/** Find the path to the from a block to another block
 *
 *	@param	_Start					The starting point of the search
 *	@param	_End					The goal of the search
 *
 *	@return							The position of the first placable finish
 */
Int3[] AutoFinish_GetFinishPath_GBFS(Int3 _Start, Int3 _End) {
	declare Frontier = Integer[Int3];
	Frontier[_Start] = 0;
	declare CameFrom = Int3[Int3];
	CameFrom[_Start] = _Start;
	
	declare NextYield = C_Tick_GetFinishCoordGBFS;
	//CustomSelectionCoords.clear();
	
	while (Frontier.count > 0) {
		declare Int3 Current;
		foreach (Coord => Priority in Frontier) {
			Current = Coord;
			break;
		}
		declare Removed = Frontier.removekey(Current);
		declare Neighbors = Utils::GetNeighbors(Current);
		
		foreach (Neighbor in Neighbors) {
			if (Collection::IsObstacle(Neighbor)) continue;
			
			if (!CameFrom.existskey(Neighbor)) {
				Frontier[Neighbor] = Utils::ManhattanDistance(Neighbor, _End);
				CameFrom[Neighbor] = Current;
				//CustomSelectionCoords.add(Neighbor);
				Frontier = Frontier.sort();
				
				if (AutoFinish_CanPlaceFinish(Neighbor)) {
					declare PrevCoord = Neighbor;
					declare Path = [Neighbor];
					declare Limit = CameFrom.count;
					while (True) {
						if (PrevCoord == CameFrom[PrevCoord]) break;
						PrevCoord = CameFrom[PrevCoord];
						
						//CustomSelectionCoords.add(PrevCoord);
						Path.add(PrevCoord);
						
						Limit -= 1;
						if (Limit <= 0) break;
					}
					
					return Path;
				}
			}
			if (G_CancelGeneration) break;
		}
		NextYield -= CameFrom.count / 5000 + 1;
		if (NextYield <= 0) {
			NextYield = C_Tick_GetFinishCoordGBFS;
			Yield();
		}
		if (G_CancelGeneration) break;
	}
	
	return [_Start];
}

// ---------------------------------- //
/** Find the first finish block in the list
 *
 *	@param	_MacroblockModels		The list of macroblock models
 *
 *	@return							A finish macroblock model if found, Null otherwise
 */
CMacroblockModel AutoFinish_GetFinishMacroblock(CMacroblockModel[] _MacroblockModels) {
	foreach (MacroblockModel in _MacroblockModels) {
		if (MacroblockModel.HasFinish && Macroblock::GetClipCount(MacroblockModel) > 0) return MacroblockModel;
	}
	return Null;
}

// ---------------------------------- //
/** Find a path and place a finish
 *
 *	@param	_MaxSteps				Maximum number of blocks to the finish
 *
 *	@return							True if the function placed a finish, False otherwise
 */
Boolean AutoFinish_FindFinish(Integer _MaxSteps) {
	LogRandomMap("----------------");
	LogRandomMap("_MaxSteps : "^_MaxSteps);
	if (_MaxSteps <= 0) return False;
	declare AutoFinish_MaxIterations for This = 0;
	if (AutoFinish_MaxIterations <= 0) return False;
	
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	declare CompatibleMacroblocks = FilterMacroblocks2(False);
	declare Finish <=> AutoFinish_GetFinishMacroblock(CompatibleMacroblocks);
	
	// Skip search if there's no compatible block
	LogRandomMap("CompatibleMacroblocks : "^CompatibleMacroblocks.count);
	if (CompatibleMacroblocks.count <= 0) return False;
	
	// Stop auto-finish if cancel
	if (G_CancelGeneration) return False;
	
	// If the block is a finish stop
	if (Finish != Null) {
		if (Placement::Exists(Finish)) {
			declare CameraCoord = Utils::GetWorldPosition2(Placement::GetCoord(Finish)) + C_CameraCoord_Place;
			if (!G_RandomMapGeneration || !ManiaPlanet.HMD_IsActive) Camera::GoTo(CameraCoord, C_CameraRot_Place);
		}
		declare MacroblockPlaced = AddMacroblock2(Finish.Id, False);
		LogRandomMap("Found a finish : "^Finish);
		return True;
	} 
	// Sort the available blocks
	else if (_MaxSteps > 1) {
		declare Int3[Integer] FinishesCoords;
		declare PrevMacroblockModel <=> MapContent::GetMacroblockModel(G_CursorCoord);
		declare PrevMacroblockCoord = MapContent::GetMacroblockCoord(G_CursorCoord);
		declare PrevMacroblockDir = MapContent::GetMacroblockDir(G_CursorCoord);
		declare PrevDisconnectedClips = MapContent::GetDisconnectedClips(PrevMacroblockModel, PrevMacroblockCoord, PrevMacroblockDir);
		
		foreach (PrevDisconnectedClip in PrevDisconnectedClips) {
			declare ClipCoord = Macroblock::GetClipCoord(PrevMacroblockModel, PrevMacroblockCoord, PrevMacroblockDir, PrevDisconnectedClip);
			// Find the nearest placable finish
			FinishesCoords[PrevDisconnectedClip] = AutoFinish_GetFinishCoord_BFS(ClipCoord);
		}
		
		declare Integer[Text] MacroblockModelsSorting;
		declare Text[] MacroblockModelsSorted;
		declare Integer[Ident][Text] MacroblockModelsToTest;
		declare Int3[Text] MacroblocksCoords;
		declare CEditorPlugin::CardinalDirections[Text] MacroblocksDirs;
		declare AutoFinish_FinishesClips for This = Text[];
		
		foreach (PrevClip => FinishCoord in FinishesCoords) {
			declare PrevClipCoord = Macroblock::GetClipCoord(PrevMacroblockModel, PrevMacroblockCoord, PrevMacroblockDir, PrevClip);
			declare PrevClipName = Macroblock::GetClipName(PrevMacroblockModel, PrevClip);
			
			// Walk the path to the finish and stop at the first crossable obstacle
			// Then determine what are the possible height at which the obstacle can be crossed from a tunnel
			declare PathToFinish = AutoFinish_GetFinishPath_GBFS(PrevClipCoord, FinishCoord);
			declare HeightTargets = Integer[];
			for (Step, 0, PathToFinish.count - 1) {
				declare PathReversedStepCoord = PathToFinish[PathToFinish.count - Step - 1];
				declare Block <=> GetBlock(PathReversedStepCoord);
				if (Block != Null) {
					if (Collection::CrossableExists(Block.BlockModel)) {
						HeightTargets.clear();
						declare CrossableHeights = Collection::GetCrossableHeights(Block.BlockModel);
						foreach (CrossableHeight in CrossableHeights) {
							HeightTargets.add(Block.Coord.Y + CrossableHeight);
						}
					}
				}
			}
			// Compute the smallest height difference between the current clip and the targets
			declare HeightDifference = -1;
			declare HeightTarget = -1;
			foreach (Height in HeightTargets) {
				declare TmpHeightDifference = ML::Abs(Height - PrevClipCoord.Y);
				if (HeightDifference < 0 || TmpHeightDifference < HeightDifference) {
					HeightDifference = TmpHeightDifference;
					HeightTarget = Height;
				}
			}
			// Reset the height target if we're already at the right height
			if (HeightDifference == 0) {
				HeightDifference = -1;
				HeightTarget = -1;
			}
			// Single tunnels have a height step of 4, double tunnels have a height step of 1
			// If the height target is a multiple of 4 we will prioritize "Tunnel" clips, otherwise we'll prioritize "TunnelDouble" clips
			declare PenalizedClips = Integer[Text];
			
			if (Map.CollectionName == "Canyon") {
				if (HeightDifference < 0 || HeightDifference % 4 == 0) PenalizedClips["RoadCaveDoubleFreeClip"] = 1000;
				else PenalizedClips["RoadCaveClip"] = 1000;
				
				// When on cliff roads, privilege first "RoadMain", then "Cliff12RoadHigh" and finaly all the others
				declare CliffClips = ["Cliff12RoadHighClipLeft", "Cliff12RoadHighClipRight", "Cliff12RoadMedClipLeft", "Cliff12RoadMedClipRight"];
				if (CliffClips.exists(PrevClipName)) {
					PenalizedClips["Cliff12RoadHighClipLeft"] = 1000;
					PenalizedClips["Cliff12RoadHighClipRight"] = 1000;
					PenalizedClips["Cliff12RoadMedClipLeft"] = 2000;
					PenalizedClips["Cliff12RoadMedClipRight"] = 2000;
				}
			}
		
			foreach (MacroblockModel in CompatibleMacroblocks) {
				// Skip block disabled for random generation
				if (ThemePack::IsRandomDisabled(MacroblockModel)) continue;
				// Skip blocks that have less than 2 clips
				declare MacroblockModelClips = Macroblock::GetClipNames(MacroblockModel);
				if (MacroblockModelClips.count < 2) continue;
				
				declare BlockDirs = Placement::GetDirs(MacroblockModel);
				declare BlockCoords = Placement::GetCoords(MacroblockModel);
				
				LogRandomMap("MacroblockModel : "^MacroblockModel^" | ClipsNames : "^MacroblockModelClips^" | BlockDirs : "^BlockDirs);
				foreach (Placement => BlockDir in BlockDirs) {
					MacroblockModelsSorting[MacroblockModel.Id^Placement] = 0;
					MacroblockModelsToTest[MacroblockModel.Id^Placement] = [MacroblockModel.Id => Placement];
					MacroblocksCoords[MacroblockModel.Id^Placement] = BlockCoords[Placement];
					MacroblocksDirs[MacroblockModel.Id^Placement] = BlockDir;
					
					declare Total = 0;
					declare TotalWeight = 0;
						
					declare BlockCoord = Placement::GetCoord(MacroblockModel, Placement);
					// Finding disconnected clips consume too mush resources, it's better to use brute force and try all clips
					/*declare DisconnectedClips = MapContent::GetDisconnectedClips(MacroblockModel, BlockCoord, BlockDir);
					foreach (Clip in DisconnectedClips) {*/
					declare BlockClips = Macroblock::GetClipDirs(MacroblockModel);
					foreach (Clip => ClipDir in BlockClips) {
						declare ClipCoord = Macroblock::GetClipCoord(MacroblockModel, BlockCoord, BlockDir, Clip);
						// Weight computation :
						// Good : blocks with 2 clips only
						// Good : blocks that lead faster to the nearest finish
						// Bad : blocks with a clip that end into an obstacle
						// Bad : blocks with a penalized clip
						// Bad : blocks with a turbo
						// Bad : not the auto oriented placement
						// Bad : clip too close of the top of the map
						
						// Compute the clip penalty
						declare ClipPenalty = 0;
						declare ClipName = MacroblockModelClips[Clip];
						if (PenalizedClips.existskey(ClipName)) ClipPenalty += PenalizedClips[ClipName];
						// Penalize clips if it can't be connected to a finish clip
						ClipPenalty += AutoFinish::GetClipPenalty(ClipName, PrevClipCoord) * 1000;
						
						declare HeightPenalty = 0;
						if (HeightTarget < 0) HeightPenalty = ML::Abs(ClipCoord.Y - FinishCoord.Y) * Map.Size.Y;
						else HeightPenalty = ML::Abs(ClipCoord.Y - HeightTarget) * Map.Size.Y;
						declare DistanceToFinish = Utils::ManhattanDistance(ClipCoord, FinishCoord);
						declare Weight = HeightPenalty + DistanceToFinish + ClipPenalty;
						//LogRandomMap("A > Weight : "^Weight^" | HeightPenalty : "^HeightPenalty^" | DistanceToFinish : "^DistanceToFinish^" | ClipPenalty : "^ClipPenalty);
						if (Collection::IsObstacle(ClipCoord)) Weight += Map.Size.Y * Map.Size.Y;
						//LogRandomMap("B > Weight : "^Weight);
						if (Macroblock::GetType(MacroblockModel) == "Turbos") Weight += 1;
						//LogRandomMap("C > Weight : "^Weight);
						if (Placement != Placement::GetPlacement(MacroblockModel)) Weight += 1;
						//LogRandomMap("D > Weight : "^Weight);
						if (Map.Size.Y - 1 - ClipCoord.Y < C_AutoFinish_PaddingTop) Weight += ClipCoord.Y * 1000; ///< Clip is near the top limit, we can't place a finish block that uses 2 blocks
						//LogRandomMap("E > Weight : "^Weight);
						
						Total += 1;
						TotalWeight += Weight;
					}
					
					MacroblockModelsSorting[MacroblockModel.Id^Placement] = TotalWeight / Total;
					
					LogRandomMap("MacroblockModel.Id^Placement > Weight : "^MacroblockModelsSorting[MacroblockModel.Id^Placement]);
				}
			}
		}
		
		// Sort the macroblocks by weight, but randomize the position of the macroblocks with the same weight
		MacroblockModelsSorting = MacroblockModelsSorting.sort();
		declare LastWeight = -1;
		declare TmpSorting = Integer[Text];
		foreach (MacroblockSortId => Weight in MacroblockModelsSorting) {
			if (LastWeight == -1 || LastWeight == Weight) {
				TmpSorting[MacroblockSortId] = Random::Rand(0, 100);
			} else {
				TmpSorting = TmpSorting.sort();
				foreach (TmpId => TmpWeight in TmpSorting) {
					MacroblockModelsSorted.add(TmpId);
				}
				TmpSorting.clear();
				TmpSorting[MacroblockSortId] = Random::Rand(0, 100);
			}
			LastWeight = Weight;
		}
		if (TmpSorting.count > 0) {
			TmpSorting = TmpSorting.sort();
			foreach (TmpId => TmpWeight in TmpSorting) {
				MacroblockModelsSorted.add(TmpId);
			}
			TmpSorting.clear();
		}
		
		LogRandomMap("__________________");
		LogRandomMap("Sorting list : "^MacroblockModelsSorting);
		LogRandomMap("Sorted list : "^MacroblockModelsSorted);
		
		// Loop through the sorted blocks and try to build a path to the finish
		declare InvalidSignaturesKey = Integer[];
		foreach (MacroblockSortId in MacroblockModelsSorted) {
			declare MacroblockModelToTest = MacroblockModelsToTest[MacroblockSortId];
			foreach (MacroblockModelId => Placement in MacroblockModelToTest) {
				declare MacroblockModel <=> MacroblockModels[MacroblockModelId];
				
				// Skip macroblocks that was already tested with the same signature
				declare MacroblockSignature = Macroblock::GetSignatureKey(MacroblockModel);
				if (InvalidSignaturesKey.exists(MacroblockSignature)) continue;
				
				AutoFinish_MaxIterations -= 1;
				
				declare BlockCoord = MacroblocksCoords[MacroblockSortId];
				declare BlockDir = MacroblocksDirs[MacroblockSortId];
				if (!G_RandomMapGeneration || !ManiaPlanet.HMD_IsActive) {
					declare CameraCoord = Utils::GetWorldPosition2(BlockCoord) + C_CameraCoord_Place;
					Camera::GoTo(CameraCoord, C_CameraRot_Place);
				}
				declare MacroblockPlaced = AddMacroblock2(MacroblockModel, BlockCoord, BlockDir, False, True);
				
				SetUndergroundMode(MacroblockModel);
				
				// Slow mode
				if (ManiaPlanet.HMD_IsActive) Sleep(100);
				
				LogRandomMap("Connect macroblock > Placed : "^MacroblockPlaced^" | Coord : "^BlockCoord^" | Dir : "^BlockDir^" | Id : "^MacroblockModelId);
				
				if (MacroblockPlaced) {
					LogRandomMap("Forward from step : "^_MaxSteps);
					declare FinishPlaced = AutoFinish_FindFinish(_MaxSteps - 1);
					LogRandomMap("Backward to step : "^_MaxSteps);
					if (FinishPlaced) {
						return True;
					} else {
						if (!G_RandomMapGeneration || !ManiaPlanet.HMD_IsActive) {
							declare CameraCoord = Utils::GetWorldPosition2(BlockCoord) + C_CameraCoord_Place;
							Camera::GoTo(CameraCoord, C_CameraRot_Place);
						}
						if (CutPasteIsAllowed()) {
							CutMacroblock(); ///< Cut the previous macroblock
							SkipMacroblock();
						} else {
							RemoveMacroblock2(MacroblockModel, BlockCoord, BlockDir, G_Mode, False); ///< Remove the previous macroblock
						}
						LogRandomMap("Removed macroblock : "^MacroblockModel);
						// Filter macroblock again to get the right placements !
						//declare Tmp = FilterMacroblocks2(False);
						
						if (!InvalidSignaturesKey.exists(MacroblockSignature)) InvalidSignaturesKey.add(MacroblockSignature);
					}
				}
				
				if (AutoFinish_MaxIterations <= 0) break;
				
				// Stop auto-finish if cancel
				if (G_CancelGeneration) return False;
			}
			if (AutoFinish_MaxIterations <= 0) break;
			
			// Stop auto-finish if cancel
			if (G_CancelGeneration) return False;
		}
		
		return False;
	}
	
	return False;
}

// ---------------------------------- //
/// Initialize the auto-finish process
Void AutoFinish_Start() {
	CustomSelectionCoords.clear();
	
	declare AutoFinish_MaxIterations for This = 0;
	AutoFinish_MaxIterations = C_AutoFinish_MaxIterations;
	
	declare AutoFinish_Finishes for This = CMacroblockModel[];
	declare AutoFinish_FinishesClips for This = Text[];
	AutoFinish_Finishes.clear();
	AutoFinish_FinishesClips.clear();
	foreach (MacroblockModel in MacroblockModels) {
		if (!Macroblock::GetValidity(MacroblockModel)) continue;
		
		if (MacroblockModel.HasFinish && Macroblock::GetClipCount(MacroblockModel) > 0) {
			AutoFinish_Finishes.add(MacroblockModel);
			declare ClipNames = Macroblock::GetClipNames(MacroblockModel);
			foreach (ClipName in ClipNames) {
				if (!AutoFinish_FinishesClips.exists(ClipName)) AutoFinish_FinishesClips.add(ClipName);
			}
		}
	}
	
	G_CancelGeneration = False;
}

// ---------------------------------- //
/// Clean the auto-finish process
Void AutoFinish_End() {
	CustomSelectionCoords.clear();
}

// ---------------------------------- //
/** Try to place a finish a build a track to it automatically
 *
 *	@param	_Alert					Display an alert if the auto-finish fails
 */
Void AutoFinish(Boolean _Alert) {
	LogRandomMap("Start Auto finish");
	LogRandomMap("==================");
	
	// Update sequence
	G_AutoFinishing = True;
	declare PrevCategory = G_Category;
	declare PrevMode = G_Mode;
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	SelectSequence();
	
	// Find the coordinates of a macroblock with an open clip
	declare StartingCoord = G_CursorCoord;
	declare PrevMacroblock <=> MapContent::GetMacroblockModel(StartingCoord);
	declare PrevMacroblockCoord = MapContent::GetMacroblockCoord(StartingCoord);
	declare PrevMacroblockDir = MapContent::GetMacroblockDir(StartingCoord);
	declare PrevClipsDisconnected = MapContent::GetDisconnectedClips(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir);
	
	if (PrevClipsDisconnected.count <= 0) {
		StartingCoord = MapContent::GetNearestMacroblockUnitCoord(G_CursorCoord, C_Modes_ConstructTrack, True);
		PrevMacroblock <=> MapContent::GetMacroblockModel(StartingCoord);
		PrevMacroblockCoord = MapContent::GetMacroblockCoord(StartingCoord);
		PrevMacroblockDir = MapContent::GetMacroblockDir(StartingCoord);
		PrevClipsDisconnected = MapContent::GetDisconnectedClips(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir);
	}
	
	SetCursorCoord(PrevMacroblockCoord, StartingCoord);
	
	// We found on open block
	if (PrevClipsDisconnected.count > 0) {
		declare Finished = False;
		if (G_RandomMapGeneration) {
			// Try until we can't remove the latest placed block
			declare Count = 0;
			while (!Finished && Count <= 10) {
				LogRandomMap(".............");
				LogRandomMap("AutoFinish > Count : "^Count);
				AutoFinish_Start();
				Finished = AutoFinish_FindFinish(C_AutoFinish_MaxSteps);
				AutoFinish_End();
				
				LogRandomMap("AutoFinish > Finished : "^Finished);
				if (!Finished) {
					declare RemoveCoord = MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, True);
					if (RemoveCoord == Utils::NullCoord()) break;
					LogRandomMap("Try to remove : "^RemoveCoord^" | Macroblock : "^MapContent::GetMacroblockModel(RemoveCoord));
					RemoveMacroblock2(RemoveCoord, True);
					StartingCoord = MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, True);
					if (StartingCoord == Utils::NullCoord()) break;
					
					PrevMacroblock <=> MapContent::GetMacroblockModel(StartingCoord);
					PrevMacroblockCoord = MapContent::GetMacroblockCoord(StartingCoord);
					PrevMacroblockDir = MapContent::GetMacroblockDir(StartingCoord);
					PrevClipsDisconnected = MapContent::GetDisconnectedClips(PrevMacroblock, PrevMacroblockCoord, PrevMacroblockDir);
					LogRandomMap("New starting coord : "^StartingCoord^" | Macroblock : "^PrevMacroblock);
					
					SetCursorCoord(PrevMacroblockCoord, StartingCoord);
					
					if (PrevClipsDisconnected.count <= 0) break;
				}
				
				Count += 1;
			}
		} else {
			Sound::Play("EditorAutoFinish");
			AutoFinish_Start();
			Finished = AutoFinish_FindFinish(C_AutoFinish_MaxSteps);
			AutoFinish_End();
		}
		
		if (Finished) {
			G_MainMenu = False;
			LogRandomMap("Auto-finish succeed");
		} else {
			//L16N [MapEditor] Pop-up explaining to the player that the auto-finish function was not able to place a finish line.
			if (_Alert) Alert(_("The track could not be auto-finished. Remove a few blocks before retrying."));
			LogRandomMap("Auto-finish failed : The track could not be auto-finished.");
		}
	} 
	// We didn't find an open block, cancel autofinish
	else {
		//L16N [MapEditor] Pop-up explaining to the player that the auto-finish function was not able to place a finish line.
		if (_Alert) Alert(_("The track must have an open connector to be auto-finished."));
		LogRandomMap("Auto-finish failed : The track must have an open connector to be auto-finished.");
	}
	
	G_AutoFinishing = False;
	SelectMode(PrevCategory, PrevMode);
	SelectSequence();
	
	LogRandomMap("=================");
	LogRandomMap("Stop auto-finish");
	LogRandomMap("#################");
}

// ---------------------------------- //
/** Place a random start
 *
 *	@return							True if a start was placed, False otherwise
 */
Boolean RandomStart() {
	LogRandomMap("=================");
	LogRandomMap("Start random start");
	
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	SelectSequence();
	
	// Find random start with at least one clip
	declare TriesNb = 50;
	declare StartPlaced = False;
	declare CMacroblockModel[] StartBlocks;
	declare ClipsPriority = RandomStyles::GetClipsPriority();
	// Space to test around the start (3x2 blocks)
	declare Int3[] SpaceToTest;
	for (PosX, -1, 1) {
		for (PosY, 1, 2) {
			SpaceToTest.add(<PosX, 0, PosY>);
		}
	}
	
	List::Clear();
	declare PrimaryList = List::Push();
	declare SecondaryList = List::Push();
	
	for (I, 1, TriesNb) {
		Yield();
		
		// Find start blocks
		foreach (MacroblockModel in MacroblockModels) {
			if (!Macroblock::GetValidity(MacroblockModel)) continue;
			if (MacroblockModel.HasStart && Macroblock::GetClipCount(MacroblockModel) > 0) {
				if (!ThemePack::IsListed(MacroblockModel)) continue;
				if (ThemePack::IsRandomDisabled(MacroblockModel)) continue;
				
				StartBlocks.add(MacroblockModel);
				declare Probability = ML::NearestInteger(RandomStyles::GetMultiplier(MacroblockModel) * 100);
				if (Probability < 0) Probability = 1;
				
				// If the macroblock contained some prioritized clips, add it to the priority list ...
				if (ClipsPriority.count == 0 || Macroblock::GetClipNames(MacroblockModel).containsonly(ClipsPriority)) {
					List::Add(PrimaryList, MacroblockModel, Probability);
				} 
				// ... else add it to the secondary list
				else {
					List::Add(SecondaryList, MacroblockModel, Probability);
				}
			}
		}
		
		// Select random coord
		declare RandomCoord = <0, 0, 0>;
		// Start by searching near the center of the map
		declare Padding = ML::NearestInteger(Map.Size.X * 0.25);
		if (I <= TriesNb - 30) RandomCoord = <Random::Rand(Padding, Map.Size.X-1-Padding), 0, Random::Rand(Padding, Map.Size.Z-1-Padding)>;
		else RandomCoord = <Random::Rand(0, Map.Size.X-1), 0, Random::Rand(0, Map.Size.Z-1)>;
		
		// Try to place a start block
		while (List::Count(PrimaryList) > 0 || List::Count(SecondaryList) > 0) {
			// Get a random start
			declare CMacroblockModel Start;
			declare Boolean Removed;
			if (List::Count(PrimaryList) > 0) {
				declare Found = List::SelectRandom(PrimaryList);
				Start <=> List::GetMacroblockModelFromRandom();
				Removed = List::Remove(PrimaryList, Start);
			} else {
				declare Found = List::SelectRandom(SecondaryList);
				Start <=> List::GetMacroblockModelFromRandom();
				Removed = List::Remove(SecondaryList, Start);
			}
			
			// Try each direction
			declare StartJ = Random::Rand(0, 3);
			declare EndJ = StartJ + 3;
			for (J, StartJ, EndJ) {
				// Try to place the block
				declare Dir = Utils::IntToDir(J % 4);
				
				// Try to place the start on ground at first, then randomly
				if (I < TriesNb - 10) {
					RandomCoord.Y = GetBlockGroundHeight(Start.GeneratedBlockModel, RandomCoord.X, RandomCoord.Z, Dir);
				} else {
					RandomCoord.Y = Random::Rand(0, Map.Size.Y-1);
				}
				
				LogRandomMap("Try to place start > Id : "^Start.Id^" | Coord : "^RandomCoord^" | Dir : "^Dir);
				
				if (CustomCanPlaceMacroblock(Start, RandomCoord, Dir, False)) {
					// Check if there's enough space in front of the start
					declare EnoughSpace = True;
					if (I < TriesNb - 20) {
						foreach (SpaceCoord in SpaceToTest) {
							declare RotatedSpaceCoord = RandomCoord + MU::GetRotatedOffset(SpaceCoord, Dir);
							if (!CustomCanPlaceMacroblock(Start, RotatedSpaceCoord, Dir, False)) {
								EnoughSpace = False;
								break;
							}
						}
					}
					
					if (EnoughSpace) {
						StartPlaced = AddMacroblock2(Start, RandomCoord, Dir, True, True);
						LogRandomMap("Start placed");
						if (StartPlaced) {
							// Align camera in VR
							if (ManiaPlanet.HMD_IsActive) {
								Camera::ResetTracking();
								Camera::MoveTo(RandomCoord + MU::GetRotatedOffset(<-2, 0, 0>, Dir));
								Camera::ZoomTo(300.);
								Camera::RotateTo(MU::GetOpposedDir(Dir), 2);
							}
							break;
						}
					}
				}
			}
			if (StartPlaced || !Removed) break;
		}
		if (StartPlaced) break;
	}
	
	List::Clear();
	
	LogRandomMap("Random start placed : "^StartPlaced);
	
	LogRandomMap("=================");
	LogRandomMap("Stop random start");
	LogRandomMap("#################");
	
	return StartPlaced;
}

// ---------------------------------- //
/** Create a random track
 *
 *	@param	_Distance 				The length of the track to create
 */
Void Private_RandomTrack(Real _Distance) {
	declare StepsNb = 0;
	declare Depth = 0;
	declare Distance = 0.;
	declare MinTurboDistance = 300.;
	declare LastTurboDistance = -MinTurboDistance;
	declare LastCheckpointDistance = 0.;
	declare CMacroblockModel PrevMacroblockModel;
	declare ClipsPriority = RandomStyles::GetClipsPriority();
	
	List::Clear();
	
	LogRandomMap("Start random track");
	LogRandomMap("==================");
	
	// Stop if we reached the maximum number of iterations
	while (StepsNb < C_RandomMap_MaxIterations) {
		LogRandomMap("------------------");
		LogRandomMap("Step : "^StepsNb^" | Depth : "^Depth^" | Distance : "^Distance);
		
		StepsNb += 1;
		
		// Stop if we reach the right distance
		if (Distance > _Distance) break;
		
		// Create or load list
		declare PrimaryListId = 2*Depth;
		declare SecondaryListId = (2*Depth)+1;
		declare CMacroblockModel[] FilteredMacroblocks;
		declare CMacroblockModel[] CheckpointMacroblocks;
		if (!List::Exists(PrimaryListId)) {
			PrimaryListId = List::Push();
			SecondaryListId = List::Push();
			
			declare Integer[CMacroblockModel] PrimaryTransferts;
			declare Integer[CMacroblockModel] SecondaryTransferts;
			declare MacroblockModelFollowUp = ThemePack::GetFollowUp(PrevMacroblockModel);
		
			// Find compatible macroblocks
			FilteredMacroblocks = FilterMacroblocks2(False);
			foreach (MacroblockModel in FilteredMacroblocks) {
				// Skip finish blocks
				if (MacroblockModel.HasFinish) continue;
				// Skip disabled blocks
				if (ThemePack::IsRandomDisabled(MacroblockModel)) continue;
				// Skip blocks that have less than 2 clips
				if (Macroblock::GetClipCount(MacroblockModel) < 2) continue;
				
				// Save and skip checkpoint blocks
				if (MacroblockModel.HasCheckpoint) {
					CheckpointMacroblocks.add(MacroblockModel);
					continue;
				}
				
				declare Ratio = 1000. * RandomStyles::GetMultiplier(MacroblockModel);
				
				// After a turbo reduce probability of selecting a turn or another turbo
				if (Distance - LastTurboDistance < MinTurboDistance) {
					if (Macroblock::GetType(MacroblockModel) == "Turbos") Ratio *= 0.05;
					else if (Macroblock::IsTurning(MacroblockModel)) Ratio *= 0.1;
					else if (Macroblock::IsShifting(MacroblockModel)) Ratio *= 0.5;
				} else {
					if (Map.CollectionName == "Lagoon") {
						// Increase the probability to select a turbo every 300 meters on lagoon rollercoaster
						if (Macroblock::GetFamily(PrevMacroblockModel) == "RoadThemePark" && Macroblock::GetType(MacroblockModel) == "Turbos") {
							Ratio *= 10.; 
						}
					}
				}
				
				declare Probability = ML::NearestInteger(Ratio);
				//if (Probability <= 0) Probability = 1;
				if (Probability < 0) Probability = 0; //< Allow the possibility to completely disable a block at your own risk
				
				declare SelectedListId = -1;
				
				// No clips priority, custom constraints
				if (ClipsPriority.count <= 0) {
					// Check follow up
					if (MacroblockModelFollowUp != "" && Macroblock::GetFullName(MacroblockModel) == MacroblockModelFollowUp) {
						SelectedListId = PrimaryListId;
					}
					// Prefer ground blocks
					else if (Macroblock::GetVariant(MacroblockModel) == Macroblock::VariantGround()) {
						if (Map.CollectionName == "Lagoon") {
							// Prefer freeway on ground
							if (Macroblock::GetFamily(MacroblockModel) == "Freeway") {
								SelectedListId = PrimaryListId;
							} 
							// Try to leave tunnel
							else if (Macroblock::GetFamily(PrevMacroblockModel) == "Tunnel") {
								SelectedListId = PrimaryListId;
							} else {
								SelectedListId = SecondaryListId;
							}
						} else {
							SelectedListId = PrimaryListId;
						}
					} else {
						SelectedListId = SecondaryListId;
					}
				} 
				// Follow clips priority
				else {
					declare ClipNames = Macroblock::GetClipNames(MacroblockModel);
					declare ClipsExists = ClipNames.containsonly(ClipsPriority);
					if (ClipsExists) {
						SelectedListId = PrimaryListId;
					} 
					// ... else add it to the secondary list
					else {
						SelectedListId = SecondaryListId;
					}
					
					// Save transfert macroblocks leading to the prioritized clips
					if (ClipsPriority.count > 0 && Macroblock::IsTransfert(MacroblockModel)) {
						if (ClipNames.containsoneof(ClipsPriority)) {
							PrimaryTransferts[MacroblockModel] = Probability;
						} else {
							SecondaryTransferts[MacroblockModel] = Probability;
						}
					}
				}
				
				declare PlacementCoords = Placement::GetCoords(MacroblockModel);
				declare PlacementDirs = Placement::GetDirs(MacroblockModel);
				for (PlacementKey, 0, PlacementCoords.count-1) {
					List::Add(
						SelectedListId, 
						MacroblockModel, 
						PlacementKey, 
						PlacementCoords[PlacementKey], 
						Utils::DirToInt(PlacementDirs[PlacementKey]), 
						Probability
					);
				}
			}
			
			// If there's no primary macroblocks, then it's probably because the last available clip isn't a prioritized one
			// We'll add the right transfert block to the primary list to fix that
			if (List::Count(PrimaryListId) <= 0) {
				if (PrimaryTransferts.count > 0) {
					foreach (MacroblockModel => Probability in PrimaryTransferts) {
						declare PlacementCoords = Placement::GetCoords(MacroblockModel);
						declare PlacementDirs = Placement::GetDirs(MacroblockModel);
						for (PlacementKey, 0, PlacementCoords.count-1) {
							List::Add(
								PrimaryListId, 
								MacroblockModel, 
								PlacementKey, 
								PlacementCoords[PlacementKey], 
								Utils::DirToInt(PlacementDirs[PlacementKey]), 
								Probability
							);
						}
					}	
				} else {
					foreach (MacroblockModel => Probability in SecondaryTransferts) {
						declare PlacementCoords = Placement::GetCoords(MacroblockModel);
						declare PlacementDirs = Placement::GetDirs(MacroblockModel);
						for (PlacementKey, 0, PlacementCoords.count-1) {
							List::Add(
								PrimaryListId, 
								MacroblockModel, 
								PlacementKey, 
								PlacementCoords[PlacementKey], 
								Utils::DirToInt(PlacementDirs[PlacementKey]), 
								Probability
							);
						}
					}
				}
			}
		}
		
		LogRandomMap("__________________");
		if (C_LogRandom) {
			declare DebugPrimaryList = List::GetAllWithWeight(PrimaryListId);
			declare DebugSecondaryList = List::GetAllWithWeight(SecondaryListId);
			LogRandomMap("Primary list : "^DebugPrimaryList);
			LogRandomMap("Secondary list : "^DebugSecondaryList);
		}
		
		
		declare MacroblockConnected = False;
		
		// If there's no compatible macroblock, decrease depth
		declare FoundMacroblocks = List::Count(PrimaryListId) <= 0 && List::Count(SecondaryListId) <= 0;
		if (FoundMacroblocks) {
			List::Pop();
			List::Pop();
			
			LogRandomMap("******************");
			LogRandomMap("No compatible macroblock");
		} 
		// If there are some compatible macroblocks
		else {
			LogRandomMap("******************");
			LogRandomMap("Some compatible macroblocks");
			
			// Select the macroblock to connect
			declare Ident MacroblockId;
			declare Int3 RandomCoord;
			declare CEditorPlugin::CardinalDirections RandomDir;
			// Try to find a checkpoint
			// if the last checkpoint is at more than MaxCheckpointDistance meters
			// if the finish is at more than 350 meters
			if (CheckpointMacroblocks.count > 0 && Distance - LastCheckpointDistance > RandomStyles::GetCheckpointsSpacing()) {
				declare Checkpoint <=> CheckpointMacroblocks[Random::Rand(0, CheckpointMacroblocks.count-1)];
				MacroblockId = Checkpoint.Id;
				Placement::Select(Checkpoint, 0);
				RandomCoord = Placement::GetCoord(Checkpoint);
				RandomDir = Placement::GetDir(Checkpoint);
				declare Removed = CheckpointMacroblocks.remove(Checkpoint);
				
				LogRandomMap("Select a checkpoint");
				LogRandomMap("Selected : "^Checkpoint);
				
				if (!Removed) break;
			}
			// Try to find a simple block
			if (MacroblockId == NullId) {
				declare CMacroblockModel Macroblock;
				declare Integer Placement;
				declare Int3 Coord;
				declare CEditorPlugin::CardinalDirections Dir;
				
				if (List::Count(PrimaryListId) > 0) {
					declare Found = List::SelectRandom(PrimaryListId);
					Macroblock <=> List::GetMacroblockModelFromRandom();
					Placement = List::GetPlacementFromRandom();
					Coord = List::GetCoordFromRandom();
					Dir = List::GetDirFromRandom();
					declare Removed = List::Remove(PrimaryListId, Macroblock, Placement);
					
					LogRandomMap("Select a macroblock in primary list");
					LogRandomMap("Selected : "^Macroblock);
				} else {
					declare Found = List::SelectRandom(SecondaryListId);
					Macroblock <=> List::GetMacroblockModelFromRandom();
					Placement = List::GetPlacementFromRandom();
					Coord = List::GetCoordFromRandom();
					Dir = List::GetDirFromRandom();
					declare Removed = List::Remove(SecondaryListId, Macroblock, Placement);
					
					LogRandomMap("Select a macroblock in secondary list");
					LogRandomMap("Selected : "^Macroblock);
				}
				if (Macroblock != Null) {
					MacroblockId = Macroblock.Id;
					RandomCoord = Coord;
					RandomDir = Dir;
				}
			}
			
			// Try to connect the macroblock
			if (MacroblockId != NullId) {
				// Check if the macroblock is a checkpoint or a turbo
				declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockId);
				if (MacroblockModel.HasCheckpoint || Macroblock::GetType(MacroblockModel) == "Checkpoints") {
					LastCheckpointDistance = Distance;
					LogRandomMap("It's a checkpoint");
				}
				if (Macroblock::GetType(MacroblockModel) == "Turbos") {
					LastTurboDistance = Distance;
					LogRandomMap("It's a turbo");
				}
				
				// Move camera on block
				declare CameraCoord = Utils::GetWorldPosition2(RandomCoord) + C_CameraCoord_Place;
				if (!ManiaPlanet.HMD_IsActive) Camera::GoTo(CameraCoord, C_CameraRot_Place);
				
				// Connect macroblock
				declare MacroblockPlaced = AddMacroblock2(MacroblockModel, RandomCoord, RandomDir, False, True);
				LogRandomMap("Placed : "^MacroblockPlaced^" | Coord : "^RandomCoord^" | Dir : "^RandomDir^" | MacroblockModel : "^MacroblockModel);
				
				// Slow mode
				if (ManiaPlanet.HMD_IsActive) Sleep(100);
				
				PrevMacroblockModel = MacroblockModel;
				MacroblockConnected = True;
				SetUndergroundMode(MacroblockModel);
				
				// Add the length of the macroblock to the 
				declare Length = Macroblock::GetLength(MacroblockModel);
				if (Length <= 0.) Length = 64.;
				Distance += Length;
			}
		}
		
		// Macroblock connected, increase depth
		if (MacroblockConnected) {
			Depth += 1;
			
			LogRandomMap("++++++++++++++++++");
			LogRandomMap("Macroblock connected with success > Depth : "^Depth);
		} 
		// Couldn't connect a macroblock, disconnect the last one and decrease depth
		else {
			Depth -= 1;
			
			LogRandomMap("++++++++++++++++++");
			LogRandomMap("Can't connect macroblock > Depth : "^Depth);
			
			// Get the macroblock models that we will disconnect
			declare CMacroblockModel[] DisconnectedMacroblockModels;
			declare MacroblockModelsIds = History2::GetMacroblockModelsIds();
			foreach (MacroblockModelId in MacroblockModelsIds) {
				declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
				if (MacroblockModel != Null) DisconnectedMacroblockModels.add(MacroblockModel);
			}
			
			if (Depth >= 0) {
				UndoHistory2();
				
				foreach (MacroblockModel in DisconnectedMacroblockModels) {
					LogRandomMap("Disconnect previous macroblock : "^MacroblockModel.Id);
					
					if (MacroblockModel.HasCheckpoint || Macroblock::GetType(MacroblockModel) == "Checkpoints") {
						LastCheckpointDistance = 0.;
						LogRandomMap("It was a checkpoint");
					}
					if (Macroblock::GetType(MacroblockModel) == "Turbos") {
						LastTurboDistance = 0.;
						LogRandomMap("It was a turbo");
					}
				
					declare Length = Macroblock::GetLength(MacroblockModel);
					if (Length <= 0.) Length = 64.;
					Distance -= Length;
				}
				
				// Remove all macroblocks with the same signature from the list
				declare Integer[] SignaturesKeys;
				foreach (MacroblockModel in DisconnectedMacroblockModels) {
					SignaturesKeys.add(Macroblock::GetSignatureKey(MacroblockModel));
				}
				
				LogRandomMap("Search and remove macroblocks with signature key : "^SignaturesKeys);
				
				for (I, 1, 2) {
					declare PrevListId = 0;
					if (I == 1) PrevListId = 2*Depth; ///< Primary list
					else PrevListId = (2*Depth)+1; ///< Secondary list
				
					declare CompatibleMacroblocks = List::GetAll(PrevListId);
					foreach (Macroblock in CompatibleMacroblocks) {
						if (SignaturesKeys.exists(Macroblock::GetSignatureKey(Macroblock))) {
							declare Removed = List::Remove(PrevListId, Macroblock);
							LogRandomMap("Removed block with same signature from list "^I^" > "^Macroblock.Id);
						}
					}
					
					if (C_LogRandom) {
						declare DebugList = List::GetAll(PrevListId);
						declare DebugNames = Text[];
						foreach (DebugMacroblockModel in DebugList) {
							DebugNames.add(""^DebugMacroblockModel.Id);
						}
						LogRandomMap(""^I^" list : "^DebugNames);
					}
				}
			}
		}
		
		if (!MacroblockConnected) Yield();
		
		// If the user want to stop
		if (G_CancelGeneration) break;
		
		// If there's no compatible block at all, stop
		if (Depth < 0) break;
		
		LogRandomMap("");
		LogRandomMap("");
	}
	
	// Clean history and weighted lists
	List::Clear();
	
	LogRandomMap("=================");
	LogRandomMap("Stop random track");
	LogRandomMap("#################");
}

// ---------------------------------- //
/** Generate a random track
 *
 *	@param	_Length					The length of the track to generate
 */
Void RandomTrack(Real _Length) {
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	SelectSequence();
	
	declare RandomMap_MaxIterations for This = 0;
	RandomMap_MaxIterations = C_RandomMap_MaxIterations;
	
	Private_RandomTrack(_Length);
}

// ---------------------------------- //
/** Get the probability of use for each decoration category
 *
 *	@param	_DecoRatios				The base decoration ratios
 *
 *	@return							The decoration probabilities
 */
Real[Text] GetDecoProbabilities(Real[Text] _DecoRatios) {
	declare Max = 0.;
	declare Total = 0.;
	declare EmptyRatio = 1.;
	foreach (Family => Ratio in _DecoRatios) {
		if (Ratio <= 0.) continue;
		if (Ratio > Max) Max = Ratio;
		Total += Ratio;
	}
	if (Total > 1.) EmptyRatio = 1. / Total;
	
	declare Real[Text] NormalizedRatios;
	foreach (Family => Ratio in _DecoRatios) {
		NormalizedRatios[Family] = Ratio * Max * EmptyRatio;
	}
	
	declare Real[Text] Probabilities;
	declare ProbabilitiesTotal = 0.;
	foreach (Family => Ratio in NormalizedRatios) {
		ProbabilitiesTotal += Ratio;
		Probabilities[Family] = ProbabilitiesTotal;
	}
	
	return Probabilities;
}

// ---------------------------------- //
/** Add decoration to the map
 *
 *	@param	_RandomMap				True if we're generating a full map
 */
Void RandomDecorate2(Boolean _RandomMap) {
	LogRandomMap("Start random decorate");
	LogRandomMap("=================");
	
	// Update sequence
	G_GeneratingDecoration = True;
	SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
	SelectSequence();
	
	// Move camera
	/*declare CameraCoord = MapContent::GetMapBarycentre();
	if (CameraCoord == Utils::NullCoord()) CameraCoord = <Map.Size.X / 2, Map.Size.Y / 2, Map.Size.Z / 2>;
	Camera::MoveTo(CameraCoord);
	Camera::ZoomTo(625.);
	Camera::RotateTo(<5.532, ML::PI()/8.>);*/
	declare PrevCameraZoom = CameraToTargetDistance;
	declare PrevCameraRotationY = Camera::GetRotation().Y;
	if (_RandomMap) {
		//Camera::GoTo(C_CameraCoord_Terraforming, C_CameraRot_Terraforming);
		if (!ManiaPlanet.HMD_IsActive) Camera::CenterOnMap(C_Modes_ConstructTrack, C_CameraZoom_Reroll);
	} else {
		RemoveDecoration();
		Camera::CenterOnMap(C_Modes_ConstructTrack, C_CameraZoom_Terraforming[Map.CollectionName]);
	}
	
	Sleep(250);
	
	// Get list of available deco macroblocks
	declare DecorationTypeAndModels = GetDecorationMacroblocks(True);
	declare DecorationMaxCount = Integer[Ident];
	
	// Create deco type source
	declare Real[Text] DecoRatios;
	declare Real[Text] AdvancedRatios = UI_DecoSelection::GetRatios();
	declare UsePodium = False;
	
	foreach (DecorationType => DecorationMacroblockModels in DecorationTypeAndModels) {
		if (DecorationType == "|Decoration|Podium") {
			declare Amount = C_DefaultPodiumAmount;
			/*if (IsEditor(C_Editor_Beginner)) {
				if (ThemePack::ExistsDecorationRatio(DecorationType)) Amount = ThemePack::GetDecorationRatio(DecorationType);
			} else if (IsEditor(C_Editor_Advanced)) {
				//Amount = 1.;
			} else {
				if (RandomStyles::ExistsMultiplier(DecorationType)) Amount = RandomStyles::GetMultiplier(DecorationType);
			} else {*/
				// Automatically place a podium if there are not any
				if (CountPodium() <= 0) {
					Amount = 1.;
				}
			//}
			if (Amount > 0.) UsePodium = True;
			continue;
		}
		
		declare Amount = C_DefaultDecoAmount;
		/*if (IsEditor(C_Editor_Beginner)) {
			if (ThemePack::ExistsDecorationRatio(DecorationType)) Amount = ThemePack::GetDecorationRatio(DecorationType);
		} else*/ if (IsEditor(C_Editor_Advanced) || IsEditor(C_Editor_Beginner)) {
			if (AdvancedRatios.existskey(DecorationType)) Amount = AdvancedRatios[DecorationType];
		} else {
			if (RandomStyles::ExistsMultiplier(DecorationType)) Amount = RandomStyles::GetMultiplier(DecorationType);
		}
		
		DecoRatios[DecorationType] = Amount;
		
		LogRandomMap(DecorationType^" > Exists : "^RandomStyles::ExistsMultiplier(DecorationType)^" | Amount : "^RandomStyles::GetMultiplier(DecorationType));
	}
	
	// Save deco ratios
	declare metadata Real[Text] PartyEditor_DecoRatios for Map;
	PartyEditor_DecoRatios = DecoRatios;
	
	declare DecoProbabilities = GetDecoProbabilities(DecoRatios);
	LogRandomMap("DecoProbabilities : "^DecoProbabilities);
	
	// Place podium
	if (UsePodium) {
		// Select a random podium macroblock
		declare PodiumMacroblockModel <=> DecorationTypeAndModels["|Decoration|Podium"][Random::Rand(0, DecorationTypeAndModels["|Decoration|Podium"].count-1)];
		declare IsAir = False;
		declare IsUnderground = False;
		declare IsGround = False;
		if (PodiumMacroblockModel.GeneratedBlockModel.VariantGround != Null) {
			IsGround = True;
		} else if (PodiumMacroblockModel.GeneratedBlockModel.VariantAir != Null) {
			if (
				PodiumMacroblockModel.GeneratedBlockModel.VariantAir.IsAllUnderground
				|| PodiumMacroblockModel.GeneratedBlockModel.VariantAir.IsPartUnderground
			) {
				IsUnderground = True;
			} else {
				IsAir = True;
				
				// Try to select a ground variant when possible
				declare MacroblockVariants = Macroblock::GetVariants(PodiumMacroblockModel);
				foreach (VariantId => VariantModelId in MacroblockVariants) {
					if (VariantId != Macroblock::VariantGround()) continue;
					PodiumMacroblockModel <=> Macroblock::GetMacroblockModelFromId(VariantModelId);
					IsGround = True;
					IsAir = False;
					break;
				}
			}
		}
		
		// Select a random points around the finish and spiral around it
		declare Int3 Coord;
		if (MapContent::HasFinish()) Coord = MapContent::GetFinishUnitCoord();
		Coord = <Random::Rand(Coord.X-2, Coord.X+2), Coord.Y, Random::Rand(Coord.Z-2, Coord.Z+2)>;
		if (Coord.X < 0) Coord.X = 0;
		if (Coord.X > Map.Size.X - 1) Coord.X = Map.Size.X - 1;
		if (Coord.Z < 0) Coord.Z = 0;
		if (Coord.Z > Map.Size.Z - 1) Coord.Z = Map.Size.Z - 1;
		declare Vecs = [
			<0, 0, 1>, 
			<-1, 0, 0>, 
			<0, 0, -1>, 
			<1, 0, 0>
		];
		declare I = 0;
		declare J = 0;
		declare N = 0;
		declare Vec = <0, 0, 0>;
		declare Max = Map.Size.X * Map.Size.Z;
		declare Stop = False;
		while (I <= Max) {
			J = (N / 2) + 1;
			Vec = Vecs[N%4];
			N += 1;
			for (K, 1, J) {
				Coord += Vec;
				I += 1;
				
				// Try to place in all direction
				declare StartDir = Random::Rand(0, 3);
				for (L, StartDir, StartDir+3) {
					declare IntDir = L % 4;
					declare Dir = Utils::IntToDir(IntDir);
					declare GroundHeight = GetBlockGroundHeight(PodiumMacroblockModel.GeneratedBlockModel, Coord.X, Coord.Z, Dir);
					declare Coord = <Coord.X % Map.Size.X, GroundHeight, Coord.Z % Map.Size.Z>;
					
					if (IsAir) {
						for (Y, GroundHeight + 1, Map.Size.Y - 1) {
							Coord.Y = Y;
							if (CustomCanPlaceMacroblock(PodiumMacroblockModel, Coord, Dir, False)) {
								declare Placed = AddMacroblock2(PodiumMacroblockModel, Coord, Dir, False, True);
								Stop = True;
								break;
							}
						}
					} else if (IsUnderground) {
						for (RevY, 1, GroundHeight) {
							Coord.Y = GroundHeight - RevY;
								for (Y, GroundHeight + 1, Map.Size.Y - 1) {
								Coord.Y = Y;
								if (CustomCanPlaceMacroblock(PodiumMacroblockModel, Coord, Dir, False)) {
									declare Placed = AddMacroblock2(PodiumMacroblockModel, Coord, Dir, False, True);
									Stop = True;
									break;
								}
							}
						}
					} else if (IsGround) {
						if (CustomCanPlaceMacroblock(PodiumMacroblockModel, Coord, Dir, False)) {
							Coord.Y = GroundHeight;
							declare Placed = AddMacroblock2(PodiumMacroblockModel, Coord, Dir, False, True);
							Stop = True;
						}
					}
					
					if (Max != 0 && I % C_Tick_RandomDecorate == 0) {
						Yield();
					}
					if (Stop) break;
				}
				if (Stop) break;
			}
			if (Stop) break;
		}
	}
	
	// Run the track and try to add deco around it
	declare TrackCoords = MapContent::GetMacroblocksCoords(C_Modes_ConstructTrack);
	LogRandomMap("DecorationTypeAndModels : "^DecorationTypeAndModels);
	LogRandomMap("TrackCoords : "^TrackCoords.count);
	
	//L16N [MapEditor] Message displayed during a decoration progress
	declare ProgressMessage = _("Decoration");
	declare MinBlocksCount = 10;
	if (!G_RandomMapGeneration && TrackCoords.count > MinBlocksCount) UI_PopUp::SetProgress(ProgressMessage, 0);
	
	foreach (Key => TrackCoord in TrackCoords) {
		if (!G_RandomMapGeneration && TrackCoords.count > MinBlocksCount) UI_PopUp::SetProgress(ProgressMessage, ML::FloorInteger((Key / (TrackCoords.count*1.)) * 100));
		
		declare CubeStart = <TrackCoord.X-2, CollectionGroundY, TrackCoord.Z-2>;
		declare CubeEnd = <TrackCoord.X+2, CollectionGroundY, TrackCoord.Z+2>;
		declare Placed = False;
		
		// Check each block around the track
		for (X, CubeStart.X, CubeEnd.X) {
			if (X < 0 || X > Map.Size.X - 1) continue;
			for (Z, CubeStart.Z, CubeEnd.Z) {
				if (Z < 0 || Z > Map.Size.Z - 1) continue;
				
				// Dynamically adjust decoration amount
				declare CopperLimitRatio = 1.;
				if (Map.CopperPrice > C_CopperLimit_Deco) {
					CopperLimitRatio = 1. - ((Map.CopperPrice - C_CopperLimit_Deco) / ((C_CopperLimit_Hard - C_CopperLimit_Deco) * 1.));
					if (CopperLimitRatio < 0.01) CopperLimitRatio = 0.01;
				}
				declare CanPlaceMax = C_DecoLimiter * CopperLimitRatio;
				if (Random::Rand(0., 1., X*Z*1.) > CanPlaceMax) continue;
				
				// Select a random deco macroblock
				declare DecoType = "";
				declare DecoTypeRand = Random::Rand(0., 1., X*Z*1.);
				foreach (Family => Probability in DecoProbabilities) {
					if (DecoTypeRand <= Probability) {
						DecoType = Family;
						break;
					}
				}
				if (DecoType == "") continue;
				declare DecoMacroblockModel <=> DecorationTypeAndModels[DecoType][Random::Rand(0, DecorationTypeAndModels[DecoType].count-1)];
				
				// Try to spread limited blocks on all the track
				declare DecoMacroblockModelLimit = RandomStyles::GetDecoMaxCount(DecoMacroblockModel);
				if (DecoMacroblockModelLimit >= 0) {
					declare SkipLimited = DecoMacroblockModelLimit * (1. / DecorationTypeAndModels[DecoType].count);
					if (Random::Rand(0., 1., X*Z*1.) > SkipLimited) {
						continue;
					}
				}
				
				// Some block have a limited rate
				declare DecoRate = RandomStyles::GetDecoRate(DecoMacroblockModel);
				if (DecoRate < 1.) {
					if (Random::Rand(0., 1., X*Z*1.) > DecoRate) {
						continue;
					}
				}
				
				declare DecoCountUpdate = False;
				declare IsAir = Macroblock::GetVariant(DecoMacroblockModel) == Macroblock::VariantAir();
				
				// Try to place it in all direction
				declare StartDir = Random::Rand(0, 3);
				for (I, StartDir, StartDir+3) {
					declare IntDir = I % 4;
					declare Dir = Utils::IntToDir(IntDir);
					declare Int3 Coord;
					if (IsAir) {
						Coord = <X, TrackCoord.Y+1, Z>;
					} else {
						declare GroundHeight = GetBlockGroundHeight(DecoMacroblockModel.GeneratedBlockModel, X, Z, Dir);
						Coord = <X, GroundHeight, Z>;
					}
					
					if (CustomCanPlaceMacroblock(DecoMacroblockModel, Coord, Dir, False)) {
						// Check that the deco macroblock doesn't obstruct the track
						// It's especially true for arena blocks
						declare MacroblockCoords = Macroblock::GetCoords(DecoMacroblockModel, Coord, Dir);
						declare Int3[] ShiftedMacroblockCoords;
						foreach (MacroblockCoord in MacroblockCoords) ShiftedMacroblockCoords.add(MacroblockCoord - <0, 1, 0>);
						if (!TrackCoords.containsoneof(ShiftedMacroblockCoords)) {
							SetCursorMacroblockModel(DecoMacroblockModel);
							Placed = AddMacroblock2(DecoMacroblockModel, Coord, Dir, False, True);
							if (Placed) DecoCountUpdate = True;
							
							// Slow mode
							if (ManiaPlanet.HMD_IsActive) Sleep(100);
							
							break;
						}
					}
					if (G_CancelGeneration) break;
				}
				
				// Check decoration count limitation
				if (DecoMacroblockModel != Null && DecoCountUpdate) {
					if (!DecorationMaxCount.existskey(DecoMacroblockModel.Id)) {
						DecorationMaxCount[DecoMacroblockModel.Id] = RandomStyles::GetDecoMaxCount(DecoMacroblockModel);
					}
					declare Count = DecorationMaxCount[DecoMacroblockModel.Id];
					if (Count > 0) {
						Count -= 1;
						DecorationMaxCount[DecoMacroblockModel.Id] = Count;
					}
					if (Count == 0) {
						declare Removed = DecorationTypeAndModels[DecoType].remove(DecoMacroblockModel);
					}
				}
				
				if (G_CancelGeneration) break;
			}
			if (G_CancelGeneration) break;
		}
		if (!Placed) Yield();
	}
	
	if (!G_RandomMapGeneration && TrackCoords.count > MinBlocksCount) UI_PopUp::SetProgress(ProgressMessage, 100);
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	if (_RandomMap) {
		
	} else {
		Camera::ZoomTo(PrevCameraZoom);
		Camera::Rotate(<0., ML::ToReal(PrevCameraRotationY - Camera::GetRotation().Y)>);
	}
	
	declare metadata Boolean PartyEditor_IsDecorated for Map;
	PartyEditor_IsDecorated = True;
	G_GeneratingDecoration = False;
	
	if (IsEditor(C_Editor_Advanced)) {
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Decoration())) {
			UI_Tuto::Validate(UI_Tuto::Tuto_Decoration());
			CheckTuto();
		}
	}
	
	UI_PopUp::SetProgress("", -1);
	
	SelectSequence();
	
	LogRandomMap("=================");
	LogRandomMap("Stop random decorate");
	LogRandomMap("#################");
}

// ---------------------------------- //
/** Generate a full random map
 *
 *	@param	_Full					If false, then generate only a basic map with a start and a finish
 *
 *	@return							True if the generation was a success, False otherwise
 */
Boolean Private_RandomMap(Boolean _Full) {
	// Initialization
	G_CancelGeneration = False;
	UndergroundMode = False;
	if (C_RandomMusic) Music::Reset(True);
	
	// Reset map
	Reset(C_DemoSony);
	
	// Generate a random terrain
	if (_Full) {
		//if (C_DemoSony) RandomTerrain(True);
		/*else */RandomLandscape(False, True);
	}
	
	// Save terrain
	declare metadata Boolean PartyEditor_IsTerraformed for Map;
	declare metadata Text PartyEditor_TerrainId for Map;
	declare metadata Integer PartyEditor_TerrainDir for Map;
	PartyEditor_IsTerraformed = True;
	PartyEditor_TerrainId = "FullRandom";
	PartyEditor_TerrainDir = 0;
	G_PreviewTerrainTime = -1;
	G_PreviewTerrainId = "FullRandom";
	
	// Try to place a start
	if (C_RandomMusic) Music::SetTracks([Music::GetTrack("PlaceTerrain_01"), Music::GetTrack("PlaceTerrain_02"), Music::GetTrack("PlaceRoads")]);
	Sleep(500); ///< Let the music catch up
	declare StartPlaced = RandomStart();
	if (!StartPlaced || G_CancelGeneration) return False;
	
	// Slow mode
	if (ManiaPlanet.HMD_IsActive) Sleep(1000);
	
	// Randomly place blocks
	if (_Full) RandomTrack(RandomStyles::GetLength());
	if (G_CancelGeneration) return False;
	
	// Autofinish map
	AutoFinish(False);
	if (G_CancelGeneration) return False;
	
	// Failed to place a finish
	if (!MapContent::HasFinish()) return False;
	
	// Decorate map
	UndergroundMode = False;
	if (C_RandomMusic) Music::SetTracks([Music::GetTrack("PlaceTerrain_01"), Music::GetTrack("PlaceTerrain_02"), Music::GetTrack("PlaceRoads"), Music::GetTrack("PlaceDeco")]);
	Sleep(1000); ///< Let the music catch up
	RandomDecorate2(True);
	if (G_CancelGeneration) return False;
	
	// We completed the track for sure
	// Reset the music
	if (C_RandomMusic) {
		Sound::Play("EditorRandomGenerationFinished");
		Music::Reset(False);
	}
	
	if (!ManiaPlanet.HMD_IsActive) {
		Yield(); //< Wait for the block to be placed before computing shadows
		//CustomComputeShadows(CEditorPlugin::ShadowsQuality::Default);
		Yield();
	}
	
	return True;
}

// ---------------------------------- //
/** Choose to reroll the map or not
 *
 *	@param	_Reroll					True to reroll, false to keep
 */
Void RerollRandomMap(Boolean _Reroll) {
	// Confirm the reroll if we tried to validate the track
	if (S_RandomMap_Validate) {
		if (Utils::GetSaveStatus() != Utils::SaveStatus_Saved() && G_TestedRandomMap) {
			//L16N [MapEditor] Pop-up asking the player to confirm that he wants to generate a new random track and lose the one he generated previously.
			declare ConfirmReroll = Confirm(_("Are you sure you want to generate another track?"));
			if (!ConfirmReroll) {
				G_WaitingRerollAnswer = True;
				G_RerollRandomMap = False;
				return;
			}
		}
	}
	
	if (_Reroll) {
		declare ConfirmReroll = True;
		//L16N [MapEditor] Pop-up asking the player to confirm that he wants to generate a new random track and lose the one he generated previously.
		//if (!G_CancelGeneration) ConfirmReroll = Confirm(_("Are you sure you want to generate another track?"));
		if (ConfirmReroll) {
			G_WaitingRerollAnswer = False;
			G_RerollRandomMap = True;
		} else {
			G_WaitingRerollAnswer = True;
			G_RerollRandomMap = False;
		}
	} else {
		//L16N [MapEditor] Pop-up asking the player if he wants to leave the track editor to play on the track he created
		declare ConfirmLeave = Confirm(_("Are you sure you want to play this track?"));
	
		if (ConfirmLeave) {
			G_WaitingRerollAnswer = False;
			G_RerollRandomMap = False;
		} else {
			G_WaitingRerollAnswer = True;
			G_RerollRandomMap = False;
		}
	}
}

// ---------------------------------- //
/** Rebuild map from metadata
 *
 *	@param	_Terrain				Rebuild the terrain
 *	@param	_Track					Rebuild the track
 *	@param	_Deco					Rebuild the deco
 */
Void RebuildMap(Boolean _Terrain, Boolean _Track, Boolean _Deco) {
	G_RebuildMap = True;
	Loading(True, _("Loading"), False);
	
	// Save
	declare metadata Text PartyEditor_TerrainId for Map;
	declare metadata Integer PartyEditor_TerrainDir for Map;
	declare metadata Boolean PartyEditor_IsDecorated for Map;
	declare metadata Boolean PartyEditor_DecoConfirmed for Map;
	
	declare BackUp_TerrainId = PartyEditor_TerrainId;
	declare BackUp_TerrainDir = PartyEditor_TerrainDir;
	declare BackUp_MacroblockModels = MapContent::GetMacroblockModels();
	declare BackUp_MacroblocksCoords = MapContent::GetMacroblocksCoords();
	declare BackUp_MacroblocksDirs = MapContent::GetMacroblocksDirs();
	declare BackUp_MacroblocksTypes = MapContent::GetMacroblocksTypes();
	declare BackUp_MacroblocksOrders = MapContent::GetMacroblocksOrders().sort();
	declare BackUp_IsCustomTerrain = IsCustomTerrain();
	declare BackUp_IsDecorated = PartyEditor_IsDecorated;
	declare BackUp_DecoConfirmed = PartyEditor_DecoConfirmed;
	
	// Init loading progress
	declare BasePercentage = 30;
	declare TrackPercentage = (100 - BasePercentage) / 2;
	declare DecoPercentage = (100 - BasePercentage) / 2;
	if (_Track && !_Deco) {
		TrackPercentage = 100 - BasePercentage;
		DecoPercentage = 0;
	} else if (!_Track && _Deco) {
		TrackPercentage = 0;
		DecoPercentage = 100 - BasePercentage;
	} else if (!_Track && !_Deco) {
		BasePercentage = 100;
		TrackPercentage = 0;
		DecoPercentage = 0;
	}
	declare TrackCount = 0;
	declare DecoCount = 0;
	foreach (Type in BackUp_MacroblocksTypes) {
		if (Type == C_Modes_ConstructTrack) TrackCount += 1;
		else if (Type == C_Modes_ConstructDeco) DecoCount += 1;
	}
	UI_PopUp::SetLoadingProgress(0);
	
	// Reset
	if (_Terrain) {
		MapContent::RemoveAllContent();
		RemoveDecoration();
		RemoveAll();
		WaitReady();
		RemoveTerrain();
		WaitReady();
		SetCustomTerrain(False);
	} else {
		if (_Track) {
			RemoveTrack();
			MapContent::RemoveAllContent(C_Modes_ConstructTrack);
		}
		if (_Deco) {
			RemoveDecoration();
			MapContent::RemoveAllContent(C_Modes_ConstructDeco);
		}
	}
	History2::Clear();
	
	UI_PopUp::SetLoadingProgress(BasePercentage/2);
	
	Utils::SetSaveStatus(Utils::SaveStatus_NotSaved());
	if (IsSimpleEditor()) SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
	else SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	UI_Tuto::DisableAll();
	ThemePack::Select(0, 0);
	UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
	
	// Restore
	// Terrain
	if (_Terrain) {
		Yield();
		PreviewTerrain2(Macroblock::GetMacroblockModelFromId(BackUp_TerrainId), Utils::IntToDir(BackUp_TerrainDir));
		Yield();
		PlaceTerrain();
		Yield();
		SetCustomTerrain(BackUp_IsCustomTerrain);
	}
	
	UI_PopUp::SetLoadingProgress(BasePercentage);
	
	Yield();
	SelectSequence();
	Yield();
	
	// Track
	if (_Track) {
		declare StartPlaced = False;
		declare Count = 0;
		foreach (Key => Order in BackUp_MacroblocksOrders) {
			declare Type = BackUp_MacroblocksTypes[Key];
			if (Type != C_Modes_ConstructTrack) continue;
			
			declare MacroblockModel = BackUp_MacroblockModels[Key];
			declare Coord = BackUp_MacroblocksCoords[Key];
			declare Dir = Utils::IntToDir(BackUp_MacroblocksDirs[Key]);
			
			if (TrackCount > 0) {
				UI_PopUp::SetLoadingProgress(
					BasePercentage + ML::FloorInteger(TrackPercentage * (Count / (TrackCount*1.)))
				);
				Count += 1;
			}
			
			declare Placed = AddMacroblock2(MacroblockModel, Coord, Dir, False, False);
			
			if (!StartPlaced && (MacroblockModel.HasStart || MacroblockModel.HasMultilap)) {
				StartPlaced = True;
				
				Yield();
				SelectSequence();
				Yield();
			}
		}
	}
	
	Yield();
	SelectSequence();
	Yield();
	
	// Decoration
	if (_Deco) {
		declare Count = 0;
		foreach (Key => Order in BackUp_MacroblocksOrders) {
			declare Type = BackUp_MacroblocksTypes[Key];
			if (Type != C_Modes_ConstructDeco) continue;
			
			declare MacroblockModel = BackUp_MacroblockModels[Key];
			declare Coord = BackUp_MacroblocksCoords[Key];
			declare Dir = Utils::IntToDir(BackUp_MacroblocksDirs[Key]);
			
			if (DecoCount > 0) {
				UI_PopUp::SetLoadingProgress(
					BasePercentage + TrackPercentage + ML::FloorInteger(DecoPercentage * (Count / (DecoCount*1.)))
				);
				Count += 1;
			}
				
			declare Placed = AddMacroblock2(MacroblockModel, Coord, Dir, False, False);
		}
		PartyEditor_IsDecorated = BackUp_IsDecorated;
		PartyEditor_DecoConfirmed = BackUp_DecoConfirmed;
	}
	
	G_AskForValidation = !BackUp_DecoConfirmed;
	
	G_NeedRebuild = False;
	
	// Force sequence refresh
	G_CurrentSequence = C_Sequence_None;
	G_PrevSequence = C_Sequence_None;
	Yield();
	SelectSequence();
	Yield();
	
	Loading(False, "", False);
	G_RebuildMap = False;
}

// ---------------------------------- //
/// Confirm before exiting the editor
Boolean ConfirmQuit() {
	if (!S_RandomMap_Generate && Utils::GetSaveStatus() != Utils::SaveStatus_Saved()) {
		return Confirm(
			//L16N [MapEditor] Pop-up asking the player if he wants to leave the track editor
			_("Leave editor"),
			ComposeMultilines([
				//L16N [MapEditor] Pop-up warning the player that he will loose all his modifications if he confirms the action
				_("Any unsaved modification done on this track will be lost."),
				//L16N [MapEditor] Pop-up asking the player if he wants to leave the track editor
				_("Are you sure you want to leave the editor?")
			]),
			//L16N [MapEditor] Validate an action
			_("|Infinitive|Confirm"),
			//L16N [MapEditor] Cancel an action
			_("Cancel")
		);
	}
	return True;
}

// ---------------------------------- //
/// Confirm before exiting the editor
Void CustomQuit() {
	if (ConfirmQuit()) {
		Camera::SetWorldScale(Camera::WorldScale_Default());
		Camera::SetMoveScale(Camera::MoveScale_Default());
		Camera::SetHudDistance(Camera::HudDistance_Default());
		QuickQuit();
	}
}

// ---------------------------------- //
/** Confirm before exiting the editor and return an event
 *
 *	@param	_Type					The type of event to return
 *	@param	_Data					The data of the event
 */
Void CustomQuit(Text _Type, Text[] _Data) {
	if (ConfirmQuit()) {
		Camera::SetWorldScale(Camera::WorldScale_Default());
		Camera::SetMoveScale(Camera::MoveScale_Default());
		Camera::SetHudDistance(Camera::HudDistance_Default());
		QuickQuitAndSetResult(_Type, _Data);
	}
}

// ---------------------------------- //
/// Valid a selection in the main menu
Void MainMenuValid() {
	if (IsSimpleEditor()) {
		declare Selection = UI_SimpleMenu::Valid();
		
		switch (Selection) {
			case UI_SimpleMenu::Selection_AutoFinish()	: {
				G_MainMenu = False;
				AutoFinish(True);
			}
			case UI_SimpleMenu::Selection_Save()		: CustomSaveMap(False);
			case UI_SimpleMenu::Selection_SaveAs()		: CustomSaveMap(True);
			case UI_SimpleMenu::Selection_New() 		: {
				declare ResetMap = Confirm(
					//L16N [MapEditor] Pop-up asking the player if he wants to create a new track 
					_("New track"),
					ComposeMultilines([
						//L16N [MapEditor] Pop-up warning the player that he will loose all his modifications if he confirms the action
						_("Any unsaved modification done on this track will be lost."),
						//L16N [MapEditor] Pop-up asking the player if he wants to create a new track 
						_("Are you sure you want to create a new track?")
					]),
					//L16N [MapEditor] Validate an action
					_("|Infinitive|Confirm"),
					//L16N [MapEditor] Cancel an action
					_("Cancel")
				);
				if (ResetMap) {
					G_MainMenu = False;
					Reset();
				}
			}
			case UI_SimpleMenu::Selection_Tuto()		: {
				UI_Tuto::Reset();
				G_MainMenu = False;
			}
			case UI_SimpleMenu::Selection_Quit()		: CustomQuit();
			case UI_SimpleMenu::Selection_Back()		: G_MainMenu = False;
		}
		
		UI_SimpleMenu::Select(Selection);
	} else {
		declare Selection = UI_Menu::Valid();
		
		switch (Selection) {
			case UI_Menu::Selection_Validate()		: CustomValidate();
			case UI_Menu::Selection_Style()			: G_MapStyleSelection = True;
			case UI_Menu::Selection_Save()			: CustomSaveMap(False);
			case UI_Menu::Selection_SaveAs()		: CustomSaveMap(True);
			case UI_Menu::Selection_New() 		: {
				declare ResetMap = Confirm(
					//L16N [MapEditor] Pop-up asking the player if he wants to create a new track 
					_("New track"),
					ComposeMultilines([
						//L16N [MapEditor] Pop-up warning the player that he will loose all his modifications if he confirms the action
						_("Any unsaved modification done on this track will be lost."),
						//L16N [MapEditor] Pop-up asking the player if he wants to create a new track 
						_("Are you sure you want to create a new track?")
					]),
					//L16N [MapEditor] Validate an action
					_("|Infinitive|Confirm"),
					//L16N [MapEditor] Cancel an action
					_("Cancel")
				);
				if (ResetMap) {
					G_MainMenu = False;
					Reset();
				}
			}
			case UI_Menu::Selection_Tuto()		: {
				UI_Tuto::Reset();
				G_MainMenu = False;
			}
			case UI_Menu::Selection_Quit()			: CustomQuit();
			case UI_Menu::Selection_Back()			: G_MainMenu = False;
		}
		
		UI_Menu::Select(Selection);
	}
	
	ClearInputBuffer();
	G_TerrainCanPress = False;
}

// ---------------------------------- //
/// Valid a selection in the outro menu
Void OutroMenuValid() {
	declare Selection = UI_MenuOutro::Valid();
	
	switch (Selection) {
		case UI_MenuOutro::Selection_Validate()		: CustomValidate();
		case UI_MenuOutro::Selection_Test()			: SetTestMode(True);
		case UI_MenuOutro::Selection_Style()		: G_MapStyleSelection = True;
		case UI_MenuOutro::Selection_Play() 		: CustomPlay(True);
		case UI_MenuOutro::Selection_Save()			: CustomSaveMap(False);
		case UI_MenuOutro::Selection_SaveAs()		: CustomSaveMap(True);
		case UI_MenuOutro::Selection_EditTrack()	: {
			declare Message = "";
			if (IsEditor(C_Editor_Advanced)) {
				if (ValidationStatus == CEditorPlugin::ValidationStatus::Validated) {
					Message = ComposeMultilines([
						//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
						_("The decoration will be removed and you will have to validate the track again."),
						//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
						_("Are you sure you want to edit this track?")
					]);
				} else {
					Message = ComposeMultilines([
						//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
						_("The decoration will be removed."),
						//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
						_("Are you sure you want to edit this track?")
					]);
				}
			} else {
				if (ValidationStatus == CEditorPlugin::ValidationStatus::Validated) {
					Message = ComposeMultilines([
						//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
						_("You will have to validate the track again."),
						//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
						_("Are you sure you want to edit this track?")
					]);
				} else {
					//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
					Message = _("Are you sure you want to edit this track?");
				}
			}
			declare EditMap = Confirm(
				//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
				_("Edit track"),
				Message,
				//L16N [MapEditor] Validate an action
				_("|Infinitive|Confirm"),
				//L16N [MapEditor] Cancel an action
				_("Cancel")
			);
			if (EditMap) {
				if (G_NeedRebuild) RebuildMap(True, True, True);
				SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
				RemoveDecoration();
				SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
				RemoveAllFinishes(CutPasteIsAllowed());
			}
		}
		case UI_MenuOutro::Selection_EditDeco()		: {
			declare Message = "";
			if (ValidationStatus == CEditorPlugin::ValidationStatus::Validated) {
				Message = ComposeMultilines([
					//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
					_("You will have to validate the track again."),
					//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
					_("Are you sure you want to edit the decoration?")
				]);
			} else {
				//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
				Message = _("Are you sure you want to edit the decoration?");
			}
			declare EditDeco = Confirm(
				//L16N [MapEditor] Pop-up asking confirmation to the player before editing a track
				_("Edit decoration"),
				Message,
				//L16N [MapEditor] Validate an action
				_("|Infinitive|Confirm"),
				//L16N [MapEditor] Cancel an action
				_("Cancel")
			);
			if (EditDeco) {
				if (G_NeedRebuild) RebuildMap(True, True, True);
				SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
				RemoveDecoration();
			}
		}
		case UI_MenuOutro::Selection_Quit()			: CustomQuit();
	}
	
	UI_MenuOutro::Select(Selection);
	ClearInputBuffer();
	G_TerrainCanPress = False;
}

// ---------------------------------- //
/// Valid a selection in the map style menu
Void MapStyleValid() {
	declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
	declare metadata PartyEditor_MapStyleSelected for Map = False;
	PartyEditor_MapStyle = UI_MapStyleSelection::Valid();
	PartyEditor_MapStyleSelected = True;
	
	ClearInputBuffer();
	G_TerrainCanPress = False;
	G_MapStyleSelection = False;
	
	MapModified();
}

// ---------------------------------- //
/// Close the map style menu
Void MapStyleCancel() {
	declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
	UI_MapStyleSelection::Select(PartyEditor_MapStyle);
	G_MapStyleSelection = False;
	Sound::Play("EditorMenuCancel");
}

// ---------------------------------- //
/// Cancel the decoration step and go back to track building
Void CancelDecoration() {
	SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
	RemoveDecoration();
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	RemoveAllFinishes(CutPasteIsAllowed());
}

// ---------------------------------- //
/** Select a skin for the macroblock
 *
 *	@param	_Input					The input to trigger
 *	@param	_IsPreview				Only preview the skin
 */
Void SelectSkin(CEditorPluginEvent::EInput _Input, Boolean _IsPreview) {
	if (!G_IsSkinning) return;
	
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Skin())) {
		UI_Tuto::Validate(UI_Tuto::Tuto_Skin());
		CheckTuto();
	}
	
	switch (_Input) {
		case CEditorPluginEvent::EInput::CursorRight	: UI_SkinSelection::NextSkin(_IsPreview); ///< Select next skin
		case CEditorPluginEvent::EInput::CursorLeft		: UI_SkinSelection::PrevSkin(_IsPreview); ///< Select previous skin
		case CEditorPluginEvent::EInput::IconRight		: UI_SkinSelection::NextSkin(_IsPreview); ///< Select next skin
		case CEditorPluginEvent::EInput::IconLeft		: UI_SkinSelection::PrevSkin(_IsPreview); ///< Select previous skin
	}
}

// ---------------------------------- //
/** Check if we can rotate the camera before applying the rotation
 *
 *	@param	_Rot					The targeted rotation
 */
Void CameraRotate(Vec2 _Rot) {
	if (IsSimpleEditor()) {
		if (G_CurrentSequence == C_Sequence_Simple_Terraforming && Camera::MouseNeedInit()) {
			Camera::MouseInit();
		}
		Camera::Rotate(_Rot);
	} else {
		if (UI_MacroblockSelection::IsSelecting()) return;
		Camera::Rotate(_Rot);
	}
	if (UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_CameraMove_Pad())) {
		UI_Tuto::Validate(UI_Tuto::Tuto_CameraMove_Pad());
		CheckTuto();
	}
}

// ---------------------------------- //
/// Check if we can zoom the camera before applying the zoom
Void CameraZoom() {
	if (IsSimpleEditor()) {
		Camera::Zoom();
	} else {
		if (!UI_MacroblockSelection::IsSelecting()) Camera::Zoom();
	}
	if (UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_CameraMove_Pad())) {
		UI_Tuto::Validate(UI_Tuto::Tuto_CameraMove_Pad());
		CheckTuto();
	}
}

// ---------------------------------- //
/** Check if we can move the macroblock
 *
 *	@param	_Rot					The move input
 */
Void CursorHeight(CEditorPluginEvent::EInput _Input) {
	if (UI_MacroblockSelection::IsSelecting()) return;
	MoveMacroblock(_Input);
}

// ---------------------------------- //
/** Check if the player clicked on the block in the cursor
 *
 *	@return														True if the player clicked on the block, False otherwise
 */
Boolean ClickedOnBlock() {
	declare MacroblockModel = G_CursorMacroblockModel;
	declare Coord = CursorCoord;
	declare Dir = CursorDir;
	if ((G_IsEditing || G_IsSkinning) && MapContent::Exists(CursorCoord)) {
		MacroblockModel = MapContent::GetMacroblockModel(CursorCoord);
		Coord = MapContent::GetMacroblockCoord(CursorCoord);
		Dir = MapContent::GetMacroblockDir(CursorCoord);
	}
	
	declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
	if (Variant != Null) {
		declare MacroblockCoords = Macroblock::GetCoords(MacroblockModel, Coord, Dir, False);
		declare Start = Coord.Y;
		declare End = Coord.Y + Variant.Size.Y - 1;
		for (Y, Start, End) {
			declare ClickedOnBlock = MacroblockCoords.exists(GetMouseCoordAtHeight(Y));
			if (ClickedOnBlock) return True;
		}
	}
	
	return False;
}

// ---------------------------------- //
/// Leave the random editor
Void LeaveRandomEditor() {
	if (Confirm(
		//L16N [MapEditor] Pop-up asking confirmation to the player before leaving the random track generator
		_("Leave random track generator"),
		ComposeMultilines([
			//L16N [MapEditor] Pop-up asking confirmation to the player before leaving the random track generator
			_("Do you want to leave the random track generator")
		]),
		//L16N [MapEditor] Validate an action
		_("|Infinitive|Confirm"),
		//L16N [MapEditor] Cancel an action
		_("Cancel")
	)) CustomQuit();
}

// ---------------------------------- //
/** Validate the rosaces tutorial when pressing the right button
 *
 *	@param	_Input					The input pressed
 */
Void ValidateTutoRosaces(CEditorPluginEvent::EInput _Input) {
	if (
		_Input == CEditorPluginEvent::EInput::CursorUp ||
		_Input == CEditorPluginEvent::EInput::CursorRight ||
		_Input == CEditorPluginEvent::EInput::CursorDown ||
		_Input == CEditorPluginEvent::EInput::CursorLeft ||
		_Input == CEditorPluginEvent::EInput::CursorPick ||
		_Input == CEditorPluginEvent::EInput::CameraUp ||
		_Input == CEditorPluginEvent::EInput::CameraRight ||
		_Input == CEditorPluginEvent::EInput::CameraDown ||
		_Input == CEditorPluginEvent::EInput::CameraLeft
	) {	
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Rosaces())) {
			UI_Tuto::Validate(UI_Tuto::Tuto_Rosaces());
			CheckTuto();
		}
	}
}

// ---------------------------------- //
/** Validate the rosaces tutorial when pressing the right button
 *
 *	@param	_Input					The input pressed
 */
Void ValidateTutoRosaces(Text _Input) {
	if (_Input == UI_MacroblockSelection::Event_MacroblockClick()) {	
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Rosaces())) {
			UI_Tuto::Validate(UI_Tuto::Tuto_Rosaces());
			CheckTuto();
		}
	}
}

// ---------------------------------- //
/** Trigger an input
 *
 *	@param	_Input					The input to trigger
 *	@param	_Device					The device used to do the input
 */
Void TriggerInput(CEditorPluginEvent::EInput _Input, Integer _Device) {
	// Cancel input if a selection is ongoing
	if (Selection::IsSelecting() && !Selection::IsMoveInput(_Input)) return;
	
	switch (G_CurrentSequence) {
		case C_Sequence_RerollMap: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: RandomMenu(); //LeaveRandomEditor(); ///< Leave editor
				//case CEditorPluginEvent::EInput::Undo			:
				//case CEditorPluginEvent::EInput::Redo			:
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				case CEditorPluginEvent::EInput::CursorTurn		: {
					if (S_RandomMap_Validate && MapContent::HasFinish()) {
						if (ValidationStatus != CEditorPlugin::ValidationStatus::Validated) {
							//L16N [MapEditor] Pop-up explaining to the player that his track must be validated before he can play it outside the editor
							Alert(_("To play this track outside of the editor you need to validate it."));
						}
						CustomSaveMap(False);
					}
				}
				//case CEditorPluginEvent::EInput::RemoveAll	:
				//case CEditorPluginEvent::EInput::CursorDelete :
				//case CEditorPluginEvent::EInput::IconUp		:
				//case CEditorPluginEvent::EInput::IconRight	:
				//case CEditorPluginEvent::EInput::IconDown		:
				//case CEditorPluginEvent::EInput::IconLeft		:
				//case CEditorPluginEvent::EInput::CursorUp		:
				//case CEditorPluginEvent::EInput::CursorRight	:
				//case CEditorPluginEvent::EInput::CursorDown	:
				//case CEditorPluginEvent::EInput::CursorLeft	:
				//case CEditorPluginEvent::EInput::CursorPick	:
				case CEditorPluginEvent::EInput::CursorPlace	: {
					if (MapContent::HasFinish()) {
						if (C_DemoSony) CustomValidate(); ///< Test the map
						else if (S_RandomMap_Validate) {
							G_TestedRandomMap = True;
							CustomValidate();
						} else RerollRandomMap(False); ///< Select the current map
					}
				}
				case CEditorPluginEvent::EInput::SwitchToRace	: RerollRandomMap(True); ///< Reroll the map
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< RotateCamera
				//case CEditorPluginEvent::EInput::CameraZoomNext:
			}
		}
		case C_Sequence_MainMenu: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: {
					G_MainMenu = False; ///< Close main menu
					Sound::Play("EditorMenuCancel");
				}
				//case CEditorPluginEvent::EInput::Undo			:
				//case CEditorPluginEvent::EInput::Redo			:
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				//case CEditorPluginEvent::EInput::CursorTurn	:
				case CEditorPluginEvent::EInput::CursorPlace	: MainMenuValid(); ///< Valid menu selection
				//case CEditorPluginEvent::EInput::SwitchToRace	:
				case CEditorPluginEvent::EInput::IconUp			: {
					if (IsSimpleEditor()) UI_SimpleMenu::Prev();
					else UI_Menu::Prev();
				} ///< Previous selection in the menu
				//case CEditorPluginEvent::EInput::IconRight	:
				case CEditorPluginEvent::EInput::IconDown		: {
					if (IsSimpleEditor()) UI_SimpleMenu::Next();
					else UI_Menu::Next();
				} ///< Next selection in the menu
				//case CEditorPluginEvent::EInput::IconLeft		:
				case CEditorPluginEvent::EInput::CursorUp		: {
					if (IsSimpleEditor()) UI_SimpleMenu::Prev();
					else UI_Menu::Prev();
				} ///< Previous selection in the menu
				//case CEditorPluginEvent::EInput::CursorRight	:
				case CEditorPluginEvent::EInput::CursorDown	: {
					if (IsSimpleEditor()) UI_SimpleMenu::Next();
					else UI_Menu::Next();
				} ///< Next selection in the menu
				//case CEditorPluginEvent::EInput::CursorLeft	:
				//case CEditorPluginEvent::EInput::CursorPick	:
				//case CEditorPluginEvent::EInput::CameraUp		:
				//case CEditorPluginEvent::EInput::CameraRight	:
				//case CEditorPluginEvent::EInput::CameraDown	:
				//case CEditorPluginEvent::EInput::CameraLeft	:
				//case CEditorPluginEvent::EInput::CameraZoomNext:
			}
			if (_Device == Buttons2::Device_Pad()) {
				switch (_Input) {
					//case CEditorPluginEvent::EInput::RemoveAll	:
					case CEditorPluginEvent::EInput::CursorDelete	: {
						G_MainMenu = False; ///< Close main menu
						Sound::Play("EditorMenuCancel");
					}
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::RemoveAll		: {
						G_MainMenu = False; ///< Close main menu
						Sound::Play("EditorMenuCancel");
					}
					//case CEditorPluginEvent::EInput::CursorDelete	:
				}
			}
		}
		case C_Sequence_MapStyle: {
			switch (_Input) {
				//case CEditorPluginEvent::EInput::Menu			:
				//case CEditorPluginEvent::EInput::Undo			:
				//case CEditorPluginEvent::EInput::Redo			:
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				//case CEditorPluginEvent::EInput::CursorTurn	:
				case CEditorPluginEvent::EInput::CursorPlace	: MapStyleValid(); ///< Valid map style selection
				//case CEditorPluginEvent::EInput::SwitchToRace	:
				case CEditorPluginEvent::EInput::IconUp			: UI_MapStyleSelection::Prev(); ///< Previous selection in the menu
				//case CEditorPluginEvent::EInput::IconRight	:
				case CEditorPluginEvent::EInput::IconDown		: UI_MapStyleSelection::Next(); ///< Next selection in the menu
				//case CEditorPluginEvent::EInput::IconLeft		:
				case CEditorPluginEvent::EInput::CursorUp		: UI_MapStyleSelection::Prev(); ///< Previous selection in the menu
				//case CEditorPluginEvent::EInput::CursorRight	:
				case CEditorPluginEvent::EInput::CursorDown		: UI_MapStyleSelection::Next(); ///< Next selection in the menu
				//case CEditorPluginEvent::EInput::CursorLeft	:
				//case CEditorPluginEvent::EInput::CursorPick	:
				//case CEditorPluginEvent::EInput::CameraUp		:
				//case CEditorPluginEvent::EInput::CameraRight	:
				//case CEditorPluginEvent::EInput::CameraDown	:
				//case CEditorPluginEvent::EInput::CameraLeft	:
				//case CEditorPluginEvent::EInput::CameraZoomNext:
			}
			if (_Device == Buttons2::Device_Pad()) {
				switch (_Input) {
					//case CEditorPluginEvent::EInput::RemoveAll	:
					case CEditorPluginEvent::EInput::CursorDelete	: MapStyleCancel(); ///< Cancel map style selection
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::RemoveAll		: MapStyleCancel(); ///< Cancel map style selection
					//case CEditorPluginEvent::EInput::CursorDelete	:
				}
			}
		}
		case C_Sequence_SelectTerrain: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
				//case CEditorPluginEvent::EInput::Undo			:
				//case CEditorPluginEvent::EInput::Redo			:
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				//case CEditorPluginEvent::EInput::CursorTurn	:
				case CEditorPluginEvent::EInput::CursorPlace	: PlaceTerrain(); ///< Place the current terrain
				//case CEditorPluginEvent::EInput::RemoveAll	:
				//case CEditorPluginEvent::EInput::CursorDelete	:
				//case CEditorPluginEvent::EInput::SwitchToRace	:
				//case CEditorPluginEvent::EInput::IconUp		:
				//case CEditorPluginEvent::EInput::IconRight	:
				//case CEditorPluginEvent::EInput::IconDown		:
				//case CEditorPluginEvent::EInput::IconLeft		:
				//case CEditorPluginEvent::EInput::CursorUp		:
				//case CEditorPluginEvent::EInput::CursorRight	:
				//case CEditorPluginEvent::EInput::CursorDown	:
				//case CEditorPluginEvent::EInput::CursorLeft	:
				case CEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Landscape); ///< Switch mode
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< RotateCamera
				//case CEditorPluginEvent::EInput::CameraZoomNext:
			}
		}
		case C_Sequence_RandomTerrain: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
				//case CEditorPluginEvent::EInput::Undo			:
				//case CEditorPluginEvent::EInput::Redo			:
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				case CEditorPluginEvent::EInput::CursorTurn		: RandomTerrain(False); ///< Generate random terrain
				case CEditorPluginEvent::EInput::CursorPlace	: PlaceTerrain(); ///< Place the current terrain
				//case CEditorPluginEvent::EInput::RemoveAll	:
				//case CEditorPluginEvent::EInput::CursorDelete	:
				//case CEditorPluginEvent::EInput::SwitchToRace	: 
				//case CEditorPluginEvent::EInput::IconUp		:
				//case CEditorPluginEvent::EInput::IconRight	:
				//case CEditorPluginEvent::EInput::IconDown		:
				//case CEditorPluginEvent::EInput::IconLeft		:
				//case CEditorPluginEvent::EInput::CursorUp		:
				//case CEditorPluginEvent::EInput::CursorRight	:
				//case CEditorPluginEvent::EInput::CursorDown	:
				//case CEditorPluginEvent::EInput::CursorLeft	:
				case CEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Landscape); ///< Switch mode
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< RotateCamera
				//case CEditorPluginEvent::EInput::CameraZoomNext:
			}
		}
		case C_Sequence_PlaceStart: {
			if (UI_MacroblockSelection::IsSelecting()) {
				switch (_Input) {
					case CEditorPluginEvent::EInput::Undo			: PrevStyle(); ///< Previous style
					case CEditorPluginEvent::EInput::Redo			: NextStyle(); ///< Next style
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
					case CEditorPluginEvent::EInput::Undo			: UndoHistory2(); ///< Undo or previous style
					case CEditorPluginEvent::EInput::Redo			: RedoHistory2(); ///< Redo history
					case CEditorPluginEvent::EInput::CursorRaise	: CursorHeight(_Input); ///< Move start macroblock up
					case CEditorPluginEvent::EInput::CursorLower	: CursorHeight(_Input); ///< Move start macroblock down
					case CEditorPluginEvent::EInput::CursorTurn		: RotateMacroblock(1); ///< Rotate start macroblock
					case CEditorPluginEvent::EInput::CursorPlace	: AddStartMacroblock2(); ///< Place start macroblock
					//case CEditorPluginEvent::EInput::RemoveAll	:
					//case CEditorPluginEvent::EInput::CursorDelete	:
					case CEditorPluginEvent::EInput::SwitchToRace	: SetTestMode(True); ///< Switch to test mode
					case CEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Construct); ///< Switch mode
					case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
				}
				if (Buttons2::IsKeyboardOnPC(_Device)) {
					switch (_Input) {
						//case CEditorPluginEvent::EInput::IconUp		:
						case CEditorPluginEvent::EInput::IconRight		: SelectSkin(_Input, False); ///< Select next skin
						//case CEditorPluginEvent::EInput::IconDown		:
						case CEditorPluginEvent::EInput::IconLeft		: SelectSkin(_Input, False); ///< Select previous skin
						case CEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(_Input); ///< Move start macroblock
						case CEditorPluginEvent::EInput::CursorRight	: MoveMacroblock(_Input); ///< Move start macroblock
						case CEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(_Input); ///< Move start macroblock
						case CEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(_Input); ///< Move start macroblock
					}
				} else {
					switch (_Input) {
						case CEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move start macroblock
						case CEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move start macroblock
						case CEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move start macroblock
						case CEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move start macroblock
						//case CEditorPluginEvent::EInput::CursorUp		: 
						case CEditorPluginEvent::EInput::CursorRight	: SelectSkin(_Input, False); ///< Select next skin
						//case CEditorPluginEvent::EInput::CursorDown	: 
						case CEditorPluginEvent::EInput::CursorLeft		: SelectSkin(_Input, False); ///< Select previous skin
					}
				}
			}
		}
		case C_Sequence_ConnectMode: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
				case CEditorPluginEvent::EInput::Undo			: UndoHistory2(); ///< Undo history
				case CEditorPluginEvent::EInput::Redo			: RedoHistory2(); ///< Redo history
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				case CEditorPluginEvent::EInput::CursorTurn		: SwitchMacroblockPlacement(UI_MacroblockSelection::GetMacroblockId()); ///< Switch placement
				case CEditorPluginEvent::EInput::CursorPlace	: G_AllowLongPress = True; ///< Connect macroblock
				//case CEditorPluginEvent::EInput::RemoveAll	:
				case CEditorPluginEvent::EInput::CursorDelete	: RemoveMacroblock2(G_FilteringCoord, False); ///< Remove the previous macroblock
				case CEditorPluginEvent::EInput::SwitchToRace	: SetTestMode(True); ///< Switch to test mode
				//case CEditorPluginEvent::EInput::IconUp		:
				//case CEditorPluginEvent::EInput::IconRight	:
				//case CEditorPluginEvent::EInput::IconDown		:
				//case CEditorPluginEvent::EInput::IconLeft		:
				//case CEditorPluginEvent::EInput::CursorUp		: 
				//case CEditorPluginEvent::EInput::CursorRight	:
				//case CEditorPluginEvent::EInput::CursorDown	:
				//case CEditorPluginEvent::EInput::CursorLeft	:
				case CEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Construct); ///< Switch mode
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
			}
		}
		case C_Sequence_FreeMode: {
			if (UI_MacroblockSelection::IsSelecting()) {
				ValidateTutoRosaces(_Input);
				switch (_Input) {
					case CEditorPluginEvent::EInput::Undo			: PrevStyle(); ///< Previous style
					case CEditorPluginEvent::EInput::Redo			: NextStyle(); ///< Next style
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
					case CEditorPluginEvent::EInput::Undo			: UndoHistory2(); ///< Undo or previous style
					case CEditorPluginEvent::EInput::Redo			: RedoHistory2(); ///< Redo history
					case CEditorPluginEvent::EInput::CursorRaise	: CursorHeight(_Input); ///< Move macroblock up
					case CEditorPluginEvent::EInput::CursorLower	: CursorHeight(_Input); ///< Move macroblock down or next style
					case CEditorPluginEvent::EInput::CursorTurn		: ExpertCursorTurn(); ///< Rotate macroblock
					case CEditorPluginEvent::EInput::CursorPlace	: {
						declare MacroblockPlaced = ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId()); ///< Place macroblock
					}
					//case CEditorPluginEvent::EInput::RemoveAll	:
					case CEditorPluginEvent::EInput::CursorDelete	: ExpertRemoveMacroblock2(CursorCoord);
					case CEditorPluginEvent::EInput::SwitchToRace	: SetTestMode(True); ///< Switch to test mode
					case CEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Construct); ///< Switch mode
					case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
				}
				if (Buttons2::IsKeyboardOnPC(_Device)) {
					switch (_Input) {
						//case CEditorPluginEvent::EInput::IconUp		:
						case CEditorPluginEvent::EInput::IconRight		: SelectSkin(_Input, False); ///< Select next skin
						//case CEditorPluginEvent::EInput::IconDown		:
						case CEditorPluginEvent::EInput::IconLeft		: SelectSkin(_Input, False); ///< Select previous skin
						case CEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(_Input); ///< Move macroblock
						case CEditorPluginEvent::EInput::CursorRight	: MoveMacroblock(_Input); ///< Move macroblock
						case CEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(_Input); ///< Move macroblock
						case CEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(_Input); ///< Move macroblock
					}
				} else {
					switch (_Input) {
						case CEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move macroblock
						case CEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move macroblock
						case CEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move macroblock
						case CEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move macroblock
						//case CEditorPluginEvent::EInput::CursorUp		: 
						case CEditorPluginEvent::EInput::CursorRight	: SelectSkin(_Input, False); ///< Select next skin
						//case CEditorPluginEvent::EInput::CursorDown	: 
						case CEditorPluginEvent::EInput::CursorLeft		: SelectSkin(_Input, False); ///< Select previous skin
					}
				}
			}
		}
		case C_Sequence_TestMode: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
				//case CEditorPluginEvent::EInput::Undo			:
				//case CEditorPluginEvent::EInput::Redo			:
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				//case CEditorPluginEvent::EInput::CursorTurn	:
				case CEditorPluginEvent::EInput::CursorPlace	: StartTest(); ///< Spawn the player
				//case CEditorPluginEvent::EInput::SwitchToRace	:
				//case CEditorPluginEvent::EInput::IconUp		:
				case CEditorPluginEvent::EInput::IconRight		: SelectSpawn(1); ///< Next checkpoint
				//case CEditorPluginEvent::EInput::IconDown		:
				case CEditorPluginEvent::EInput::IconLeft		: SelectSpawn(-1); ///< Previous checkpoint
				//case CEditorPluginEvent::EInput::CursorUp		: 
				case CEditorPluginEvent::EInput::CursorRight	: SelectSpawn(1); ///< Next checkpoint
				//case CEditorPluginEvent::EInput::CursorDown	: 
				case CEditorPluginEvent::EInput::CursorLeft		: SelectSpawn(-1); ///< Previous checkpoint
				case CEditorPluginEvent::EInput::CursorPick		: { SetTestMode(False); SwitchMode(C_Categories_Construct); } ///< Switch mode
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
			}
			if (_Device == Buttons2::Device_Pad()) {
				switch (_Input) {
					//case CEditorPluginEvent::EInput::RemoveAll	:
					case CEditorPluginEvent::EInput::CursorDelete	: SetTestMode(False); ///< Leave test mode
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::RemoveAll		: SetTestMode(False); ///< Leave test mode
					//case CEditorPluginEvent::EInput::CursorDelete	:
				}
			}
		}
		case C_Sequence_AutoFinish: {
			switch (_Input) {
				//case CEditorPluginEvent::EInput::Menu			:
				//case CEditorPluginEvent::EInput::Undo			:
				//case CEditorPluginEvent::EInput::Redo			:
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				//case CEditorPluginEvent::EInput::CursorTurn	:
				//case CEditorPluginEvent::EInput::CursorPlace	:
				//case CEditorPluginEvent::EInput::RemoveAll	:
				//case CEditorPluginEvent::EInput::CursorDelete	: Cancel auto-finish
				//case CEditorPluginEvent::EInput::SwitchToRace	:
				//case CEditorPluginEvent::EInput::IconUp		:
				//case CEditorPluginEvent::EInput::IconRight	:
				//case CEditorPluginEvent::EInput::IconDown		:
				//case CEditorPluginEvent::EInput::IconLeft		:
				//case CEditorPluginEvent::EInput::CursorUp		:
				//case CEditorPluginEvent::EInput::CursorRight	:
				//case CEditorPluginEvent::EInput::CursorDown	:
				//case CEditorPluginEvent::EInput::CursorLeft	:
				//case CEditorPluginEvent::EInput::CursorPick	:
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
			}
		}
		case C_Sequence_EditTerrain: {
			if (!UI_MacroblockSelection::IsSelecting()) {
				switch (_Input) {
					case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
					case CEditorPluginEvent::EInput::Undo			: UndoHistory2(); ///< Undo history
					case CEditorPluginEvent::EInput::Redo			: RedoHistory2(); ///< Redo history
					//case CEditorPluginEvent::EInput::CursorRaise	:
					//case CEditorPluginEvent::EInput::CursorLower	:
					//case CEditorPluginEvent::EInput::CursorTurn	:
					//case CEditorPluginEvent::EInput::CursorPlace	:
					//case CEditorPluginEvent::EInput::RemoveAll	:
					//case CEditorPluginEvent::EInput::CursorDelete	:
					case CEditorPluginEvent::EInput::SwitchToRace	: SetTestMode(True); ///< Switch to test mode
					case CEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Construct); ///< Switch mode
					case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
				}
				if (Buttons2::IsKeyboardOnPC(_Device)) {
					switch (_Input) {
						//case CEditorPluginEvent::EInput::IconUp		:
						//case CEditorPluginEvent::EInput::IconRight	:
						//case CEditorPluginEvent::EInput::IconDown		:
						//case CEditorPluginEvent::EInput::IconLeft		:
						case CEditorPluginEvent::EInput::CursorUp		: MoveTerrain(_Input); ///< Move terrain block
						case CEditorPluginEvent::EInput::CursorRight	: MoveTerrain(_Input); ///< Move terrain block
						case CEditorPluginEvent::EInput::CursorDown		: MoveTerrain(_Input); ///< Move terrain block
						case CEditorPluginEvent::EInput::CursorLeft		: MoveTerrain(_Input); ///< Move terrain block
					}
				} else {
					switch (_Input) {
						case CEditorPluginEvent::EInput::IconUp			: MoveTerrain(_Input); ///< Move terrain block
						case CEditorPluginEvent::EInput::IconRight		: MoveTerrain(_Input); ///< Move terrain block
						case CEditorPluginEvent::EInput::IconDown		: MoveTerrain(_Input); ///< Move terrain block
						case CEditorPluginEvent::EInput::IconLeft		: MoveTerrain(_Input); ///< Move terrain block
						//case CEditorPluginEvent::EInput::CursorUp		:
						//case CEditorPluginEvent::EInput::CursorRight	:
						//case CEditorPluginEvent::EInput::CursorDown	:
						//case CEditorPluginEvent::EInput::CursorLeft	:
					}
				}
			}
		}
		case C_Sequence_EditDecoration: {
			if (UI_MacroblockSelection::IsSelecting()) {
				ValidateTutoRosaces(_Input);
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
					case CEditorPluginEvent::EInput::Undo			: UndoHistory2(); ///< Undo history
					case CEditorPluginEvent::EInput::Redo			: RedoHistory2(); ///< Redo history
					case CEditorPluginEvent::EInput::CursorRaise	: CursorHeight(_Input); ///< Move decoration macroblock
					case CEditorPluginEvent::EInput::CursorLower	: CursorHeight(_Input); ///< Move decoration macroblock
					case CEditorPluginEvent::EInput::CursorTurn		: ExpertCursorTurn(); ///< Rotate macroblock ///< Rotate decoration macroblock
					case CEditorPluginEvent::EInput::CursorPlace	: {
						declare MacroblockPlaced = ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId()); ///< Place the decoration macroblock
					}
					//case CEditorPluginEvent::EInput::RemoveAll	:
					case CEditorPluginEvent::EInput::CursorDelete	: ExpertRemoveMacroblock2(CursorCoord); ///< Remove the decoration macroblock
					case CEditorPluginEvent::EInput::SwitchToRace	: SetTestMode(True); ///< Switch to test mode
					case CEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Construct); ///< Switch mode
					case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
					case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
				}
				if (Buttons2::IsKeyboardOnPC(_Device)) {
					switch (_Input) {
						//case CEditorPluginEvent::EInput::IconUp		:
						case CEditorPluginEvent::EInput::IconRight		: SelectSkin(_Input, False); ///< Select next skin
						//case CEditorPluginEvent::EInput::IconDown		:
						case CEditorPluginEvent::EInput::IconLeft		: SelectSkin(_Input, False); ///< Select previous skin
						case CEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(_Input); ///< Move decoration macroblock
						case CEditorPluginEvent::EInput::CursorRight	: MoveMacroblock(_Input); ///< Move decoration macroblock
						case CEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(_Input); ///< Move decoration macroblock
						case CEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(_Input); ///< Move decoration macroblock
					}
				} else {
					switch (_Input) {
						case CEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move decoration macroblock
						case CEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move decoration macroblock
						case CEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move decoration macroblock
						case CEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move decoration macroblock
						//case CEditorPluginEvent::EInput::CursorUp		: 
						case CEditorPluginEvent::EInput::CursorRight	: SelectSkin(_Input, False); ///< Select next skin
						//case CEditorPluginEvent::EInput::CursorDown	: 
						case CEditorPluginEvent::EInput::CursorLeft		: SelectSkin(_Input, False); ///< Select previous skin
					}
				}
			}
		}
		case C_Sequence_Simple_Terraforming: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				//case CEditorPluginEvent::EInput::CursorTurn	:
				//case CEditorPluginEvent::EInput::RemoveAll	:
				//case CEditorPluginEvent::EInput::CursorDelete	: 
				case CEditorPluginEvent::EInput::CursorPlace	: SelectTerrain();
				//case CEditorPluginEvent::EInput::SwitchToRace	:
				//case CEditorPluginEvent::EInput::IconUp		:
				//case CEditorPluginEvent::EInput::IconRight	:
				//case CEditorPluginEvent::EInput::IconDown		:
				//case CEditorPluginEvent::EInput::IconLeft		:
				//case CEditorPluginEvent::EInput::CursorUp		:
				//case CEditorPluginEvent::EInput::CursorDown	:
				//case CEditorPluginEvent::EInput::CursorPick	:
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< RotateCamera
				//case CEditorPluginEvent::EInput::CameraZoomNext:
			}
			if (Buttons2::IsKeyboardOnPC(_Device)) {
				switch (_Input) {
					//case CEditorPluginEvent::EInput::Undo			:
					//case CEditorPluginEvent::EInput::Redo			:
					case CEditorPluginEvent::EInput::CursorRight	: if (IsEditor(C_Editor_Advanced)) { NextStyle(); UpdateLandscapeSimpleChoice(); }
					case CEditorPluginEvent::EInput::CursorLeft		: if (IsEditor(C_Editor_Advanced)) { PrevStyle(); UpdateLandscapeSimpleChoice(); }
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::Undo			: if (IsEditor(C_Editor_Advanced)) { PrevStyle(); UpdateLandscapeSimpleChoice(); }
					case CEditorPluginEvent::EInput::Redo			: if (IsEditor(C_Editor_Advanced)) { NextStyle(); UpdateLandscapeSimpleChoice(); }
					//case CEditorPluginEvent::EInput::CursorRight	:
					//case CEditorPluginEvent::EInput::CursorLeft	:
				}
			}
		}
		case C_Sequence_Simple_PlaceStart: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
				case CEditorPluginEvent::EInput::Undo			: if (IsEditor(C_Editor_Advanced)) PrevStyle();
				case CEditorPluginEvent::EInput::Redo			: if (IsEditor(C_Editor_Advanced)) NextStyle();
				case CEditorPluginEvent::EInput::CursorTurn		: RotateMacroblock(1); ///< Rotate start macroblock
				case CEditorPluginEvent::EInput::CursorPlace	: AddStartMacroblock2(); ///< Place start macroblock
				//case CEditorPluginEvent::EInput::SwitchToRace	:
				//case CEditorPluginEvent::EInput::RemoveAll	:
				//case CEditorPluginEvent::EInput::CursorDelete	:
				//case CEditorPluginEvent::EInput::CursorPick	: 
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
			}
			if (Buttons2::IsKeyboardOnPC(_Device)) {
				switch (_Input) {
					case CEditorPluginEvent::EInput::CursorRaise	: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorLower	: MoveMacroblock(_Input); ///< Move start macroblock
					//case CEditorPluginEvent::EInput::IconUp		:
					case CEditorPluginEvent::EInput::IconRight		: UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
					//case CEditorPluginEvent::EInput::IconDown		:
					case CEditorPluginEvent::EInput::IconLeft		: UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
					case CEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorRight	: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(_Input); ///< Move start macroblock
				}
			} else {
				switch (_Input) {
					//case CEditorPluginEvent::EInput::CursorRaise	: 
					//case CEditorPluginEvent::EInput::CursorLower	: 
					case CEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(CEditorPluginEvent::EInput::CursorRaise); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorRight	: UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
					case CEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(CEditorPluginEvent::EInput::CursorLower); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorLeft		: UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				}
			}
		}
		case C_Sequence_Simple_BuildTrack: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
				case CEditorPluginEvent::EInput::Undo			: if (IsEditor(C_Editor_Advanced)) PrevStyle();
				case CEditorPluginEvent::EInput::Redo			: if (IsEditor(C_Editor_Advanced)) NextStyle();
				case CEditorPluginEvent::EInput::CursorTurn		: if (IsEditor(C_Editor_Advanced)) SwitchMacroblockPlacement(UI_MacroblockSelection::GetMacroblockId(), True); ///< Switch placement
				//case CEditorPluginEvent::EInput::RemoveAll	:
				case CEditorPluginEvent::EInput::CursorDelete	: {
					if (CutPasteIsAllowed()) CutMacroblock(); ///< Cut the previous macroblock
					else RemoveMacroblock2(MapContent::GetLatestMacroblockUnitCoord(G_Mode, False), False); ///< Remove the previous macroblock
				}
				case CEditorPluginEvent::EInput::CursorPlace	: {
					declare MacroblockPlaced = AddMacroblock2(UI_MacroblockSelection::GetMacroblockId()); ///< Connect macroblock
				}
				case CEditorPluginEvent::EInput::SwitchToRace	: SetTestMode(True); ///< Switch to test mode
				//case CEditorPluginEvent::EInput::IconUp		: if (CutPasteIsAllowed()) PasteMacroblock();
				case CEditorPluginEvent::EInput::IconRight		: UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
				//case CEditorPluginEvent::EInput::IconDown		: if (CutPasteIsAllowed()) SkipMacroblock();
				case CEditorPluginEvent::EInput::IconLeft		: UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				case CEditorPluginEvent::EInput::CursorUp		: if (CutPasteIsAllowed()) PasteMacroblock();
				case CEditorPluginEvent::EInput::CursorRight	: UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
				case CEditorPluginEvent::EInput::CursorDown		: if (CutPasteIsAllowed()) SkipMacroblock();
				case CEditorPluginEvent::EInput::CursorLeft		: UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				case CEditorPluginEvent::EInput::CursorPick		: { if (IsEditor(C_Editor_Advanced)) G_MoveCursor = True; }
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
			}
			if (Buttons2::IsKeyboardOnPC(_Device)) {
				switch (_Input) {
					case CEditorPluginEvent::EInput::CursorRaise	: if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::PrevFamily(); ///< Select previous family
					case CEditorPluginEvent::EInput::CursorLower	: if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::NextFamily(); ///< Select next family
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::CursorRaise	: if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::NextFamily(); ///< Select next family
					case CEditorPluginEvent::EInput::CursorLower	: if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::PrevFamily(); ///< Select previous family
				}
			}
		}
		case C_Sequence_Simple_MoveCursor: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
				case CEditorPluginEvent::EInput::Undo			: PrevStyle();
				case CEditorPluginEvent::EInput::Redo			: NextStyle();
				case CEditorPluginEvent::EInput::CursorTurn		: RotateMacroblock(1); ///< Rotate start macroblock
				case CEditorPluginEvent::EInput::CursorPlace	: {
					declare MacroblockPlaced = ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId()); ///< Place macroblock
				}
				//case CEditorPluginEvent::EInput::RemoveAll	:
				case CEditorPluginEvent::EInput::CursorDelete	: { G_MoveCursor = False; CutMacroblock(); } ///< Cut the previous macroblock
				case CEditorPluginEvent::EInput::SwitchToRace	: SetTestMode(True); ///< Switch to test mode
				case CEditorPluginEvent::EInput::CursorPick		: {
					if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_ConnectMode())) UI_Tuto::Validate(UI_Tuto::Tuto_ConnectMode());
					G_MoveCursor = False; ///< Disable move cursor move
				}
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
			}
			if (Buttons2::IsKeyboardOnPC(_Device)) {
				switch (_Input) {
					case CEditorPluginEvent::EInput::CursorRaise	: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorLower	: MoveMacroblock(_Input); ///< Move start macroblock
					//case CEditorPluginEvent::EInput::IconUp		:
					case CEditorPluginEvent::EInput::IconRight		: UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
					//case CEditorPluginEvent::EInput::IconDown		:
					case CEditorPluginEvent::EInput::IconLeft		: UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
					case CEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorRight	: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(_Input); ///< Move start macroblock
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::CursorRaise	: UI_MacroblockSelection::NextFamily(); ///< Select next family
					case CEditorPluginEvent::EInput::CursorLower	: UI_MacroblockSelection::PrevFamily(); ///< Select previous family
					case CEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(CEditorPluginEvent::EInput::CursorRaise); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorRight	: UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
					case CEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(CEditorPluginEvent::EInput::CursorLower); ///< Move start macroblock
					case CEditorPluginEvent::EInput::CursorLeft		: UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				}
			}
		}
		case C_Sequence_Simple_Test: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: if (!MapContent::HasFinish())G_MainMenu = True; ///< Open main menu
				//case CEditorPluginEvent::EInput::Undo			:
				//case CEditorPluginEvent::EInput::Redo			:
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				//case CEditorPluginEvent::EInput::CursorTurn	:
				case CEditorPluginEvent::EInput::CursorPlace	: StartTest(); ///< Spawn the player
				//case CEditorPluginEvent::EInput::SwitchToRace	:
				//case CEditorPluginEvent::EInput::IconUp		:
				case CEditorPluginEvent::EInput::IconRight		: SelectSpawn(1); ///< Next checkpoint
				//case CEditorPluginEvent::EInput::IconDown		:
				case CEditorPluginEvent::EInput::IconLeft		: SelectSpawn(-1); ///< Previous checkpoint
				//case CEditorPluginEvent::EInput::CursorUp		: 
				case CEditorPluginEvent::EInput::CursorRight	: SelectSpawn(1); ///< Next checkpoint
				//case CEditorPluginEvent::EInput::CursorDown	: 
				case CEditorPluginEvent::EInput::CursorLeft		: SelectSpawn(-1); ///< Previous checkpoint
				//case CEditorPluginEvent::EInput::CursorPick	: 
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< Rotate camera
				case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
			}
			if (_Device == Buttons2::Device_Pad()) {
				switch (_Input) {
					//case CEditorPluginEvent::EInput::RemoveAll	:
					case CEditorPluginEvent::EInput::CursorDelete	: SetTestMode(False); ///< Leave test mode
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::RemoveAll		: SetTestMode(False); ///< Leave test mode
					//case CEditorPluginEvent::EInput::CursorDelete	:
				}
			}
		}
		case C_Sequence_Simple_Deco: {
			switch (_Input) {
				case CEditorPluginEvent::EInput::Menu			: G_MainMenu = True; ///< Open main menu
				case CEditorPluginEvent::EInput::CursorRaise	: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::More();
				case CEditorPluginEvent::EInput::CursorLower	: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::Less();
				case CEditorPluginEvent::EInput::CursorTurn		: DefaultDecoration(); ///< Use default decoration settings
				case CEditorPluginEvent::EInput::CursorPlace	: RandomDecorate2(False); ///< Generate random decoration
				//case CEditorPluginEvent::EInput::RemoveAll	:
				case CEditorPluginEvent::EInput::CursorDelete	: CancelDecoration(); ///< Cancel decoration
				case CEditorPluginEvent::EInput::SwitchToRace	: ConfirmDecoration(); ///< Confirm the decoration
				//case CEditorPluginEvent::EInput::IconUp		:
				//case CEditorPluginEvent::EInput::IconRight	: 
				//case CEditorPluginEvent::EInput::IconDown		:
				//case CEditorPluginEvent::EInput::IconLeft		: 
				//case CEditorPluginEvent::EInput::CursorDown	:
				//case CEditorPluginEvent::EInput::CursorLeft	:
				//case CEditorPluginEvent::EInput::CursorPick	:
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraZoomNext	: CameraZoom(); ///< Change zoom level
			}
			if (Buttons2::IsKeyboardOnPC(_Device)) {
				switch (_Input) {
					//case CEditorPluginEvent::EInput::Undo			:
					//case CEditorPluginEvent::EInput::Redo			:
					case CEditorPluginEvent::EInput::CursorRight	: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::NextFamily();
					case CEditorPluginEvent::EInput::CursorLeft		: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::PrevFamily();
				}
			} else {
				switch (_Input) {
					case CEditorPluginEvent::EInput::Undo			: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::PrevFamily();
					case CEditorPluginEvent::EInput::Redo			: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::NextFamily();
					//case CEditorPluginEvent::EInput::CursorRight	:
					//case CEditorPluginEvent::EInput::CursorLeft	:
				}
			}
		}
		case C_Sequence_Simple_Outro: {
			switch (_Input) {
				//case CEditorPluginEvent::EInput::Menu			:
				//case CEditorPluginEvent::EInput::Undo			:
				//case CEditorPluginEvent::EInput::Redo			:
				//case CEditorPluginEvent::EInput::CursorRaise	:
				//case CEditorPluginEvent::EInput::CursorLower	:
				//case CEditorPluginEvent::EInput::CursorTurn	:
				//case CEditorPluginEvent::EInput::RemoveAll	:
				//case CEditorPluginEvent::EInput::CursorDelete	:
				case CEditorPluginEvent::EInput::CursorPlace	: OutroMenuValid(); ///< Valid menu selection
				//case CEditorPluginEvent::EInput::SwitchToRace	:
				case CEditorPluginEvent::EInput::IconUp			: UI_MenuOutro::Prev(); ///< Previous selection in the menu
				//case CEditorPluginEvent::EInput::IconRight	:
				case CEditorPluginEvent::EInput::IconDown		: UI_MenuOutro::Next(); ///< Next selection in the menu
				//case CEditorPluginEvent::EInput::IconLeft		:
				case CEditorPluginEvent::EInput::CursorUp		: UI_MenuOutro::Prev(); ///< Previous selection in the menu
				//case CEditorPluginEvent::EInput::CursorRight	:
				case CEditorPluginEvent::EInput::CursorDown		: UI_MenuOutro::Next(); ///< Next selection in the menu
				//case CEditorPluginEvent::EInput::CursorLeft	:
				//case CEditorPluginEvent::EInput::CursorPick	:
				case CEditorPluginEvent::EInput::CameraUp		: CameraRotate(<0., 1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraRight	: CameraRotate(<1., 0.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraDown		: CameraRotate(<0., -1.>); ///< RotateCamera
				case CEditorPluginEvent::EInput::CameraLeft		: CameraRotate(<-1., 0.>); ///< RotateCamera
				//case CEditorPluginEvent::EInput::CameraZoomNext:
			}
		}
	}
}

// ---------------------------------- //
/** Trigger inputs from the skin selection UI
 *
 *	@param	_EventType				The input to trigger
 *	@param	_EventData				The event data
 */
Void TriggerSkinInput(Text _EventType, Text[] _EventData) {
	switch (_EventType) {
		case UI_SkinSelection::Event_SkinHover(): {
			UI_SkinSelection::SelectSkin(TL::ToInteger(_EventData[0]), True, True);
		}
		case UI_SkinSelection::Event_SkinClick(): {
			UI_SkinSelection::SelectSkin(TL::ToInteger(_EventData[0]), True, False);
		}
		case UI_SkinSelection::Event_SkinNext(): {
			SelectSkin(CEditorPluginEvent::EInput::CursorRight, False); ///< Select next skin
		}
		case UI_SkinSelection::Event_SkinPrev(): {
			SelectSkin(CEditorPluginEvent::EInput::CursorLeft, False); ///< Select next skin
		}
		case UI_SkinSelection::Event_SkinRestore(): {
			UI_SkinSelection::CancelPreview();
		}
	}
}

// ---------------------------------- //
/** Trigger an input
 *
 *	@param	_Input					The input to trigger
 */
Void TriggerInput(Text[][Text] _Input) {
	declare EventType = "";
	declare EventData = Text[];
	
	foreach (Type => Data in _Input) {
		EventType = Type;
		EventData = Data;
	}
	
	// Cancel input if a selection is ongoing
	if (Selection::IsSelecting() && !Selection::IsMoveEvent(EventType)) return;
	
	switch (G_CurrentSequence) {
		case C_Sequence_RerollMap: {
			switch (EventType) {
				case UI_SimpleChoice::Event_Click(): {
					declare Action = TL::ToInteger(EventData[0]);
					switch (Action) {
						case C_SimpleChoice_RandomGenerate	: RerollRandomMap(True); ///< Reroll the map
						case C_SimpleChoice_RandomSave		: {
							if (S_RandomMap_Validate && MapContent::HasFinish()) {
								if (ValidationStatus != CEditorPlugin::ValidationStatus::Validated) {
									//L16N [MapEditor] Pop-up explaining to the player that his track must be validated before he can play it outside the editor
									Alert(_("To play this track outside of the editor you need to validate it."));
								}
								CustomSaveMap(False);
							}
						}
						case C_SimpleChoice_RandomPlay		: {
							if (MapContent::HasFinish()) {
								if (C_DemoSony) CustomValidate(); ///< Test the map
								else if (S_RandomMap_Validate) {
									G_TestedRandomMap = True;
									CustomValidate();
								} else RerollRandomMap(False); ///< Select the current map
							}
						}
					}
				}
			}
		}
		case C_Sequence_MainMenu: {
			if (IsSimpleEditor()) {
				switch (EventType) {
					case UI_SimpleMenu::Event_Hover(): UI_SimpleMenu::Select(TL::ToInteger(EventData[0]), True);
					case UI_SimpleMenu::Event_Click(): {
						UI_SimpleMenu::Select(TL::ToInteger(EventData[0]));
						MainMenuValid(); ///< Valid menu selection
					}
				}
			} else {
				switch (EventType) {
					case UI_Menu::Event_Hover(): UI_Menu::Select(TL::ToInteger(EventData[0]), True);
					case UI_Menu::Event_Click(): {
						UI_Menu::Select(TL::ToInteger(EventData[0]));
						MainMenuValid(); ///< Valid menu selection
					}
				}
			}
		}
		case C_Sequence_MapStyle: {
			switch (EventType) {
				case UI_MapStyleSelection::Event_Hover(): UI_MapStyleSelection::Select(TL::ToInteger(EventData[0]), True);
				case UI_MapStyleSelection::Event_Click(): {
					UI_MapStyleSelection::Select(TL::ToInteger(EventData[0]));
					MapStyleValid(); ///< Valid map style selection
				}
				case UI_MapStyleSelection::Event_Confirm(): MapStyleValid(); ///< Valid map style selection
				case UI_MapStyleSelection::Event_Cancel():  MapStyleCancel(); ///< Cancel map style selection
			}
		}
		case C_Sequence_PlaceStart: {
			if (UI_MacroblockSelection::IsSelecting()) {
				switch (EventType) {
					case UI_MacroblockSelection::Event_FamilyNext(): NextStyle(); ///< Next style
					case UI_MacroblockSelection::Event_FamilyPrev(): PrevStyle(); ///< Previous style
					case UI_Header::Event_SelectMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
				}
			} else {
				TriggerSkinInput(EventType, EventData);
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_MouseControl::Event_GetCoordinates(): {
						declare ClickedCoord = GetMouseCoordAtHeight(CursorCoord.Y);
						if (ClickedCoord != <-1, -1, -1>) {
							if (ClickedOnBlock()) {
								AddStartMacroblock2(); ///< Place start macroblock
								if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_PlaceBlock_Mouse())) {
									UI_Tuto::Validate(UI_Tuto::Tuto_PlaceBlock_Mouse());
									CheckTuto();
								}
							} else {
								MoveMacroblock(ClickedCoord - G_ForcedCursorCoord, False);
								ExpertCursorConnect(UI_MacroblockSelection::GetMacroblockId(), ClickedCoord);
							}
						}
					}
				}
			}
		}
		case C_Sequence_ConnectMode: {
			switch (EventType) {
				case UI_Header::Event_SelectMode(): {
					SelectMode(EventData[0]);
				}
				case UI_Header::Event_SwitchMode(): {
					SwitchMode(C_Categories_Construct); ///< Switch mode
				}
			}
		}
		case C_Sequence_FreeMode: {
			ValidateTutoRosaces(EventType);
			if (UI_MacroblockSelection::IsSelecting()) {
				//ValidateTutoRosaces(EventType);
				switch (EventType) {
					case UI_MacroblockSelection::Event_FamilyNext(): NextStyle(); ///< Next style
					case UI_MacroblockSelection::Event_FamilyPrev(): PrevStyle(); ///< Previous style
					case UI_Header::Event_SelectMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
				}
			} else {
				TriggerSkinInput(EventType, EventData);
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_MouseControl::Event_GetCoordinates(): {
						declare ClickedCoord = GetMouseCoordAtHeight(CursorCoord.Y);
						if (ClickedCoord != <-1, -1, -1>) {
							if (ClickedOnBlock()) {
								declare MacroblockPlaced = ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId());
								if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_PlaceBlock_Mouse())) {
									UI_Tuto::Validate(UI_Tuto::Tuto_PlaceBlock_Mouse());
									CheckTuto();
								}
							} else {
								MoveMacroblock(ClickedCoord - G_ForcedCursorCoord, False);
								ExpertCursorConnect(UI_MacroblockSelection::GetMacroblockId(), ClickedCoord);
							}
						}
					}
				}
			}
		}
		case C_Sequence_TestMode: {
			switch (EventType) {
				case UI_SpawnSelection::Event_SpawnHover(): {
					GoToSpawn(TL::ToInteger(EventData[0]));
				}
				case UI_SpawnSelection::Event_SpawnClick(): {
					GoToSpawn(TL::ToInteger(EventData[0]));
					StartTest();
				}
				case UI_SpawnSelection::Event_SpawnNext(): {
					SelectSpawn(1); ///< Next checkpoint
				}
				case UI_SpawnSelection::Event_SpawnPrev(): {
					SelectSpawn(-1); ///< Previous checkpoint
				}
				case UI_Header::Event_SelectMode(): {
					SetTestMode(False);
					SelectMode(EventData[0]);
				}
				case UI_Header::Event_SwitchMode(): {
					SetTestMode(False);
					SwitchMode(C_Categories_Construct); ///< Switch mode
				}
			}
		}
		case C_Sequence_EditTerrain: {
			if (UI_MacroblockSelection::IsSelecting()) {
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
				}
			} else {
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					default : {
						if (
							EventType == UI_MouseControl::Event_SelectionStart() ||
							EventType == UI_MouseControl::Event_SelectionUpdate() ||
							EventType == UI_MouseControl::Event_SelectionStop()
						) {
							declare ClickedCoord = GetMouseCoordOnGround();
							if (ClickedCoord != <-1, -1, -1>) {
								MoveTerrain(
									ClickedCoord - G_ForcedCursorCoord,
									False,
									EventType == UI_MouseControl::Event_SelectionStop()
								);
							}
						}
					}
				}
			}
		}
		case C_Sequence_EditDecoration: {
			ValidateTutoRosaces(EventType);
			if (UI_MacroblockSelection::IsSelecting()) {
				//ValidateTutoRosaces(EventType);
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
				}
			} else {
				TriggerSkinInput(EventType, EventData);
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_MouseControl::Event_GetCoordinates(): {
						declare ClickedCoord = GetMouseCoordAtHeight(CursorCoord.Y);
						if (ClickedCoord != <-1, -1, -1>) {
							if (ClickedOnBlock()) {
								declare MacroblockPlaced = ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId());
								if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_PlaceBlock_Mouse())) {
									UI_Tuto::Validate(UI_Tuto::Tuto_PlaceBlock_Mouse());
									CheckTuto();
								}
							} else {
								MoveMacroblock(ClickedCoord - G_ForcedCursorCoord, False);
								ExpertCursorConnect(UI_MacroblockSelection::GetMacroblockId(), ClickedCoord);
							}
						}
					}
				}
			}
		}
		case C_Sequence_Simple_Terraforming: {
			switch (EventType) {
				case UI_StyleSelection::Event_StyleClick(): {
					if (IsEditor(C_Editor_Advanced)) { SelectStyle(EventData[0]); UpdateLandscapeSimpleChoice(); }
				}
				case UI_StyleSelection::Event_StyleNext(): {
					if (IsEditor(C_Editor_Advanced)) { NextStyle(); UpdateLandscapeSimpleChoice(); }
				}
				case UI_StyleSelection::Event_StylePrev(): {
					if (IsEditor(C_Editor_Advanced)) { PrevStyle(); UpdateLandscapeSimpleChoice(); }
				}
				case UI_SimpleChoice::Event_Click(): {
					declare Action = TL::ToInteger(EventData[0]);
					if (Action == C_SimpleChoice_SelectLandscape || Action == C_SimpleChoice_StartTrack) SelectTerrain();
				}
			}
		}
		case C_Sequence_Simple_PlaceStart: {
			switch (EventType) {
				case UI_MacroblockSelection::Event_MacroblockHover(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]), True);
				}
				case UI_MacroblockSelection::Event_MacroblockClick(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]));
					declare MacroblockPlaced = AddMacroblock2(UI_MacroblockSelection::GetMacroblockId());
				}
				case UI_StyleSelection::Event_StyleClick(): {
					if (IsEditor(C_Editor_Advanced)) SelectStyle(EventData[0]);
				}
				case UI_StyleSelection::Event_StyleNext(): {
					if (IsEditor(C_Editor_Advanced)) NextStyle();
				}
				case UI_StyleSelection::Event_StylePrev(): {
					if (IsEditor(C_Editor_Advanced)) PrevStyle();
				}
				case UI_MacroblockSelection::Event_FamilyClick(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::SelectFamily(EventData[0], True);
				}
				case UI_MacroblockSelection::Event_FamilyNext(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::NextFamily(); ///< Select next family
				}
				case UI_MacroblockSelection::Event_FamilyPrev(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::PrevFamily(); ///< Select previous family
				}
				case UI_MacroblockSelection::Event_MacroblockNext(): {
					UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
				}
				case UI_MacroblockSelection::Event_MacroblockPrev(): {
					UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				}
			}
		}
		case C_Sequence_Simple_BuildTrack: {
			switch (EventType) {
				case UI_MacroblockSelection::Event_MacroblockHover(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]), True);
				}
				case UI_MacroblockSelection::Event_MacroblockClick(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]));
					declare MacroblockPlaced = AddMacroblock2(UI_MacroblockSelection::GetMacroblockId());
				}
				case UI_StyleSelection::Event_StyleClick(): {
					if (IsEditor(C_Editor_Advanced)) SelectStyle(EventData[0]);
				}
				case UI_StyleSelection::Event_StyleNext(): {
					if (IsEditor(C_Editor_Advanced)) NextStyle();
				}
				case UI_StyleSelection::Event_StylePrev(): {
					if (IsEditor(C_Editor_Advanced)) PrevStyle();
				}
				case UI_MacroblockSelection::Event_FamilyClick(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::SelectFamily(EventData[0], True);
				}
				case UI_MacroblockSelection::Event_FamilyNext(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::NextFamily(); ///< Select next family
				}
				case UI_MacroblockSelection::Event_FamilyPrev(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::PrevFamily(); ///< Select previous family
				}
				case UI_MacroblockSelection::Event_MacroblockNext(): {
					UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
				}
				case UI_MacroblockSelection::Event_MacroblockPrev(): {
					UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				}
				case CutPaste::Event_Paste(): {
					if (CutPasteIsAllowed()) PasteMacroblock();
				}
				case CutPaste::Event_Discard(): {
					if (CutPasteIsAllowed()) SkipMacroblock();
				}
			}
		}
		case C_Sequence_Simple_MoveCursor: {
			switch (EventType) {
				case UI_MacroblockSelection::Event_MacroblockHover(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]), True);
				}
				case UI_MacroblockSelection::Event_MacroblockClick(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]));
					declare MacroblockPlaced = AddMacroblock2(UI_MacroblockSelection::GetMacroblockId());
				}
				case UI_StyleSelection::Event_StyleClick(): {
					if (IsEditor(C_Editor_Advanced)) SelectStyle(EventData[0]);
				}
				case UI_StyleSelection::Event_StyleNext(): {
					if (IsEditor(C_Editor_Advanced)) NextStyle();
				}
				case UI_StyleSelection::Event_StylePrev(): {
					if (IsEditor(C_Editor_Advanced)) PrevStyle();
				}
				case UI_MacroblockSelection::Event_FamilyClick(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::SelectFamily(EventData[0], True);
				}
				case UI_MacroblockSelection::Event_FamilyNext(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::NextFamily(); ///< Select next family
				}
				case UI_MacroblockSelection::Event_FamilyPrev(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::PrevFamily(); ///< Select previous family
				}
				case UI_MacroblockSelection::Event_MacroblockNext(): {
					UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
				}
				case UI_MacroblockSelection::Event_MacroblockPrev(): {
					UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				}
			}
		}
		case C_Sequence_Simple_Test: {
			switch (EventType) {
				case UI_SpawnSelection::Event_SpawnHover(): {
					GoToSpawn(TL::ToInteger(EventData[0]));
				}
				case UI_SpawnSelection::Event_SpawnClick(): {
					GoToSpawn(TL::ToInteger(EventData[0]));
					StartTest();
				}
				case UI_SpawnSelection::Event_SpawnNext(): {
					SelectSpawn(1); ///< Next checkpoint
				}
				case UI_SpawnSelection::Event_SpawnPrev(): {
					SelectSpawn(-1); ///< Previous checkpoint
				}
			}
		}
		case C_Sequence_Simple_Deco: {
			switch (EventType) {
				case UI_DecoSelection::Event_DecoClick(): {
					UI_DecoSelection::SelectFamily(EventData[0], True);
				}
				case UI_DecoSelection::Event_DecoNext(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::NextFamily();
				}
				case UI_DecoSelection::Event_DecoPrev(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::PrevFamily();
				}
				case UI_DecoSelection::Event_DecoMore(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::More();
				}
				case UI_DecoSelection::Event_DecoLess(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::Less();
				}
				case UI_DecoSelection::Event_GaugeClick(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::SetRatio(EventData[0], TL::ToReal(EventData[1]));
				}
				case UI_SimpleChoice::Event_Click(): {
					declare Action = TL::ToInteger(EventData[0]);
					switch (Action) {
						case C_SimpleChoice_DecoGenerate: RandomDecorate2(False); ///< Generate random decoration
						case C_SimpleChoise_DecoValid	: ConfirmDecoration(); ///< Confirm the decoration
						case C_SimpleChoice_DecoCancel	: CancelDecoration(); ///< Cancel decoration
						case C_SimpleChoice_DecoDefault	: DefaultDecoration(); ///< Use default decoration settings
					}
				}
			}
		}
		case C_Sequence_Simple_Outro: {
			switch (EventType) {
				case UI_MenuOutro::Event_Hover(): UI_MenuOutro::Select(TL::ToInteger(EventData[0]), True);
				case UI_MenuOutro::Event_Click(): {
					UI_MenuOutro::Select(TL::ToInteger(EventData[0]));
					OutroMenuValid(); ///< Valid menu selection
				}
			}
		}
	}
}

// ---------------------------------- //
/// Generate a full random map
Void RandomMap() {
	G_RandomMapGeneration = True;
	RandomStyles::ClearStyles();
	
	declare metadata PartyEditor_RandomSeed for Map = -1;
	PartyEditor_RandomSeed = -1;
	
	if (S_RandomMap_Config != "") {
		RandomStyles::ReadStyles(S_RandomMap_Config, True);
	} else {
		RandomStyles::ApplyStyles([S_RandomMap_Length, S_RandomMap_Speed, S_RandomMap_Style], True);
	}
	
	RandomStyles::LoadDefaultStyles();
	
	// Init camera in VR
	if (ManiaPlanet.HMD_IsActive) {
		Camera::MoveTo(<Map.Size.X/2, Map.Size.Y, Map.Size.Z/2>);
		Camera::ZoomTo(800.);
		Camera::RotateTo(Camera::GetRotation().X, 2);
	}
	
	declare FirstRoll = True;
	declare MapCreated = False;
	G_RerollRandomMap = True;
	Camera::EnableMouseRotation(True);
	Camera::EnableMouseZoom(True);
	while (G_RerollRandomMap) {
		G_WaitingRerollAnswer = (!FirstRoll && MapContent::HasFinish()) || MapContent::HasFinish() || G_CancelGeneration;
		SelectSequence();
		ClearInputBuffer();
		G_TerrainCanPress = False;
		while (G_WaitingRerollAnswer) {
			Yield();
			
			if (G_LeaveEditor) {
				CustomQuit();
				G_LeaveEditor = False;
			}
			
			if (G_RestartGeneration) {
				RerollRandomMap(True);
				G_RestartGeneration = False;
				break;
			}
			
			// Force sequence update when turning on/off HMD
			if (G_HMD_IsActive != ManiaPlanet.HMD_IsActive) {
				G_HMD_IsActive = ManiaPlanet.HMD_IsActive;
				OnSequenceStart(G_CurrentSequence);
			}
			
			foreach (Key => Input in G_InputBuffer) {
				TriggerInput(Input, G_DeviceBuffer[Key]);
			}
			foreach (Input in G_UIInputBuffer) {
				TriggerInput(Input);
			}
			ClearInputBuffer();
			
			// Update camera
			Camera::MouseLoop();
			
			G_TerrainCanPress = False;
		}
		SelectSequence();
		
		if (!G_RerollRandomMap) break;
		
		G_TestedRandomMap = False;
		
		// Init random seed
		if (FirstRoll && S_RandomMap_Seed != 0) {
			Random::Init(S_RandomMap_Seed);
		} else {
			Random::Init();
		}
		FirstRoll = False;
		
		// Get and save the seed used to create this map
		PartyEditor_RandomSeed = Random::GetSeed();
		Utils::Log("[Random] Seed : "^PartyEditor_RandomSeed);
		
		// Determine a length for the map
		// We have to do it event if it's already defined in the settings
		// This way the random seed will be valid with our without setting
		declare RandomLength = Random::Rand(0, 7);
		declare Length = "";
		if (RandomLength <= 3) Length = "short";
		else if (RandomLength <= 5) Length = "veryshort";
		else if (RandomLength <= 6) Length = "medium";
		else Length = "long";
		// Override length
		if (S_RandomMap_Length != "") Length = S_RandomMap_Length;
		RandomStyles::ApplyStyles([Length], False);
		MapInfo::SetRandomMapLength(Length);
		
		// Init camera in VR (top-down view)
		if (ManiaPlanet.HMD_IsActive) {
			Camera::MoveTo(<Map.Size.X/2, Map.Size.Y, Map.Size.Z/2>);
			Camera::ZoomTo(800.);
			Camera::RotateTo(Camera::GetRotation().X, 2);
		}
		
		G_CancelGeneration = False;
		
		Utils::LogToFile(C_LogToFile);
		Utils::ResetLogFile();
		LogRandomMap("[Random] Seed : "^PartyEditor_RandomSeed);
		
		// Generate a complete map
		declare TriesNb = 1;
		while (TriesNb <= C_RandomMap_MaxTries && !G_CancelGeneration) {
			MapCreated = Private_RandomMap(True);
			if (MapCreated) break;
			TriesNb += 1;
		}
		
		// Generate a really simple map if all tries failed
		if (!MapCreated) {
			TriesNb = 1;
			while (TriesNb <= C_RandomMap_MaxTries && !G_CancelGeneration) {
				MapCreated = Private_RandomMap(False);
				if (MapCreated) break;
				TriesNb += 1;
			}
		}
		
		if (C_LogToFile) Utils::ViewLogFile();
		
		// Align camera in VR (center on map view)
		/*if (ManiaPlanet.HMD_IsActive) {
			Camera::ResetTracking();
			Camera::CenterOnMap(C_Modes_ConstructTrack, C_CameraZoom_Reroll);
		}*/
	}
	Camera::EnableMouseRotation(True);
	Camera::EnableMouseZoom(True);
	
	// Reset all and switch to manual mode if we failed to generate a map
	if (!MapCreated) {
		Reset();
	} 
	// Validate the map if we succeed to generate it
	else {
		// Force validation and map type update
		MapTypeSynchro::SetLength(RandomStyles::GetLength());
		MapTypeSynchro::ForceValidation(True);
		MapTypeSynchro::AskSynchro();
		declare MaxDuration = Now + 2500;
		while (!MapTypeSynchro::Synchronized()) {
			Yield();
			if (Now > MaxDuration) break;
		}
		
		CustomSaveMap(False);
		CustomQuit("EditorRandomGenerationFinished", [GetMapName()]);
		//CustomPlay(True);
	}
	
	G_RandomMapGeneration = False;
}

// ---------------------------------- //
/// Initialize the deco families
Void InitDecoFamilies() {
	// Initialize deco selection UI
	declare DecoMacroblockModels = GetDecorationMacroblocks(False);
	declare DecoFamilies = Text[];
	foreach (Family => DecoMacroblocks in DecoMacroblockModels) {
		if (Family == "|Decoration|Podium" || Family == "|Decoration|Flying") continue;
		DecoFamilies.add(Family);
	}
	UI_DecoSelection::SetFamilies(DecoFamilies);
	//UI_DecoSelection::SetRatios(ThemePack::GetDecoRatios());
	UI_DecoSelection::SetColors(ThemePack::GetDecoColors());
	
	declare metadata Real[Text] PartyEditor_DecoRatios for Map;
	declare DecoRatios = ThemePack::GetDecoRatios();
	foreach (Category => Ratio in PartyEditor_DecoRatios) {
		if (DecoRatios.existskey(Category)) DecoRatios[Category] = Ratio;
	}
	UI_DecoSelection::SetRatios(DecoRatios);
}

// ---------------------------------- //
/// Start the classic editor
Void StartClassicEditor() {
	G_StartClassicEditor = False;
	
	// Are we loading a classic map ?
	declare metadata PartyEditor_Setting_EditorLevel for Map = 0;
	declare IsClassicTrack = PartyEditor_Setting_EditorLevel == C_Editor_Classic;
	
	// Ask confirmation if the map was not already save from classic editor
	declare ConfirmClassic = True;
	if (!IsClassicTrack) {
		ConfirmClassic = Confirm(
			//L16N [MapEditor] Title of the warning displayed before starting the classic editor
			_("Classic trackbuilder"), 
			//L16N [MapEditor] Warning displayed before starting the classic editor
			_("The classic trackbuilder only support keyboard and mouse controls. Once a map has been converted, it can not be edited in the other trackbuilders anymore. Are you sure you want to start the classic trackbuilder?"), 
			//L16N [MapEditor] Validate an action
			_("Yes"),
			//L16N [MapEditor] Cancel an action
			_("No")
		);
	}
	if (!ConfirmClassic) return;
	
	if (!IsClassicTrack) {
		// Ask for a last save before converting the track
		declare ConfirmSave = Confirm(
				//L16N [MapEditor] Title of the warning displayed before starting the classic editor
				_("Classic trackbuilder"), 
				//L16N [MapEditor] Warning displayed before starting the classic editor
				_("Do you want to save your map before converting it?"), 
				//L16N [MapEditor] Validate an action
				_("Yes"),
				//L16N [MapEditor] Cancel an action
				_("No")
			);
		if (ConfirmSave) CustomSaveMap(False, False);
	}
	
	// Reset camera, inputs and cursor
	SetCursorCoord(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>);
	CustomSelectionCoords.clear();
	ClearInputBuffer();
	Camera::Init();
	
	// Config UI
	UI_MapStyleSelection::DisplayBackground(True);
	UI_ShadowMenu::SetOptions([UI_ShadowMenu::Selection_None(), UI_ShadowMenu::Selection_VeryFast(), UI_ShadowMenu::Selection_Fast(), UI_ShadowMenu::Selection_Nice(), UI_ShadowMenu::Selection_VeryNice()]);
	
	// Change editor level
	PartyEditor_Setting_EditorLevel = C_Editor_Classic;
	G_Setting_EditorLevel = PartyEditor_Setting_EditorLevel;
	
	// Reset sequence
	G_RandomMapGeneration = False;
	G_MapStyleSelection = False;
	G_MainMenu = False;
	SelectSequence();
	
	// Reset config
	HideEditorInterface = False;
	EnableEditorInputsCustomProcessing = False;
	HideAlwaysCursorDirectionalArrow = False;
	CursorBrightnessFactor = 1.;
	HideBlockHelpers = False;
	ShowPlacementGrid = False;
	EnableUnlimitedUndoHistory = False;
	EnableCursorShowingWhenInterfaceIsFocused = True;
	
	// Reset place and edit modes
	SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Block, CEditorPlugin::EditMode::Place);
	
	// Remove mouse control
	UI_MouseControl::Unload();
	
	// Start classic editor
	TurboClassicMapEditorMode = True;
	CoppersLimit = C_CopperLimit_Hard;
	
	// Save map with a new name
	if (!IsClassicTrack) CopyMap(False);
	
	declare PrevThumbnailUpdate = MapTypeSynchro::GetThumbnailUpdate();
	
	while (True) {
		Yield();
		SelectSequence();
		
		// Update thumbnail
		if (PrevThumbnailUpdate != MapTypeSynchro::GetThumbnailUpdate()) {
			PrevThumbnailUpdate = MapTypeSynchro::GetThumbnailUpdate();
			Camera::UpdateThumbnail(MapTypeSynchro::GetThumbnailPos(), MapTypeSynchro::GetThumbnailRot(), MapTypeSynchro::GetThumbnailFov());
			declare metadata PartyEditor_HasCustomThumbnail for Map = False;
			PartyEditor_HasCustomThumbnail = True;
			MapModified();
		}
	
		// Manage events
		foreach (Event in PendingEvents) {
			if (Event.Type == CEditorPluginEvent::Type::EditorInput) {
				if (Event.Input == CEditorPluginEvent::EInput::Save) {
					EnableEditorInputsCustomProcessing = True;
					CustomSaveMap(False);
					EnableEditorInputsCustomProcessing = False;
				} else if (Event.Input == CEditorPluginEvent::EInput::SaveAs) {
					EnableEditorInputsCustomProcessing = True;
					CustomSaveMap(True);
					EnableEditorInputsCustomProcessing = False;
				} else if (Event.Input == CEditorPluginEvent::EInput::MapStyle) {
					// Set the number of laps
					if (GetStartLineBlock() != Null && GetStartLineBlock().BlockModel.WaypointType == CBlockModel::EWayPointType::StartFinish) {
						UI_Multilaps::Show();
						
						while (!UI_Multilaps::Confirmed() && !UI_Multilaps::Canceled()) {
							Yield();
							UI_Multilaps::Loop();
						}
						
						UI_Multilaps::Hide();
						declare Confirmed = UI_Multilaps::Confirmed();
					}
			
					G_MapStyleSelection = True;
					SelectSequence();
					ClearInputBuffer();
					G_TerrainCanPress = False;
					
					EnableEditorInputsCustomProcessing = True;
					while (G_MapStyleSelection) {
						Yield();
						declare TmpCanceled = UpdateMapStyleSelection();
					}
					EnableEditorInputsCustomProcessing = False;
					
					SelectSequence();
				}
			}
		}
	}
}

// ---------------------------------- //
/// Unload the plugin
Void Unload() {
	UI_Header::Unload();
	UI_StyleSelection::Unload();
	UI_BlockHelp::Unload();
	UI_TerrainPreview::Unload();
	UI_MacroblockSelection::Unload();
	UI_SkinSelection::Unload();
	UI_SpawnSelection::Unload();
	UI_DecoSelection::Unload();
	UI_PopUp::Unload();
	UI_SimpleChoice::Unload();
	UI_Menu::Unload();
	UI_MenuOutro::Unload();
	UI_Progression::Unload();
	UI_SimpleMenu::Unload();
	UI_RandomMenu::Unload();
	UI_ShadowMenu::Unload();
	UI_Tuto::Unload();
	UI_Multilaps::Unload();
	UI_MouseControl::Unload();
	UI_MapStyleSelection::Unload();
	
	Collection::Unload();
	Transitions::Unload();
	ThemePack::Unload();
	RandomStyles::Unload();
	Terrain::Unload();
	Buttons::Unload();
	List::Unload();
	History2::Unload();
	CutPaste::Unload();
	MapContent::Unload();
	Camera::Unload();
	AutoFinish::Unload();
	Random::Unload();
	Sound::Unload();
	Music::Unload();
	Layers::Unload();
	Macroblock::Unload();
}

// ---------------------------------- //
/** Load the plugin
 *
 *	The Load() functions of the libraries can call yield;
 *	Be careful because this results on lost events, etc ...
 */
Void Load() {
	// Initialize default editor UI
	HideEditorInterface = !C_Debug;
	EnableEditorInputsCustomProcessing = True;
	HideAlwaysCursorDirectionalArrow = True;
	CursorBrightnessFactor = C_CursorVisibility;
	HideBlockHelpers = C_HideBlockHelpers;
	ShowPlacementGrid = C_ShowPlacementGrid;
	EnableUnlimitedUndoHistory = True;
	EnableCursorShowingWhenInterfaceIsFocused = True;
	
	Utils::EnableLog(C_EnableLog);
	Utils::IsTrialVersion(S_TrialVersion && IsEditor(C_Editor_Advanced));
	
	Unload();
	
	// Load buttons before any other lib use them
	Buttons::Load();
	
	// Display loading screen
	Layers::Load();
	UI_PopUp::Load();
	//L16N [MapEditor] Message displayed during a loading
	UI_PopUp::Loading(True, _("Loading"), True, False);
	Sleep(500);
	
	Macroblock::Load();
	Achievements::Load();
	
	// Preload blocks
	PreloadAllBlocks();
	
	SetPlaceAndEditModes(CEditorPlugin::PlaceMode::Unknown, CEditorPlugin::EditMode::FreeLook);
	G_RandomMapGeneration = S_RandomMap_Generate;
	
	// New map
	declare metadata PartyEditor_Setting_EditorLevel for Map = 0;
	if (GetMapName() == "") {
		declare EditorLevel = S_EditorLevel;
		if (S_RandomMap_Generate) EditorLevel = C_Editor_Expert;
		G_Setting_EditorLevel = EditorLevel;
		PartyEditor_Setting_EditorLevel = EditorLevel;
	} 
	// Load map
	else {
		G_Setting_EditorLevel = PartyEditor_Setting_EditorLevel;
	}
	
	// /!\ SYNCHRO OPERATION, EVENTS WILL BE LOST
	// Load theme pack
	ThemePack::Load(C_LogThemePack);
	ThemePack::UseRandomLandscapeGeneration(C_RandomLandscape);
	if (!G_RandomMapGeneration && IsEditor(C_Editor_Beginner)) {
		ThemePack::LoadConfig_Start(C_ThemePack_Beginner);
	} else if (!G_RandomMapGeneration && IsEditor(C_Editor_Advanced)) {
		ThemePack::LoadConfig_Start(C_ThemePack_Advanced);
	} else {
		ThemePack::LoadConfig_Start(C_ThemePack_Expert);
	}
	while (ThemePack::LoadConfig_IsLoading()) Yield();
	ThemePack::Sync_LoadConfig_End();
	ThemePack::Sync_GenerateMacroblockModelsList();
	
	if (C_LogThemePack && !ThemePack::LoadConfig_IsLoaded()) Utils::Log("Failed to load theme packs config file.");
	
	ThemePack::Select(0, 0);
	
	SystemText::Load();
	Random::Load();
	MapContent::Load();
	CutPaste::Load();
	History2::Load();
	List::Load();
	Terrain::Load();
	RandomStyles::Load();
	Transitions::Load();
	AutoFinish::Load();
	Camera::Load();
	Collection::Load();
	Yield(); ///< Yield before loading sounds because it takes a while
	Sound::Load();
	Music::Load(S_RandomMap_Generate);
	//LoadingScreen::Load();
	
	// Play music if we are not in the random track generator
	if (C_Music && !S_RandomMap_Generate) {
		Music::Reset(True);
		Music::SetTracks([Music::GetTrack("Trackbuilder")]);
	}
	
	// Yied between Load() to spread the manialink script compilation
	UI_Header::Load();
	Yield();
	UI_StyleSelection::Load();
	Yield();
	UI_BlockHelp::Load();
	Yield();
	UI_TerrainPreview::Load();
	Yield();
	UI_MacroblockSelection::Load(IsSimpleEditor());
	Yield();
	UI_SkinSelection::Load();
	Yield();
	UI_SpawnSelection::Load();
	Yield();
	UI_DecoSelection::Load();
	Yield();
	UI_SimpleChoice::Load();
	Yield();
	UI_Menu::Load();
	Yield();
	UI_MenuOutro::Load(IsEditor(C_Editor_Advanced));
	Yield();
	UI_Progression::Load(IsEditor(C_Editor_Advanced));
	Yield();
	UI_SimpleMenu::Load();
	Yield();
	UI_RandomMenu::Load();
	Yield();
	UI_ShadowMenu::Load();
	Yield();
	UI_Tuto::Load();
	Yield();
	UI_Multilaps::Load();
	Yield();
	UI_MouseControl::Load();
	Yield();
	UI_MapStyleSelection::Load();
	Yield();
	
	// Select map style
	declare metadata PartyEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
	UI_MapStyleSelection::Select(PartyEditor_MapStyle);
	UI_MapStyleSelection::DisplayBackground(IsEditor(C_Editor_Expert));
	
	// Let the layers initialize their variables for Page
	Sleep(50);
	
	if (GetMapName() == "") Utils::SetSaveStatus(Utils::SaveStatus_NotSaved());
	else Utils::SetSaveStatus(Utils::SaveStatus_Saved());
	
	Camera::SetTerraformingZoom(C_CameraZoom_Terraforming);
	Camera::CenterOnClips(IsEditor(C_Editor_Expert));
	Camera::Init();
	UI_Header::SetLimit(C_CopperLimit_Hard);
	UI_Header::SetLimitVisibility(!S_RandomMap_Generate);
	CustomSelectionCoords.clear();
	SetFreeModeVariant(Macroblock::VariantNull());
	SetCursorCoord(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>);
	
	G_RandomMacroblocks.clear();
	foreach (MacroblockModel in MacroblockModels) {
		G_RandomMacroblocks.add(MacroblockModel);
	}
	Yield();
	
	G_CurrentSequence = C_Sequence_None;
	G_PrevSequence = C_Sequence_None;
	G_TestMode = False;
	G_PreviewTerrainTime = -1;
	G_PreviewTerrainId = "";
	G_AutoRepeatInput.clear();
	ClearInputBuffer();
	G_TerrainCanPress = False;
	G_CancelGeneration = False;
	G_LeaveEditor = False;
	G_StartingNewMap = !MapContent::HasStart();
	G_MainMenu = False;
	G_MapStyleSelection = False;
	G_IsSkinning = False;
	G_IsEditing = False;
	G_ForcedCursorCoord = CursorCoord;
	G_SavedCursorCoord.clear();
	G_LastRandomPlace = -1;
	G_AllowLongPress = False;
	G_InactivityStartTime = -1;
	G_AskForDeco = False;
	G_AskForValidation = False;
	G_AvailableMacroblocks.clear();
	G_DiscardedMacroblocks.clear();
	G_AvailableConnectors.clear();
	G_CursorConnectedTo = -1;
	G_MacroblocksCount = 0;
	Camera::DefaultZoomMinMax();
	Camera::MouseNeedInit(False);
	G_HMD_IsActive = ManiaPlanet.HMD_IsActive;
	G_NeedRebuild = IsEditor(C_Editor_Advanced);
	G_MoveCursor = False;
	G_CanAskCheckpoint = False;
	G_TestedRandomMap = False;
	G_RebuildMap = False;
	G_Platform = Buttons2::System_PC();
	G_CacheBlocksSkins.clear();
	G_StartClassicEditor = IsEditor(C_Editor_Classic);
	
	declare PartyEditor_NeedSimpleBlock for Map = False;
	PartyEditor_NeedSimpleBlock = True;
	
	// Load thumbnail camera
	MapTypeSynchro::SetThumbnailPos(ThumbnailCameraPosition);
	MapTypeSynchro::SetThumbnailRot(<ThumbnailCameraHAngle, ThumbnailCameraVAngle, ThumbnailCameraRoll>);
	
	// Check if we can skip the terraforming sequence
	CanSkipTerrain();
	
	Yield();
	if (IsTerraformed()) {
		InitConstructMode();
	} else {
		if (IsSimpleEditor()) SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
		else SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	}
	
	Yield();
	SelectSequence();
	
	if (IsEditor(C_Editor_Advanced)) {
		InitDecoFamilies();
		UI_MacroblockSelection::DisplayNames(True);
		UI_Header::SetEditor(UI_Header::Editor_Advanced());
		UI_MacroblockSelection::SetEditor(UI_MacroblockSelection::Editor_Advanced());
	} else if (IsEditor(C_Editor_Beginner)) {
		InitDecoFamilies();
		UI_MacroblockSelection::DisplayNames(False);
		UI_Header::SetEditor(UI_Header::Editor_Beginner());
		UI_MacroblockSelection::SetEditor(UI_MacroblockSelection::Editor_Beginner());
	} else {
		if (G_RandomMapGeneration) UI_Header::SetEditor(UI_Header::Editor_Random());
		else UI_Header::SetEditor(UI_Header::Editor_Expert());
		UI_MacroblockSelection::SetEditor(UI_MacroblockSelection::Editor_Expert());
		UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
	}
	
	Loading(False);
}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	// Force the default loading screen display until the plugin finish loading
	HoldLoadingScreen = True;
	// Hide the editor interface by default
	HideEditorInterface = True;
	
	// Don't use Yield() function before the librairies are loaded, because Yield() use these librairies (eg: gamepad disconnected window, TRAC-1751)
	yield; //< Script compilation complete, yield to go to next frame
	
	// Create a copy of the map
	if (S_CreateCopy) CopyMap(True);
	
	Load();
	
	Sleep(250); ///< Wait for the plugin loading screen to be hidden
	HoldLoadingScreen = False;
	
	declare PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
	declare PrevSelectedSkinUpdate = UI_SkinSelection::GetSkinUpdate();
	declare PrevAddTerrain = False;
	declare PrevRemoveTerrain = False;
	declare CursorPlaceStart = -1;
	declare CursorPlaceSequence = C_Sequence_None;
	declare PrevCopperPrice = 0;
	declare CanShowSoftLimit = True;
	declare AskCheckpoint = False;
	declare PrevCanRotateCamera = False;
	declare PrevCanZoomCamera = False;
	
	if (G_NeedRebuild) {
		if (!MapContent::HasStart()) RebuildMap(True, False, False);
		else if (!MapContent::HasFinish()) RebuildMap(True, True, False);
		else if (!DecoConfirmed()) RebuildMap(True, True, True);
	}
	
	// Clear inputs done during loading
	ClearInputBuffer();
	
	// Run a random generation
	while (S_RandomMap_Generate) {
		RandomMap();
	}
	
	while (True) {
		Yield();
		
		// Check for classic editor
		if (G_StartClassicEditor) {
			StartClassicEditor();
		}
		
		// Force sequence update when turning on/off HMD
		if (G_HMD_IsActive != ManiaPlanet.HMD_IsActive) {
			G_HMD_IsActive = ManiaPlanet.HMD_IsActive;
			OnSequenceStart(G_CurrentSequence);
		}
		
		// Cursor place short/long press
		declare CursorPlaceLongPress = False;
		declare CursorPlaceShortPress = False;
		if (G_AllowLongPress) {
			if (EditorInputIsDown_CursorPlace) {
				if (CursorPlaceStart < 0) CursorPlaceStart = Now;
				if (Now - CursorPlaceStart >= 500) CursorPlaceLongPress = True;
			} else {
				G_AllowLongPress = False;
				if (CursorPlaceStart >= 0) {
					if (Now - CursorPlaceStart < 500) CursorPlaceShortPress = True;
					CursorPlaceStart = -1;
				}
			} 
		}
	
		// Select the sequence to use
		SelectSequence();
		
		// User input
		foreach (Key => Input in G_InputBuffer) {
			if (G_DeviceBuffer.existskey(Key)) { ///< The two arrays can be cleared during TriggerInput, so we must check they are not empty
				TriggerInput(Input, G_DeviceBuffer[Key]);
			}
		}
		foreach (Input in G_UIInputBuffer) {
			TriggerInput(Input);
		}
		ClearInputBuffer();
		
		// Update camera
		declare CanRotateCamera = (
			G_CurrentSequence != C_Sequence_MapStyle &&
			G_CurrentSequence != C_Sequence_MainMenu &&
			!UI_MacroblockSelection::IsSelecting()
		);
		declare CanZoomCamera = (
			//G_CurrentSequence != C_Sequence_Simple_Outro &&
			//G_CurrentSequence != C_Sequence_Simple_Terraforming &&
			G_CurrentSequence != C_Sequence_RandomTerrain &&
			G_CurrentSequence != C_Sequence_SelectTerrain &&
			G_CurrentSequence != C_Sequence_MapStyle &&
			G_CurrentSequence != C_Sequence_MainMenu &&
			//G_CurrentSequence != C_Sequence_RerollMap &&
			!UI_MacroblockSelection::IsSelecting() &&
			!Camera::MouseNeedInit()
		);
		if (PrevCanRotateCamera != CanRotateCamera) {
			PrevCanRotateCamera = CanRotateCamera;
			Camera::EnableMouseRotation(CanRotateCamera);
		}
		if (PrevCanZoomCamera != CanZoomCamera) {
			PrevCanZoomCamera = CanZoomCamera;
			Camera::EnableMouseZoom(CanZoomCamera);
		}
		Camera::MouseLoop();
		
		if (G_CurrentSequence != C_Sequence_EditTerrain) G_TerrainCanPress = False;
		
		// Select the sequence to use
		SelectSequence();
		
		// Check copper limit
		if (PrevCopperPrice != Map.CopperPrice && MustCheckCoppersLimit()) {
			PrevCopperPrice = Map.CopperPrice;
			if (!CanShowSoftLimit && Map.CopperPrice < C_CopperLimit_Soft - 250) CanShowSoftLimit = True;
			if (CanShowSoftLimit && Map.CopperPrice > C_CopperLimit_Soft) {
				CanShowSoftLimit = False;
				Alert(
					//L16N [MapEditor] Title of a pop-up displaying informations about the track editor
					_("Caution"), 
					//L16N [MapEditor] Pop-up warning the player that he has almost reached the maximum number of blocks that can be placed in the track.
					_("You have almost reached the maximum number of blocks that can be placed in the track."),
					//L16N [MapEditor] Confirm an action
					_("|Infinitive|Confirm")
				);
			}
		}
		
		// ---------------------------------- //
		// Construct the track
		if (G_CurrentSequence == C_Sequence_ConnectMode) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId());
			}
			
			if (CursorPlaceShortPress) {
				declare MacroblockPlaced = AddMacroblock2(UI_MacroblockSelection::GetMacroblockId());
			} else if (CursorPlaceLongPress) {
				AddRandomMacroblock2();
			}
		}
		// ---------------------------------- //
		// Free mode
		else if (G_CurrentSequence == C_Sequence_FreeMode) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				
				declare MacroblockId = UI_MacroblockSelection::GetMacroblockId();
				if (MacroblockId != NullId) PreviewMacroblock(MacroblockId, True);
			}
			
			if (PrevSelectedSkinUpdate != UI_SkinSelection::GetSkinUpdate()) {
				PrevSelectedSkinUpdate = UI_SkinSelection::GetSkinUpdate();
				SetSkin(UI_SkinSelection::GetSkinIndex());
			}
		}
		// ---------------------------------- //
		// Place a start block
		else if (IsPlacingStart()) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), True);
				CheckTuto();
			}
			
			if (PrevSelectedSkinUpdate != UI_SkinSelection::GetSkinUpdate()) {
				PrevSelectedSkinUpdate = UI_SkinSelection::GetSkinUpdate();
				SetSkin(UI_SkinSelection::GetSkinIndex());
			}
		}
		// ---------------------------------- //
		// Place terrain
		else if (G_CurrentSequence == C_Sequence_SelectTerrain) {
			//PreviewTerrain(UI_LandscapeSelection::GetTerrainId());
		}
		// ---------------------------------- //
		// Edit terrain
		else if (G_CurrentSequence == C_Sequence_EditTerrain) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				PreviewTerrainBlock(UI_MacroblockSelection::GetMacroblockId());
				SetCursorStyle();
			}
			
			declare MouseLeftButton = UI_MouseControl::MouseLeftButton();
			
			if (!G_TerrainCanPress) {
				G_TerrainCanPress = !MouseLeftButton && !EditorInputIsDown_CursorPlace && !EditorInputIsDown_CursorDelete;
			}
			
			declare CursorPlace = (
				G_TerrainCanPress &&
				(EditorInputIsDown_CursorPlace || MouseLeftButton) &&
				!EditorInputIsDown_CursorDelete
			);
			declare CursorDelete = (
				G_TerrainCanPress &&
				!EditorInputIsDown_CursorPlace &&
				(EditorInputIsDown_CursorDelete || MouseLeftButton)
			);
			if (CursorPlace && CursorDelete) {
				if (PrevAddTerrain) CursorDelete = False;
				else if (PrevRemoveTerrain) CursorPlace = False;
				else CursorDelete = False;
			}

			if (PrevAddTerrain != CursorPlace) {
				PrevAddTerrain = CursorPlace;
				AddTerrain2(CursorPlace);
			}
			
			if (PrevRemoveTerrain != CursorDelete) {
				PrevRemoveTerrain = CursorDelete;
				RemoveTerrain2(CursorDelete);
			}
		}
		// ---------------------------------- //
		// Edit decoration
		else if (G_CurrentSequence == C_Sequence_EditDecoration) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), True);
			}
			
			if (PrevSelectedSkinUpdate != UI_SkinSelection::GetSkinUpdate()) {
				PrevSelectedSkinUpdate = UI_SkinSelection::GetSkinUpdate();
				SetSkin(UI_SkinSelection::GetSkinIndex());
			}
			
			if (CursorPlaceShortPress) {
				declare MacroblockPlaced = AddDecoMacroblock2(UI_MacroblockSelection::GetMacroblockId());
			} else if (CursorPlaceLongPress) {
				AddRandomDecoration();
			}
		}
		// ---------------------------------- //
		// Simple terraforming
		else if (G_CurrentSequence == C_Sequence_Simple_Terraforming) {
			declare metadata Text PartyEditor_TerrainId for Map;
			/*if (PartyEditor_TerrainId != C_RandomTerrainId) {
				RandomTerrain(False);
				Sound::Play("EditorDisplayUI");
			}*/
			G_PreviewTerrainId = PartyEditor_TerrainId;
		}
		// ---------------------------------- //
		// Simple automatic terraforming
		else if (G_CurrentSequence == C_Sequence_Simple_AutoTerrain) {
			if (!IsTerraformed()) {
				RandomLandscape(True, False);
				// Save terrain
				declare metadata Boolean PartyEditor_IsTerraformed for Map;
				declare metadata Text PartyEditor_TerrainId for Map;
				PartyEditor_IsTerraformed = True;
				if (PartyEditor_TerrainId == "") PartyEditor_TerrainId = "Beginner";
				G_PreviewTerrainTime = -1;
				G_PreviewTerrainId = PartyEditor_TerrainId;
			}
		}
		// ---------------------------------- //
		// Simple build track
		else if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
			}
			
			if (IsEditor(C_Editor_Advanced) && GetStartLineBlock() == Null && MapContent::Count() > 0) {
				Alert(
					//L16N [MapEditor] Title of a pop-up displaying informations about the track editor
					_("Warning"), 
					//L16N [MapEditor] Pop-up warning the player that he can't remove the starting line block of his track.
					_("You can't remove the starting line of the track."),
					//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: going back to the previous edit mode.
					_("Back")
				);
				UndoHistory2();
			}
			
			// Remove the last placed block if no macroblocks are available to continue the track
			if (IsEditor(C_Editor_Beginner) && G_MacroblocksCount <= 0 && MapContent::HasStart() && !MapContent::HasFinish()) {
				Alert(
					//L16N [MapEditor] Pop-up warning the player that his track is in a dead end.
					_("Dead end"),
					//L16N [MapEditor] Pop-up warning the player that his track is in a dead end.
					_("The track is in a dead end. Try to go in another direction"),
					//L16N [MapEditor] Text displayed next to a button's picture describing the action of this button. Here: going back to the previous edit mode.
					_("Back")
				);
				declare TotalBeforeRemove = MapContent::Count();
				RemoveMacroblock2(G_FilteringCoord, False);
				
				// Couldn't remove the block, reset the map
				if (MapContent::Count() >= TotalBeforeRemove) {
					Reset();
				}
			}
			
			if (IsEditor(C_Editor_Beginner)) {
				declare LastCheckpointDistance = MapContent::GetDistanceTo(MapContent::Block_Checkpoint());
				if (LastCheckpointDistance < 300. && !AskCheckpoint) AskCheckpoint = True;
				if (
					G_AvailableCheckpoint != NullId &&
					G_CanAskCheckpoint &&
					AskCheckpoint &&
					LastCheckpointDistance > C_CheckpointGap
				) {
					declare PlaceCheckpoint = Confirm(
						//L16N [MapEditor] Warning displayed to encourage the player to place checkpoint blocks regularly in his map
						_("Try to place checkpoints regularly"), 
						//L16N [MapEditor] Pop-up asking the player if he wants to place a checkpoint now
						_("Do you want to place a checkpoint now?"), 
						//L16N [MapEditor] Validate an action
						_("Yes"),
						//L16N [MapEditor] Cancel an action
						_("No")
					);
					
					if (PlaceCheckpoint) {
						declare MacroblockPlaced = AddMacroblock2(G_AvailableCheckpoint);
					}
					
					AskCheckpoint = False;
				}
			}
			G_CanAskCheckpoint = False;
		} 
		// ---------------------------------- //
		// Simple move cursor
		else if (G_CurrentSequence == C_Sequence_Simple_MoveCursor) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				
				declare MacroblockId = UI_MacroblockSelection::GetMacroblockId();
				if (MacroblockId != NullId) PreviewMacroblock(MacroblockId, True);
			}
		}
		// ---------------------------------- //
		// Simple deco
		else if (G_CurrentSequence == C_Sequence_Simple_Deco) {
			/*if (G_AskForDeco) {
				declare DecorateMap = Confirm(
					_("Decorate map"),
					ComposeMultilines([
						_("You placed a finish block and completed the track."),
						_("Do you want to decorate it now or continue to edit it?")
					]),
					_("Decorate"),
					_("Edit")
				);
				if (DecorateMap) G_AskForDeco = False;
				else {
					SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
					RemoveAllFinishes(CutPasteIsAllowed());
				}
			}*//* else if (!IsDecorated()) {
				RandomDecorate2(False);
			}*/
		}
		// ---------------------------------- //
		// Outro menu
		else if (G_CurrentSequence == C_Sequence_Simple_Outro) {
			if (G_AskForValidation) {
				if (IsEditor(C_Editor_Beginner)) {
					RandomDecorate2(False);
				}
				
				if (ConfirmValidate()) {
					CustomValidate();
					
					/*declare ConfirmSaveMap = Confirm(
						//L16N [MapEditor] Pop-up asking the player if he wants to save his track.
						_("Save track"),
						//L16N [MapEditor] Pop-up asking the player if he wants to save his track.
						_("Do you want to save your track?"),
						//L16N [MapEditor] Validate an action
						_("Yes"),
						//L16N [MapEditor] Cancel an action
						_("No"),
						False
					);
					if (ConfirmSaveMap) CustomSaveMap(False);*/
				} else {
					// Remove finish and decoration when canceling in beginner
					if (IsEditor(C_Editor_Beginner)) {
						//SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
						//RemoveAllFinishes(CutPasteIsAllowed());
						CancelDecoration();
					}
				}
				
				G_AskForValidation = False;
			} else if (!UI_MenuOutro::IsVisible()) {
				UI_MenuOutro::Show();
			}
		}
	}
	
	Unload();
	EnableEditorInputsCustomProcessing = False;
}